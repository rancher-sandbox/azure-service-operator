// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

// The storage account.
type StorageAccount_STATUS struct {
	// ExtendedLocation: The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// Kind: Gets the Kind.
	Kind *Kind_STATUS `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Placement: Optional. Gets or sets the zonal placement details for the storage account.
	Placement *Placement_STATUS `json:"placement,omitempty"`

	// Properties: Properties of the storage account.
	Properties *StorageAccountProperties_STATUS `json:"properties,omitempty"`

	// Sku: Gets the SKU.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// Zones: The availability zones.
	Zones []string `json:"zones"`
}

// The complex type of the extended location.
type ExtendedLocation_STATUS struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationTypes_STATUS `json:"type,omitempty"`
}

// Identity for the resource.
type Identity_STATUS struct {
	// PrincipalId: The principal ID of resource identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of resource.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *IdentityType_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: Gets or sets a list of key value pairs that describe the set of User Assigned identities that
	// will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned
	// identity is permitted here.
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities"`
}

// Indicates the type of storage account.
type Kind_STATUS string

const (
	Kind_STATUS_BlobStorage      = Kind_STATUS("BlobStorage")
	Kind_STATUS_BlockBlobStorage = Kind_STATUS("BlockBlobStorage")
	Kind_STATUS_FileStorage      = Kind_STATUS("FileStorage")
	Kind_STATUS_Storage          = Kind_STATUS("Storage")
	Kind_STATUS_StorageV2        = Kind_STATUS("StorageV2")
)

// Mapping from string to Kind_STATUS
var kind_STATUS_Values = map[string]Kind_STATUS{
	"blobstorage":      Kind_STATUS_BlobStorage,
	"blockblobstorage": Kind_STATUS_BlockBlobStorage,
	"filestorage":      Kind_STATUS_FileStorage,
	"storage":          Kind_STATUS_Storage,
	"storagev2":        Kind_STATUS_StorageV2,
}

// The complex type of the zonal placement details.
type Placement_STATUS struct {
	// ZonePlacementPolicy: The availability zone pinning policy for the storage account.
	ZonePlacementPolicy *ZonePlacementPolicy_STATUS `json:"zonePlacementPolicy,omitempty"`
}

// The SKU of the storage account.
type Sku_STATUS struct {
	// Name: The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called
	// accountType.
	Name *SkuName_STATUS `json:"name,omitempty"`

	// Tier: The SKU tier. This is based on the SKU name.
	Tier *SkuTier_STATUS `json:"tier,omitempty"`
}

// Properties of the storage account.
type StorageAccountProperties_STATUS struct {
	// AccessTier: Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium'
	// access tier is the default value for premium block blobs storage account type and it cannot be changed for the premium
	// block blobs storage account type.
	AccessTier *AccessTier_STATUS `json:"accessTier,omitempty"`

	// AccountMigrationInProgress: If customer initiated account migration is in progress, the value will be true else it will
	// be null.
	AccountMigrationInProgress *bool `json:"accountMigrationInProgress,omitempty"`

	// AllowBlobPublicAccess: Allow or disallow public access to all blobs or containers in the storage account. The default
	// interpretation is false for this property.
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// AllowCrossTenantReplication: Allow or disallow cross AAD tenant object replication. Set this property to true for new or
	// existing accounts only if object replication policies will involve storage accounts in different AAD tenants. The
	// default interpretation is false for new accounts to follow best security practices by default.
	AllowCrossTenantReplication *bool `json:"allowCrossTenantReplication,omitempty"`

	// AllowSharedKeyAccess: Indicates whether the storage account permits requests to be authorized with the account access
	// key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure
	// Active Directory (Azure AD). The default value is null, which is equivalent to true.
	AllowSharedKeyAccess *bool `json:"allowSharedKeyAccess,omitempty"`

	// AllowedCopyScope: Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.
	AllowedCopyScope *AllowedCopyScope_STATUS `json:"allowedCopyScope,omitempty"`

	// AzureFilesIdentityBasedAuthentication: Provides the identity based authentication settings for Azure Files.
	AzureFilesIdentityBasedAuthentication *AzureFilesIdentityBasedAuthentication_STATUS `json:"azureFilesIdentityBasedAuthentication,omitempty"`

	// BlobRestoreStatus: Blob restore status
	BlobRestoreStatus *BlobRestoreStatus_STATUS `json:"blobRestoreStatus,omitempty"`

	// CreationTime: Gets the creation date and time of the storage account in UTC.
	CreationTime *string `json:"creationTime,omitempty"`

	// CustomDomain: Gets the custom domain the user assigned to this storage account.
	CustomDomain *CustomDomain_STATUS `json:"customDomain,omitempty"`

	// DefaultToOAuthAuthentication: A boolean flag which indicates whether the default authentication is OAuth or not. The
	// default interpretation is false for this property.
	DefaultToOAuthAuthentication *bool `json:"defaultToOAuthAuthentication,omitempty"`

	// DnsEndpointType: Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of
	// accounts in a single subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an
	// alphanumeric DNS Zone identifier.
	DnsEndpointType *DnsEndpointType_STATUS `json:"dnsEndpointType,omitempty"`

	// DualStackEndpointPreference: Maintains information about the Internet protocol opted by the user.
	DualStackEndpointPreference *DualStackEndpointPreference_STATUS `json:"dualStackEndpointPreference,omitempty"`

	// EnableExtendedGroups: Enables extended group support with local users feature, if set to true
	EnableExtendedGroups *bool `json:"enableExtendedGroups,omitempty"`

	// Encryption: Encryption settings to be used for server-side encryption for the storage account.
	Encryption *Encryption_STATUS `json:"encryption,omitempty"`

	// FailoverInProgress: If the failover is in progress, the value will be true, otherwise, it will be null.
	FailoverInProgress *bool `json:"failoverInProgress,omitempty"`

	// GeoPriorityReplicationStatus: Status indicating whether Geo Priority Replication is enabled for the account.
	GeoPriorityReplicationStatus *GeoPriorityReplicationStatus_STATUS `json:"geoPriorityReplicationStatus,omitempty"`

	// GeoReplicationStats: Geo Replication Stats
	GeoReplicationStats *GeoReplicationStats_STATUS `json:"geoReplicationStats,omitempty"`

	// ImmutableStorageWithVersioning: The property is immutable and can only be set to true at the account creation time. When
	// set to true, it enables object level immutability for all the containers in the account by default.
	ImmutableStorageWithVersioning *ImmutableStorageAccount_STATUS `json:"immutableStorageWithVersioning,omitempty"`

	// IsHnsEnabled: Account HierarchicalNamespace enabled if sets to true.
	IsHnsEnabled *bool `json:"isHnsEnabled,omitempty"`

	// IsLocalUserEnabled: Enables local users feature, if set to true
	IsLocalUserEnabled *bool `json:"isLocalUserEnabled,omitempty"`

	// IsNfsV3Enabled: NFS 3.0 protocol support enabled if set to true.
	IsNfsV3Enabled *bool `json:"isNfsV3Enabled,omitempty"`

	// IsSftpEnabled: Enables Secure File Transfer Protocol, if set to true
	IsSftpEnabled *bool `json:"isSftpEnabled,omitempty"`

	// IsSkuConversionBlocked: This property will be set to true or false on an event of ongoing migration. Default value is
	// null.
	IsSkuConversionBlocked *bool `json:"isSkuConversionBlocked,omitempty"`

	// KeyCreationTime: Storage account keys creation time.
	KeyCreationTime *KeyCreationTime_STATUS `json:"keyCreationTime,omitempty"`

	// KeyPolicy: KeyPolicy assigned to the storage account.
	KeyPolicy *KeyPolicy_STATUS `json:"keyPolicy,omitempty"`

	// LargeFileSharesState: Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
	LargeFileSharesState *LargeFileSharesState_STATUS `json:"largeFileSharesState,omitempty"`

	// LastGeoFailoverTime: Gets the timestamp of the most recent instance of a failover to the secondary location. Only the
	// most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only
	// available if the accountType is Standard_GRS or Standard_RAGRS.
	LastGeoFailoverTime *string `json:"lastGeoFailoverTime,omitempty"`

	// MinimumTlsVersion: Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS
	// 1.0 for this property.
	MinimumTlsVersion *MinimumTlsVersion_STATUS `json:"minimumTlsVersion,omitempty"`

	// NetworkAcls: Network rule set
	NetworkAcls *NetworkRuleSet_STATUS `json:"networkAcls,omitempty"`

	// PrimaryEndpoints: Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that
	// Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
	PrimaryEndpoints *Endpoints_STATUS `json:"primaryEndpoints,omitempty"`

	// PrimaryLocation: Gets the location of the primary data center for the storage account.
	PrimaryLocation *string `json:"primaryLocation,omitempty"`

	// PrivateEndpointConnections: List of private endpoint connection associated with the specified storage account
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections"`

	// ProvisioningState: Gets the status of the storage account at the time the operation was called.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: Allow, disallow, or let Network Security Perimeter configuration to evaluate public network access
	// to Storage Account.
	PublicNetworkAccess *PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// RoutingPreference: Maintains information about the network routing choice opted by the user for data transfer
	RoutingPreference *RoutingPreference_STATUS `json:"routingPreference,omitempty"`

	// SasPolicy: SasPolicy assigned to the storage account.
	SasPolicy *SasPolicy_STATUS `json:"sasPolicy,omitempty"`

	// SecondaryEndpoints: Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the
	// secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
	SecondaryEndpoints *Endpoints_STATUS `json:"secondaryEndpoints,omitempty"`

	// SecondaryLocation: Gets the location of the geo-replicated secondary for the storage account. Only available if the
	// accountType is Standard_GRS or Standard_RAGRS.
	SecondaryLocation *string `json:"secondaryLocation,omitempty"`

	// StatusOfPrimary: Gets the status indicating whether the primary location of the storage account is available or
	// unavailable.
	StatusOfPrimary *AccountStatus_STATUS `json:"statusOfPrimary,omitempty"`

	// StatusOfSecondary: Gets the status indicating whether the secondary location of the storage account is available or
	// unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
	StatusOfSecondary *AccountStatus_STATUS `json:"statusOfSecondary,omitempty"`

	// StorageAccountSkuConversionStatus: This property is readOnly and is set by server during asynchronous storage account
	// sku conversion operations.
	StorageAccountSkuConversionStatus *StorageAccountSkuConversionStatus_STATUS `json:"storageAccountSkuConversionStatus,omitempty"`

	// SupportsHttpsTrafficOnly: Allows https traffic only to storage service if sets to true.
	SupportsHttpsTrafficOnly *bool `json:"supportsHttpsTrafficOnly,omitempty"`
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

// Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium' access tier
// is the default value for premium block blobs storage account type and it cannot be changed for the premium block blobs
// storage account type.
type AccessTier_STATUS string

const (
	AccessTier_STATUS_Cold    = AccessTier_STATUS("Cold")
	AccessTier_STATUS_Cool    = AccessTier_STATUS("Cool")
	AccessTier_STATUS_Hot     = AccessTier_STATUS("Hot")
	AccessTier_STATUS_Premium = AccessTier_STATUS("Premium")
)

// Mapping from string to AccessTier_STATUS
var accessTier_STATUS_Values = map[string]AccessTier_STATUS{
	"cold":    AccessTier_STATUS_Cold,
	"cool":    AccessTier_STATUS_Cool,
	"hot":     AccessTier_STATUS_Hot,
	"premium": AccessTier_STATUS_Premium,
}

// Gets the status indicating whether the primary location of the storage account is available or unavailable.
type AccountStatus_STATUS string

const (
	AccountStatus_STATUS_Available   = AccountStatus_STATUS("available")
	AccountStatus_STATUS_Unavailable = AccountStatus_STATUS("unavailable")
)

// Mapping from string to AccountStatus_STATUS
var accountStatus_STATUS_Values = map[string]AccountStatus_STATUS{
	"available":   AccountStatus_STATUS_Available,
	"unavailable": AccountStatus_STATUS_Unavailable,
}

// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.
type AllowedCopyScope_STATUS string

const (
	AllowedCopyScope_STATUS_AAD         = AllowedCopyScope_STATUS("AAD")
	AllowedCopyScope_STATUS_PrivateLink = AllowedCopyScope_STATUS("PrivateLink")
)

// Mapping from string to AllowedCopyScope_STATUS
var allowedCopyScope_STATUS_Values = map[string]AllowedCopyScope_STATUS{
	"aad":         AllowedCopyScope_STATUS_AAD,
	"privatelink": AllowedCopyScope_STATUS_PrivateLink,
}

// Settings for Azure Files identity based authentication.
type AzureFilesIdentityBasedAuthentication_STATUS struct {
	// ActiveDirectoryProperties: Additional information about the directory service. Required if directoryServiceOptions is AD
	// (AD DS authentication). Optional for directoryServiceOptions AADDS (Entra DS authentication) and AADKERB (Entra
	// authentication).
	ActiveDirectoryProperties *ActiveDirectoryProperties_STATUS `json:"activeDirectoryProperties,omitempty"`

	// DefaultSharePermission: Default share permission for users using Kerberos authentication if RBAC role is not assigned.
	DefaultSharePermission *DefaultSharePermission_STATUS `json:"defaultSharePermission,omitempty"`

	// DirectoryServiceOptions: Indicates the directory service used. Note that this enum may be extended in the future.
	DirectoryServiceOptions *DirectoryServiceOptions_STATUS `json:"directoryServiceOptions,omitempty"`

	// SmbOAuthSettings: Required for Managed Identities access using OAuth over SMB.
	SmbOAuthSettings *SmbOAuthSettings_STATUS `json:"smbOAuthSettings,omitempty"`
}

// Blob restore status.
type BlobRestoreStatus_STATUS struct {
	// FailureReason: Failure reason when blob restore is failed.
	FailureReason *string `json:"failureReason,omitempty"`

	// Parameters: Blob restore request parameters.
	Parameters *BlobRestoreParameters_STATUS `json:"parameters,omitempty"`

	// RestoreId: Id for tracking blob restore request.
	RestoreId *string `json:"restoreId,omitempty"`

	// Status: The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing.
	// - Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed.
	Status *BlobRestoreProgressStatus_STATUS `json:"status,omitempty"`
}

// The custom domain assigned to this storage account. This can be set via Update.
type CustomDomain_STATUS struct {
	// Name: Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
	Name *string `json:"name,omitempty"`

	// UseSubDomainName: Indicates whether indirect CName validation is enabled. Default value is false. This should only be
	// set on updates.
	UseSubDomainName *bool `json:"useSubDomainName,omitempty"`
}

// Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of accounts in a single
// subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an alphanumeric DNS Zone
// identifier.
type DnsEndpointType_STATUS string

const (
	DnsEndpointType_STATUS_AzureDnsZone = DnsEndpointType_STATUS("AzureDnsZone")
	DnsEndpointType_STATUS_Standard     = DnsEndpointType_STATUS("Standard")
)

// Mapping from string to DnsEndpointType_STATUS
var dnsEndpointType_STATUS_Values = map[string]DnsEndpointType_STATUS{
	"azurednszone": DnsEndpointType_STATUS_AzureDnsZone,
	"standard":     DnsEndpointType_STATUS_Standard,
}

// Dual-stack endpoint preference defines whether IPv6 endpoints are going to be published.
type DualStackEndpointPreference_STATUS struct {
	// PublishIpv6Endpoint: A boolean flag which indicates whether IPv6 storage endpoints are to be published.
	PublishIpv6Endpoint *bool `json:"publishIpv6Endpoint,omitempty"`
}

// The encryption settings on the storage account.
type Encryption_STATUS struct {
	// Identity: The identity to be used with service-side encryption at rest.
	Identity *EncryptionIdentity_STATUS `json:"identity,omitempty"`

	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage,
	// Microsoft.Keyvault
	KeySource *Encryption_KeySource_STATUS `json:"keySource,omitempty"`

	// Keyvaultproperties: Properties provided by key vault.
	Keyvaultproperties *KeyVaultProperties_STATUS `json:"keyvaultproperties,omitempty"`

	// RequireInfrastructureEncryption: A boolean indicating whether or not the service applies a secondary layer of encryption
	// with platform managed keys for data at rest.
	RequireInfrastructureEncryption *bool `json:"requireInfrastructureEncryption,omitempty"`

	// Services: List of services which support encryption.
	Services *EncryptionServices_STATUS `json:"services,omitempty"`
}

// The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
type Endpoints_STATUS struct {
	// Blob: Gets the blob endpoint.
	Blob *string `json:"blob,omitempty"`

	// Dfs: Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty"`

	// File: Gets the file endpoint.
	File *string `json:"file,omitempty"`

	// InternetEndpoints: Gets the internet routing storage endpoints
	InternetEndpoints *StorageAccountInternetEndpoints_STATUS `json:"internetEndpoints,omitempty"`

	// Ipv6Endpoints: Gets the IPv6 storage endpoints.
	Ipv6Endpoints *StorageAccountIpv6Endpoints_STATUS `json:"ipv6Endpoints,omitempty"`

	// MicrosoftEndpoints: Gets the microsoft routing storage endpoints.
	MicrosoftEndpoints *StorageAccountMicrosoftEndpoints_STATUS `json:"microsoftEndpoints,omitempty"`

	// Queue: Gets the queue endpoint.
	Queue *string `json:"queue,omitempty"`

	// Table: Gets the table endpoint.
	Table *string `json:"table,omitempty"`

	// Web: Gets the web endpoint.
	Web *string `json:"web,omitempty"`
}

// The type of extendedLocation.
type ExtendedLocationTypes_STATUS string

const ExtendedLocationTypes_STATUS_EdgeZone = ExtendedLocationTypes_STATUS("EdgeZone")

// Mapping from string to ExtendedLocationTypes_STATUS
var extendedLocationTypes_STATUS_Values = map[string]ExtendedLocationTypes_STATUS{
	"edgezone": ExtendedLocationTypes_STATUS_EdgeZone,
}

// Geo Priority Replication enablement status for the storage account.
type GeoPriorityReplicationStatus_STATUS struct {
	// IsBlobEnabled: Indicates whether Blob Geo Priority Replication is enabled for the storage account.
	IsBlobEnabled *bool `json:"isBlobEnabled,omitempty"`
}

// Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when
// geo-redundant replication is enabled for the storage account.
type GeoReplicationStats_STATUS struct {
	// CanFailover: A boolean flag which indicates whether or not account failover is supported for the account.
	CanFailover *bool `json:"canFailover,omitempty"`

	// CanPlannedFailover: A boolean flag which indicates whether or not planned account failover is supported for the account.
	CanPlannedFailover *bool `json:"canPlannedFailover,omitempty"`

	// LastSyncTime: All primary writes preceding this UTC date/time value are guaranteed to be available for read operations.
	// Primary writes following this point in time may or may not be available for reads. Element may be default value if value
	// of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
	LastSyncTime *string `json:"lastSyncTime,omitempty"`

	// PostFailoverRedundancy: The redundancy type of the account after an account failover is performed.
	PostFailoverRedundancy *PostFailoverRedundancy_STATUS `json:"postFailoverRedundancy,omitempty"`

	// PostPlannedFailoverRedundancy: The redundancy type of the account after a planned account failover is performed.
	PostPlannedFailoverRedundancy *PostPlannedFailoverRedundancy_STATUS `json:"postPlannedFailoverRedundancy,omitempty"`

	// Status: The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is
	// active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary
	// location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the
	// secondary location is temporarily unavailable.
	Status *GeoReplicationStatus_STATUS `json:"status,omitempty"`
}

// The identity type.
type IdentityType_STATUS string

const (
	IdentityType_STATUS_None                       = IdentityType_STATUS("None")
	IdentityType_STATUS_SystemAssigned             = IdentityType_STATUS("SystemAssigned")
	IdentityType_STATUS_SystemAssignedUserAssigned = IdentityType_STATUS("SystemAssigned,UserAssigned")
	IdentityType_STATUS_UserAssigned               = IdentityType_STATUS("UserAssigned")
)

// Mapping from string to IdentityType_STATUS
var identityType_STATUS_Values = map[string]IdentityType_STATUS{
	"none":                        IdentityType_STATUS_None,
	"systemassigned":              IdentityType_STATUS_SystemAssigned,
	"systemassigned,userassigned": IdentityType_STATUS_SystemAssignedUserAssigned,
	"userassigned":                IdentityType_STATUS_UserAssigned,
}

// This property enables and defines account-level immutability. Enabling the feature auto-enables Blob Versioning.
type ImmutableStorageAccount_STATUS struct {
	// Enabled: A boolean flag which enables account-level immutability. All the containers under such an account have
	// object-level immutability enabled by default.
	Enabled *bool `json:"enabled,omitempty"`

	// ImmutabilityPolicy: Specifies the default account-level immutability policy which is inherited and applied to objects
	// that do not possess an explicit immutability policy at the object level. The object-level immutability policy has higher
	// precedence than the container-level immutability policy, which has a higher precedence than the account-level
	// immutability policy.
	ImmutabilityPolicy *AccountImmutabilityPolicyProperties_STATUS `json:"immutabilityPolicy,omitempty"`
}

// Storage account keys creation time.
type KeyCreationTime_STATUS struct {
	Key1 *string `json:"key1,omitempty"`
	Key2 *string `json:"key2,omitempty"`
}

// KeyPolicy assigned to the storage account.
type KeyPolicy_STATUS struct {
	// KeyExpirationPeriodInDays: The key expiration period in days.
	KeyExpirationPeriodInDays *int `json:"keyExpirationPeriodInDays,omitempty"`
}

// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
type LargeFileSharesState_STATUS string

const (
	LargeFileSharesState_STATUS_Disabled = LargeFileSharesState_STATUS("Disabled")
	LargeFileSharesState_STATUS_Enabled  = LargeFileSharesState_STATUS("Enabled")
)

// Mapping from string to LargeFileSharesState_STATUS
var largeFileSharesState_STATUS_Values = map[string]LargeFileSharesState_STATUS{
	"disabled": LargeFileSharesState_STATUS_Disabled,
	"enabled":  LargeFileSharesState_STATUS_Enabled,
}

// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this
// property.
type MinimumTlsVersion_STATUS string

const (
	MinimumTlsVersion_STATUS_TLS1_0 = MinimumTlsVersion_STATUS("TLS1_0")
	MinimumTlsVersion_STATUS_TLS1_1 = MinimumTlsVersion_STATUS("TLS1_1")
	MinimumTlsVersion_STATUS_TLS1_2 = MinimumTlsVersion_STATUS("TLS1_2")
	MinimumTlsVersion_STATUS_TLS1_3 = MinimumTlsVersion_STATUS("TLS1_3")
)

// Mapping from string to MinimumTlsVersion_STATUS
var minimumTlsVersion_STATUS_Values = map[string]MinimumTlsVersion_STATUS{
	"tls1_0": MinimumTlsVersion_STATUS_TLS1_0,
	"tls1_1": MinimumTlsVersion_STATUS_TLS1_1,
	"tls1_2": MinimumTlsVersion_STATUS_TLS1_2,
	"tls1_3": MinimumTlsVersion_STATUS_TLS1_3,
}

// Network rule set
type NetworkRuleSet_STATUS struct {
	// Bypass: Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of
	// Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
	Bypass *NetworkRuleSet_Bypass_STATUS `json:"bypass,omitempty"`

	// DefaultAction: Specifies the default action of allow or deny when no other rules match.
	DefaultAction *NetworkRuleSet_DefaultAction_STATUS `json:"defaultAction,omitempty"`

	// IpRules: Sets the IP ACL rules
	IpRules []IPRule_STATUS `json:"ipRules"`

	// Ipv6Rules: Sets the IPv6 ACL rules.
	Ipv6Rules []IPRule_STATUS `json:"ipv6Rules"`

	// ResourceAccessRules: Sets the resource access rules
	ResourceAccessRules []ResourceAccessRule_STATUS `json:"resourceAccessRules"`

	// VirtualNetworkRules: Sets the virtual network rules
	VirtualNetworkRules []VirtualNetworkRule_STATUS `json:"virtualNetworkRules"`
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`
}

// Gets the status of the storage account at the time the operation was called.
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Creating     = ProvisioningState_STATUS("Creating")
	ProvisioningState_STATUS_ResolvingDNS = ProvisioningState_STATUS("ResolvingDNS")
	ProvisioningState_STATUS_Succeeded    = ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"creating":     ProvisioningState_STATUS_Creating,
	"resolvingdns": ProvisioningState_STATUS_ResolvingDNS,
	"succeeded":    ProvisioningState_STATUS_Succeeded,
}

// Allow, disallow, or let Network Security Perimeter configuration to evaluate public network access to Storage Account.
// Value is optional but if passed in, must be 'Enabled', 'Disabled' or 'SecuredByPerimeter'.
type PublicNetworkAccess_STATUS string

const (
	PublicNetworkAccess_STATUS_Disabled           = PublicNetworkAccess_STATUS("Disabled")
	PublicNetworkAccess_STATUS_Enabled            = PublicNetworkAccess_STATUS("Enabled")
	PublicNetworkAccess_STATUS_SecuredByPerimeter = PublicNetworkAccess_STATUS("SecuredByPerimeter")
)

// Mapping from string to PublicNetworkAccess_STATUS
var publicNetworkAccess_STATUS_Values = map[string]PublicNetworkAccess_STATUS{
	"disabled":           PublicNetworkAccess_STATUS_Disabled,
	"enabled":            PublicNetworkAccess_STATUS_Enabled,
	"securedbyperimeter": PublicNetworkAccess_STATUS_SecuredByPerimeter,
}

// Routing preference defines the type of network, either microsoft or internet routing to be used to deliver the user
// data, the default option is microsoft routing
type RoutingPreference_STATUS struct {
	// PublishInternetEndpoints: A boolean flag which indicates whether internet routing storage endpoints are to be published
	PublishInternetEndpoints *bool `json:"publishInternetEndpoints,omitempty"`

	// PublishMicrosoftEndpoints: A boolean flag which indicates whether microsoft routing storage endpoints are to be published
	PublishMicrosoftEndpoints *bool `json:"publishMicrosoftEndpoints,omitempty"`

	// RoutingChoice: Routing Choice defines the kind of network routing opted by the user.
	RoutingChoice *RoutingChoice_STATUS `json:"routingChoice,omitempty"`
}

// SasPolicy assigned to the storage account.
type SasPolicy_STATUS struct {
	// ExpirationAction: The SAS Expiration Action defines the action to be performed when sasPolicy.sasExpirationPeriod is
	// violated. The 'Log' action can be used for audit purposes and the 'Block' action can be used to block and deny the usage
	// of SAS tokens that do not adhere to the sas policy expiration period.
	ExpirationAction *SasPolicy_ExpirationAction_STATUS `json:"expirationAction,omitempty"`

	// SasExpirationPeriod: The SAS expiration period, DD.HH:MM:SS.
	SasExpirationPeriod *string `json:"sasExpirationPeriod,omitempty"`
}

// The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called
// accountType.
type SkuName_STATUS string

const (
	SkuName_STATUS_PremiumV2_LRS   = SkuName_STATUS("PremiumV2_LRS")
	SkuName_STATUS_PremiumV2_ZRS   = SkuName_STATUS("PremiumV2_ZRS")
	SkuName_STATUS_Premium_LRS     = SkuName_STATUS("Premium_LRS")
	SkuName_STATUS_Premium_ZRS     = SkuName_STATUS("Premium_ZRS")
	SkuName_STATUS_StandardV2_GRS  = SkuName_STATUS("StandardV2_GRS")
	SkuName_STATUS_StandardV2_GZRS = SkuName_STATUS("StandardV2_GZRS")
	SkuName_STATUS_StandardV2_LRS  = SkuName_STATUS("StandardV2_LRS")
	SkuName_STATUS_StandardV2_ZRS  = SkuName_STATUS("StandardV2_ZRS")
	SkuName_STATUS_Standard_GRS    = SkuName_STATUS("Standard_GRS")
	SkuName_STATUS_Standard_GZRS   = SkuName_STATUS("Standard_GZRS")
	SkuName_STATUS_Standard_LRS    = SkuName_STATUS("Standard_LRS")
	SkuName_STATUS_Standard_RAGRS  = SkuName_STATUS("Standard_RAGRS")
	SkuName_STATUS_Standard_RAGZRS = SkuName_STATUS("Standard_RAGZRS")
	SkuName_STATUS_Standard_ZRS    = SkuName_STATUS("Standard_ZRS")
)

// Mapping from string to SkuName_STATUS
var skuName_STATUS_Values = map[string]SkuName_STATUS{
	"premiumv2_lrs":   SkuName_STATUS_PremiumV2_LRS,
	"premiumv2_zrs":   SkuName_STATUS_PremiumV2_ZRS,
	"premium_lrs":     SkuName_STATUS_Premium_LRS,
	"premium_zrs":     SkuName_STATUS_Premium_ZRS,
	"standardv2_grs":  SkuName_STATUS_StandardV2_GRS,
	"standardv2_gzrs": SkuName_STATUS_StandardV2_GZRS,
	"standardv2_lrs":  SkuName_STATUS_StandardV2_LRS,
	"standardv2_zrs":  SkuName_STATUS_StandardV2_ZRS,
	"standard_grs":    SkuName_STATUS_Standard_GRS,
	"standard_gzrs":   SkuName_STATUS_Standard_GZRS,
	"standard_lrs":    SkuName_STATUS_Standard_LRS,
	"standard_ragrs":  SkuName_STATUS_Standard_RAGRS,
	"standard_ragzrs": SkuName_STATUS_Standard_RAGZRS,
	"standard_zrs":    SkuName_STATUS_Standard_ZRS,
}

// The SKU tier. This is based on the SKU name.
type SkuTier_STATUS string

const (
	SkuTier_STATUS_Premium  = SkuTier_STATUS("Premium")
	SkuTier_STATUS_Standard = SkuTier_STATUS("Standard")
)

// Mapping from string to SkuTier_STATUS
var skuTier_STATUS_Values = map[string]SkuTier_STATUS{
	"premium":  SkuTier_STATUS_Premium,
	"standard": SkuTier_STATUS_Standard,
}

// This defines the sku conversion status object for asynchronous sku conversions.
type StorageAccountSkuConversionStatus_STATUS struct {
	// EndTime: This property represents the sku conversion end time.
	EndTime *string `json:"endTime,omitempty"`

	// SkuConversionStatus: This property indicates the current sku conversion status.
	SkuConversionStatus *SkuConversionStatus_STATUS `json:"skuConversionStatus,omitempty"`

	// StartTime: This property represents the sku conversion start time.
	StartTime *string `json:"startTime,omitempty"`

	// TargetSkuName: This property represents the target sku name to which the account sku is being converted asynchronously.
	TargetSkuName *SkuName_STATUS `json:"targetSkuName,omitempty"`
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// UserAssignedIdentity for the resource.
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal ID of the identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

// The availability zone pinning policy for the storage account.
type ZonePlacementPolicy_STATUS string

const (
	ZonePlacementPolicy_STATUS_Any  = ZonePlacementPolicy_STATUS("Any")
	ZonePlacementPolicy_STATUS_None = ZonePlacementPolicy_STATUS("None")
)

// Mapping from string to ZonePlacementPolicy_STATUS
var zonePlacementPolicy_STATUS_Values = map[string]ZonePlacementPolicy_STATUS{
	"any":  ZonePlacementPolicy_STATUS_Any,
	"none": ZonePlacementPolicy_STATUS_None,
}

// This defines account-level immutability policy properties.
type AccountImmutabilityPolicyProperties_STATUS struct {
	// AllowProtectedAppendWrites: This property can only be changed for disabled and unlocked time-based retention policies.
	// When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only
	// new blocks can be added and any existing blocks cannot be modified or deleted.
	AllowProtectedAppendWrites *bool `json:"allowProtectedAppendWrites,omitempty"`

	// ImmutabilityPeriodSinceCreationInDays: The immutability period for the blobs in the container since the policy creation,
	// in days.
	ImmutabilityPeriodSinceCreationInDays *int `json:"immutabilityPeriodSinceCreationInDays,omitempty"`

	// State: The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state
	// allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites
	// property, Locked state only allows the increase of the immutability retention time. A policy can only be created in a
	// Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition
	// to a Locked state which cannot be reverted.
	State *AccountImmutabilityPolicyState_STATUS `json:"state,omitempty"`
}

// Settings properties for Active Directory (AD).
type ActiveDirectoryProperties_STATUS struct {
	// AccountType: Specifies the Active Directory account type for Azure Storage. If directoryServiceOptions is set to AD (AD
	// DS authentication), this property is optional. If provided, samAccountName should also be provided. For
	// directoryServiceOptions AADDS (Entra DS authentication) or AADKERB (Entra authentication), this property can be omitted.
	AccountType *AccountType_STATUS `json:"accountType,omitempty"`

	// AzureStorageSid: Specifies the security identifier (SID) for Azure Storage. If directoryServiceOptions is set to AD (AD
	// DS authentication), this property is required. Otherwise, it can be omitted.
	AzureStorageSid *string `json:"azureStorageSid,omitempty"`

	// DomainGuid: Specifies the domain GUID. If directoryServiceOptions is set to AD (AD DS authentication), this property is
	// required. If directoryServiceOptions is set to AADDS (Entra DS authentication), this property can be omitted. If
	// directoryServiceOptions is set to AADKERB (Entra authentication), this property is optional; it is needed to support
	// configuration of directory- and file-level permissions via Windows File Explorer, but is not required for authentication.
	DomainGuid *string `json:"domainGuid,omitempty"`

	// DomainName: Specifies the primary domain that the AD DNS server is authoritative for. This property is required if
	// directoryServiceOptions is set to AD (AD DS authentication). If directoryServiceOptions is set to AADDS (Entra DS
	// authentication), providing this property is optional, as it will be inferred automatically if omitted. If
	// directoryServiceOptions is set to AADKERB (Entra authentication), this property is optional; it is needed to support
	// configuration of directory- and file-level permissions via Windows File Explorer, but is not required for authentication.
	DomainName *string `json:"domainName,omitempty"`

	// DomainSid: Specifies the security identifier (SID) of the AD domain. If directoryServiceOptions is set to AD (AD DS
	// authentication), this property is required. Otherwise, it can be omitted.
	DomainSid *string `json:"domainSid,omitempty"`

	// ForestName: Specifies the Active Directory forest to get. If directoryServiceOptions is set to AD (AD DS
	// authentication), this property is required. Otherwise, it can be omitted.
	ForestName *string `json:"forestName,omitempty"`

	// NetBiosDomainName: Specifies the NetBIOS domain name. If directoryServiceOptions is set to AD (AD DS authentication),
	// this property is required. Otherwise, it can be omitted.
	NetBiosDomainName *string `json:"netBiosDomainName,omitempty"`

	// SamAccountName: Specifies the Active Directory SAMAccountName for Azure Storage. If directoryServiceOptions is set to AD
	// (AD DS authentication), this property is optional. If provided, accountType should also be provided. For
	// directoryServiceOptions AADDS (Entra DS authentication) or AADKERB (Entra authentication), this property can be omitted.
	SamAccountName *string `json:"samAccountName,omitempty"`
}

// Blob restore parameters
type BlobRestoreParameters_STATUS struct {
	// BlobRanges: Blob ranges to restore.
	BlobRanges []BlobRestoreRange_STATUS `json:"blobRanges"`

	// TimeToRestore: Restore blob to the specified time.
	TimeToRestore *string `json:"timeToRestore,omitempty"`
}

// The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. -
// Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed.
type BlobRestoreProgressStatus_STATUS string

const (
	BlobRestoreProgressStatus_STATUS_Complete   = BlobRestoreProgressStatus_STATUS("Complete")
	BlobRestoreProgressStatus_STATUS_Failed     = BlobRestoreProgressStatus_STATUS("Failed")
	BlobRestoreProgressStatus_STATUS_InProgress = BlobRestoreProgressStatus_STATUS("InProgress")
)

// Mapping from string to BlobRestoreProgressStatus_STATUS
var blobRestoreProgressStatus_STATUS_Values = map[string]BlobRestoreProgressStatus_STATUS{
	"complete":   BlobRestoreProgressStatus_STATUS_Complete,
	"failed":     BlobRestoreProgressStatus_STATUS_Failed,
	"inprogress": BlobRestoreProgressStatus_STATUS_InProgress,
}

// Default share permission for users using Kerberos authentication if RBAC role is not assigned.
type DefaultSharePermission_STATUS string

const (
	DefaultSharePermission_STATUS_None                                       = DefaultSharePermission_STATUS("None")
	DefaultSharePermission_STATUS_StorageFileDataSmbShareContributor         = DefaultSharePermission_STATUS("StorageFileDataSmbShareContributor")
	DefaultSharePermission_STATUS_StorageFileDataSmbShareElevatedContributor = DefaultSharePermission_STATUS("StorageFileDataSmbShareElevatedContributor")
	DefaultSharePermission_STATUS_StorageFileDataSmbShareReader              = DefaultSharePermission_STATUS("StorageFileDataSmbShareReader")
)

// Mapping from string to DefaultSharePermission_STATUS
var defaultSharePermission_STATUS_Values = map[string]DefaultSharePermission_STATUS{
	"none":                               DefaultSharePermission_STATUS_None,
	"storagefiledatasmbsharecontributor": DefaultSharePermission_STATUS_StorageFileDataSmbShareContributor,
	"storagefiledatasmbshareelevatedcontributor": DefaultSharePermission_STATUS_StorageFileDataSmbShareElevatedContributor,
	"storagefiledatasmbsharereader":              DefaultSharePermission_STATUS_StorageFileDataSmbShareReader,
}

// Indicates the directory service used. Note that this enum may be extended in the future.
type DirectoryServiceOptions_STATUS string

const (
	DirectoryServiceOptions_STATUS_AADDS   = DirectoryServiceOptions_STATUS("AADDS")
	DirectoryServiceOptions_STATUS_AADKERB = DirectoryServiceOptions_STATUS("AADKERB")
	DirectoryServiceOptions_STATUS_AD      = DirectoryServiceOptions_STATUS("AD")
	DirectoryServiceOptions_STATUS_None    = DirectoryServiceOptions_STATUS("None")
)

// Mapping from string to DirectoryServiceOptions_STATUS
var directoryServiceOptions_STATUS_Values = map[string]DirectoryServiceOptions_STATUS{
	"aadds":   DirectoryServiceOptions_STATUS_AADDS,
	"aadkerb": DirectoryServiceOptions_STATUS_AADKERB,
	"ad":      DirectoryServiceOptions_STATUS_AD,
	"none":    DirectoryServiceOptions_STATUS_None,
}

type Encryption_KeySource_STATUS string

const (
	Encryption_KeySource_STATUS_MicrosoftKeyvault = Encryption_KeySource_STATUS("Microsoft.Keyvault")
	Encryption_KeySource_STATUS_MicrosoftStorage  = Encryption_KeySource_STATUS("Microsoft.Storage")
)

// Mapping from string to Encryption_KeySource_STATUS
var encryption_KeySource_STATUS_Values = map[string]Encryption_KeySource_STATUS{
	"microsoft.keyvault": Encryption_KeySource_STATUS_MicrosoftKeyvault,
	"microsoft.storage":  Encryption_KeySource_STATUS_MicrosoftStorage,
}

// Encryption identity for the storage account.
type EncryptionIdentity_STATUS struct {
	// FederatedIdentityClientId: ClientId of the multi-tenant application to be used in conjunction with the user-assigned
	// identity for cross-tenant customer-managed-keys server-side encryption on the storage account.
	FederatedIdentityClientId *string `json:"federatedIdentityClientId,omitempty"`

	// UserAssignedIdentity: Resource identifier of the UserAssigned identity to be associated with server-side encryption on
	// the storage account.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// A list of services that support encryption.
type EncryptionServices_STATUS struct {
	// Blob: The encryption function of the blob storage service.
	Blob *EncryptionService_STATUS `json:"blob,omitempty"`

	// File: The encryption function of the file storage service.
	File *EncryptionService_STATUS `json:"file,omitempty"`

	// Queue: The encryption function of the queue storage service.
	Queue *EncryptionService_STATUS `json:"queue,omitempty"`

	// Table: The encryption function of the table storage service.
	Table *EncryptionService_STATUS `json:"table,omitempty"`
}

// The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and
// operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in
// progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location
// is temporarily unavailable.
type GeoReplicationStatus_STATUS string

const (
	GeoReplicationStatus_STATUS_Bootstrap   = GeoReplicationStatus_STATUS("Bootstrap")
	GeoReplicationStatus_STATUS_Live        = GeoReplicationStatus_STATUS("Live")
	GeoReplicationStatus_STATUS_Unavailable = GeoReplicationStatus_STATUS("Unavailable")
)

// Mapping from string to GeoReplicationStatus_STATUS
var geoReplicationStatus_STATUS_Values = map[string]GeoReplicationStatus_STATUS{
	"bootstrap":   GeoReplicationStatus_STATUS_Bootstrap,
	"live":        GeoReplicationStatus_STATUS_Live,
	"unavailable": GeoReplicationStatus_STATUS_Unavailable,
}

// IP rule with specific IP or IP range in CIDR format.
type IPRule_STATUS struct {
	// Action: The action of IP ACL rule.
	Action *IPRule_Action_STATUS `json:"action,omitempty"`

	// Value: Specifies the IP or IP range in CIDR format.
	Value *string `json:"value,omitempty"`
}

// Properties of key vault.
type KeyVaultProperties_STATUS struct {
	// CurrentVersionedKeyExpirationTimestamp: This is a read only property that represents the expiration time of the current
	// version of the customer managed key used for encryption.
	CurrentVersionedKeyExpirationTimestamp *string `json:"currentVersionedKeyExpirationTimestamp,omitempty"`

	// CurrentVersionedKeyIdentifier: The object identifier of the current versioned Key Vault Key in use.
	CurrentVersionedKeyIdentifier *string `json:"currentVersionedKeyIdentifier,omitempty"`

	// Keyname: The name of KeyVault key.
	Keyname *string `json:"keyname,omitempty"`

	// Keyvaulturi: The Uri of KeyVault.
	Keyvaulturi *string `json:"keyvaulturi,omitempty"`

	// Keyversion: The version of KeyVault key.
	Keyversion *string `json:"keyversion,omitempty"`

	// LastKeyRotationTimestamp: Timestamp of last rotation of the Key Vault Key.
	LastKeyRotationTimestamp *string `json:"lastKeyRotationTimestamp,omitempty"`
}

type NetworkRuleSet_Bypass_STATUS string

const (
	NetworkRuleSet_Bypass_STATUS_AzureServices = NetworkRuleSet_Bypass_STATUS("AzureServices")
	NetworkRuleSet_Bypass_STATUS_Logging       = NetworkRuleSet_Bypass_STATUS("Logging")
	NetworkRuleSet_Bypass_STATUS_Metrics       = NetworkRuleSet_Bypass_STATUS("Metrics")
	NetworkRuleSet_Bypass_STATUS_None          = NetworkRuleSet_Bypass_STATUS("None")
)

// Mapping from string to NetworkRuleSet_Bypass_STATUS
var networkRuleSet_Bypass_STATUS_Values = map[string]NetworkRuleSet_Bypass_STATUS{
	"azureservices": NetworkRuleSet_Bypass_STATUS_AzureServices,
	"logging":       NetworkRuleSet_Bypass_STATUS_Logging,
	"metrics":       NetworkRuleSet_Bypass_STATUS_Metrics,
	"none":          NetworkRuleSet_Bypass_STATUS_None,
}

type NetworkRuleSet_DefaultAction_STATUS string

const (
	NetworkRuleSet_DefaultAction_STATUS_Allow = NetworkRuleSet_DefaultAction_STATUS("Allow")
	NetworkRuleSet_DefaultAction_STATUS_Deny  = NetworkRuleSet_DefaultAction_STATUS("Deny")
)

// Mapping from string to NetworkRuleSet_DefaultAction_STATUS
var networkRuleSet_DefaultAction_STATUS_Values = map[string]NetworkRuleSet_DefaultAction_STATUS{
	"allow": NetworkRuleSet_DefaultAction_STATUS_Allow,
	"deny":  NetworkRuleSet_DefaultAction_STATUS_Deny,
}

// The redundancy type of the account after an account failover is performed.
type PostFailoverRedundancy_STATUS string

const (
	PostFailoverRedundancy_STATUS_Standard_LRS = PostFailoverRedundancy_STATUS("Standard_LRS")
	PostFailoverRedundancy_STATUS_Standard_ZRS = PostFailoverRedundancy_STATUS("Standard_ZRS")
)

// Mapping from string to PostFailoverRedundancy_STATUS
var postFailoverRedundancy_STATUS_Values = map[string]PostFailoverRedundancy_STATUS{
	"standard_lrs": PostFailoverRedundancy_STATUS_Standard_LRS,
	"standard_zrs": PostFailoverRedundancy_STATUS_Standard_ZRS,
}

// The redundancy type of the account after a planned account failover is performed.
type PostPlannedFailoverRedundancy_STATUS string

const (
	PostPlannedFailoverRedundancy_STATUS_Standard_GRS    = PostPlannedFailoverRedundancy_STATUS("Standard_GRS")
	PostPlannedFailoverRedundancy_STATUS_Standard_GZRS   = PostPlannedFailoverRedundancy_STATUS("Standard_GZRS")
	PostPlannedFailoverRedundancy_STATUS_Standard_RAGRS  = PostPlannedFailoverRedundancy_STATUS("Standard_RAGRS")
	PostPlannedFailoverRedundancy_STATUS_Standard_RAGZRS = PostPlannedFailoverRedundancy_STATUS("Standard_RAGZRS")
)

// Mapping from string to PostPlannedFailoverRedundancy_STATUS
var postPlannedFailoverRedundancy_STATUS_Values = map[string]PostPlannedFailoverRedundancy_STATUS{
	"standard_grs":    PostPlannedFailoverRedundancy_STATUS_Standard_GRS,
	"standard_gzrs":   PostPlannedFailoverRedundancy_STATUS_Standard_GZRS,
	"standard_ragrs":  PostPlannedFailoverRedundancy_STATUS_Standard_RAGRS,
	"standard_ragzrs": PostPlannedFailoverRedundancy_STATUS_Standard_RAGZRS,
}

// Resource Access Rule.
type ResourceAccessRule_STATUS struct {
	// ResourceId: Resource Id
	ResourceId *string `json:"resourceId,omitempty"`

	// TenantId: Tenant Id
	TenantId *string `json:"tenantId,omitempty"`
}

// Routing Choice defines the kind of network routing opted by the user.
type RoutingChoice_STATUS string

const (
	RoutingChoice_STATUS_InternetRouting  = RoutingChoice_STATUS("InternetRouting")
	RoutingChoice_STATUS_MicrosoftRouting = RoutingChoice_STATUS("MicrosoftRouting")
)

// Mapping from string to RoutingChoice_STATUS
var routingChoice_STATUS_Values = map[string]RoutingChoice_STATUS{
	"internetrouting":  RoutingChoice_STATUS_InternetRouting,
	"microsoftrouting": RoutingChoice_STATUS_MicrosoftRouting,
}

type SasPolicy_ExpirationAction_STATUS string

const (
	SasPolicy_ExpirationAction_STATUS_Block = SasPolicy_ExpirationAction_STATUS("Block")
	SasPolicy_ExpirationAction_STATUS_Log   = SasPolicy_ExpirationAction_STATUS("Log")
)

// Mapping from string to SasPolicy_ExpirationAction_STATUS
var sasPolicy_ExpirationAction_STATUS_Values = map[string]SasPolicy_ExpirationAction_STATUS{
	"block": SasPolicy_ExpirationAction_STATUS_Block,
	"log":   SasPolicy_ExpirationAction_STATUS_Log,
}

// This property indicates the current sku conversion status.
type SkuConversionStatus_STATUS string

const (
	SkuConversionStatus_STATUS_Failed     = SkuConversionStatus_STATUS("Failed")
	SkuConversionStatus_STATUS_InProgress = SkuConversionStatus_STATUS("InProgress")
	SkuConversionStatus_STATUS_Succeeded  = SkuConversionStatus_STATUS("Succeeded")
)

// Mapping from string to SkuConversionStatus_STATUS
var skuConversionStatus_STATUS_Values = map[string]SkuConversionStatus_STATUS{
	"failed":     SkuConversionStatus_STATUS_Failed,
	"inprogress": SkuConversionStatus_STATUS_InProgress,
	"succeeded":  SkuConversionStatus_STATUS_Succeeded,
}

// Setting property for Managed Identity access over SMB using OAuth
type SmbOAuthSettings_STATUS struct {
	// IsSmbOAuthEnabled: Specifies if managed identities can access SMB shares using OAuth. The default interpretation is
	// false for this property.
	IsSmbOAuthEnabled *bool `json:"isSmbOAuthEnabled,omitempty"`
}

// The URIs that are used to perform a retrieval of a public blob, file, web or dfs object via a internet routing endpoint.
type StorageAccountInternetEndpoints_STATUS struct {
	// Blob: Gets the blob endpoint.
	Blob *string `json:"blob,omitempty"`

	// Dfs: Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty"`

	// File: Gets the file endpoint.
	File *string `json:"file,omitempty"`

	// Web: Gets the web endpoint.
	Web *string `json:"web,omitempty"`
}

// The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via an IPv6 endpoint.
type StorageAccountIpv6Endpoints_STATUS struct {
	// Blob: Gets the blob endpoint.
	Blob *string `json:"blob,omitempty"`

	// Dfs: Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty"`

	// File: Gets the file endpoint.
	File *string `json:"file,omitempty"`

	// InternetEndpoints: Gets the internet routing storage endpoints
	InternetEndpoints *StorageAccountInternetEndpoints_STATUS `json:"internetEndpoints,omitempty"`

	// MicrosoftEndpoints: Gets the microsoft routing storage endpoints.
	MicrosoftEndpoints *StorageAccountMicrosoftEndpoints_STATUS `json:"microsoftEndpoints,omitempty"`

	// Queue: Gets the queue endpoint.
	Queue *string `json:"queue,omitempty"`

	// Table: Gets the table endpoint.
	Table *string `json:"table,omitempty"`

	// Web: Gets the web endpoint.
	Web *string `json:"web,omitempty"`
}

// The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via a microsoft routing
// endpoint.
type StorageAccountMicrosoftEndpoints_STATUS struct {
	// Blob: Gets the blob endpoint.
	Blob *string `json:"blob,omitempty"`

	// Dfs: Gets the dfs endpoint.
	Dfs *string `json:"dfs,omitempty"`

	// File: Gets the file endpoint.
	File *string `json:"file,omitempty"`

	// Queue: Gets the queue endpoint.
	Queue *string `json:"queue,omitempty"`

	// Table: Gets the table endpoint.
	Table *string `json:"table,omitempty"`

	// Web: Gets the web endpoint.
	Web *string `json:"web,omitempty"`
}

// Virtual Network rule.
type VirtualNetworkRule_STATUS struct {
	// Action: The action of virtual network rule.
	Action *VirtualNetworkRule_Action_STATUS `json:"action,omitempty"`

	// Id: Resource ID of a subnet, for example:
	// /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
	Id *string `json:"id,omitempty"`

	// State: Gets the state of virtual network rule.
	State *State_STATUS `json:"state,omitempty"`
}

// The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows
// increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property,
// Locked state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or
// Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked
// state which cannot be reverted.
type AccountImmutabilityPolicyState_STATUS string

const (
	AccountImmutabilityPolicyState_STATUS_Disabled = AccountImmutabilityPolicyState_STATUS("Disabled")
	AccountImmutabilityPolicyState_STATUS_Locked   = AccountImmutabilityPolicyState_STATUS("Locked")
	AccountImmutabilityPolicyState_STATUS_Unlocked = AccountImmutabilityPolicyState_STATUS("Unlocked")
)

// Mapping from string to AccountImmutabilityPolicyState_STATUS
var accountImmutabilityPolicyState_STATUS_Values = map[string]AccountImmutabilityPolicyState_STATUS{
	"disabled": AccountImmutabilityPolicyState_STATUS_Disabled,
	"locked":   AccountImmutabilityPolicyState_STATUS_Locked,
	"unlocked": AccountImmutabilityPolicyState_STATUS_Unlocked,
}

// Specifies the Active Directory account type for Azure Storage. If directoryServiceOptions is set to AD (AD DS
// authentication), this property is optional. If provided, samAccountName should also be provided. For
// directoryServiceOptions AADDS (Entra DS authentication) or AADKERB (Entra authentication), this property can be omitted.
type AccountType_STATUS string

const (
	AccountType_STATUS_Computer = AccountType_STATUS("Computer")
	AccountType_STATUS_User     = AccountType_STATUS("User")
)

// Mapping from string to AccountType_STATUS
var accountType_STATUS_Values = map[string]AccountType_STATUS{
	"computer": AccountType_STATUS_Computer,
	"user":     AccountType_STATUS_User,
}

// Blob range
type BlobRestoreRange_STATUS struct {
	// EndRange: Blob end range. This is exclusive. Empty means account end.
	EndRange *string `json:"endRange,omitempty"`

	// StartRange: Blob start range. This is inclusive. Empty means account start.
	StartRange *string `json:"startRange,omitempty"`
}

// A service that allows server-side encryption to be used.
type EncryptionService_STATUS struct {
	// Enabled: A boolean indicating whether or not the service encrypts the data as it is stored. Encryption at rest is
	// enabled by default today and cannot be disabled.
	Enabled *bool `json:"enabled,omitempty"`

	// KeyType: Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped
	// encryption key will be used. 'Service' key type implies that a default service key is used.
	KeyType *KeyType_STATUS `json:"keyType,omitempty"`

	// LastEnabledTime: Gets a rough estimate of the date/time when the encryption was last enabled by the user. Data is
	// encrypted at rest by default today and cannot be disabled.
	LastEnabledTime *string `json:"lastEnabledTime,omitempty"`
}

type IPRule_Action_STATUS string

const IPRule_Action_STATUS_Allow = IPRule_Action_STATUS("Allow")

// Mapping from string to IPRule_Action_STATUS
var iPRule_Action_STATUS_Values = map[string]IPRule_Action_STATUS{
	"allow": IPRule_Action_STATUS_Allow,
}

// Gets the state of virtual network rule.
type State_STATUS string

const (
	State_STATUS_Deprovisioning       = State_STATUS("Deprovisioning")
	State_STATUS_Failed               = State_STATUS("Failed")
	State_STATUS_NetworkSourceDeleted = State_STATUS("NetworkSourceDeleted")
	State_STATUS_Provisioning         = State_STATUS("Provisioning")
	State_STATUS_Succeeded            = State_STATUS("Succeeded")
)

// Mapping from string to State_STATUS
var state_STATUS_Values = map[string]State_STATUS{
	"deprovisioning":       State_STATUS_Deprovisioning,
	"failed":               State_STATUS_Failed,
	"networksourcedeleted": State_STATUS_NetworkSourceDeleted,
	"provisioning":         State_STATUS_Provisioning,
	"succeeded":            State_STATUS_Succeeded,
}

type VirtualNetworkRule_Action_STATUS string

const VirtualNetworkRule_Action_STATUS_Allow = VirtualNetworkRule_Action_STATUS("Allow")

// Mapping from string to VirtualNetworkRule_Action_STATUS
var virtualNetworkRule_Action_STATUS_Values = map[string]VirtualNetworkRule_Action_STATUS{
	"allow": VirtualNetworkRule_Action_STATUS_Allow,
}

// Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption
// key will be used. 'Service' key type implies that a default service key is used.
type KeyType_STATUS string

const (
	KeyType_STATUS_Account = KeyType_STATUS("Account")
	KeyType_STATUS_Service = KeyType_STATUS("Service")
)

// Mapping from string to KeyType_STATUS
var keyType_STATUS_Values = map[string]KeyType_STATUS{
	"account": KeyType_STATUS_Account,
	"service": KeyType_STATUS_Service,
}
