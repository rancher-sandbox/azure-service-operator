// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type ManagedClustersAgentPool_Spec struct {
	Name string `json:"name,omitempty"`

	// Properties: Properties of an agent pool.
	Properties *ManagedClusterAgentPoolProfileProperties `json:"properties,omitempty"`
}

var _ genruntime.ARMResourceSpec = &ManagedClustersAgentPool_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2025-10-02-preview"
func (pool ManagedClustersAgentPool_Spec) GetAPIVersion() string {
	return "2025-10-02-preview"
}

// GetName returns the Name of the resource
func (pool *ManagedClustersAgentPool_Spec) GetName() string {
	return pool.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/managedClusters/agentPools"
func (pool *ManagedClustersAgentPool_Spec) GetType() string {
	return "Microsoft.ContainerService/managedClusters/agentPools"
}

// Properties for the container service agent pool profile.
type ManagedClusterAgentPoolProfileProperties struct {
	// ArtifactStreamingProfile: Configuration for using artifact streaming on AKS.
	ArtifactStreamingProfile *AgentPoolArtifactStreamingProfile `json:"artifactStreamingProfile,omitempty"`

	// AvailabilityZones: The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType
	// property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones"`

	// CapacityReservationGroupID: The fully qualified resource ID of the Capacity Reservation Group to provide virtual
	// machines from a reserved group of Virtual Machines. This is of the form:
	// '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
	// Customers use it to create an agentpool with a specified CRG. For more information see [Capacity
	// Reservation](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview)
	CapacityReservationGroupID *string `json:"capacityReservationGroupID,omitempty"`

	// Count: Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive)
	// for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using
	// a snapshot.
	CreationData *CreationData `json:"creationData,omitempty"`

	// EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption. This is only supported on certain VM
	// sizes and in certain Azure regions. For more information, see:
	// https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// EnableFIPS: Whether to use a FIPS-enabled OS. See [Add a FIPS-enabled node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more
	// details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	// EnableNodePublicIP: Whether each node is allocated its own public IP. Some scenarios may require nodes in a node pool to
	// receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to
	// make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP
	// per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	// The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	// EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	// GatewayProfile: Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent pool mode is
	// not Gateway.
	GatewayProfile *AgentPoolGatewayProfile `json:"gatewayProfile,omitempty"`

	// GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile `json:"gpuInstanceProfile,omitempty"`

	// GpuProfile: GPU settings for the Agent Pool.
	GpuProfile *GPUProfile `json:"gpuProfile,omitempty"`

	// HostGroupID: The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from, used only
	// in creation scenario and not allowed to changed once set. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
	// For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
	HostGroupID *string `json:"hostGroupID,omitempty"`

	// KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig *KubeletConfig `json:"kubeletConfig,omitempty"`

	// KubeletDiskType: Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral
	// storage.
	KubeletDiskType *KubeletDiskType `json:"kubeletDiskType,omitempty"`

	// LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig `json:"linuxOSConfig,omitempty"`

	// LocalDNSProfile: Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve
	// performance and reliability of DNS resolution in an AKS cluster. For more details see aka.ms/aks/localdns.
	LocalDNSProfile *LocalDNSProfile `json:"localDNSProfile,omitempty"`

	// MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	// MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	// MessageOfTheDay: Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be written to
	// /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It must not be specified
	// for Windows nodes. It must be a static string (i.e., will be printed raw and not be executed as a script).
	MessageOfTheDay *string `json:"messageOfTheDay,omitempty"`

	// MinCount: The minimum number of nodes for auto-scaling
	MinCount *int `json:"minCount,omitempty"`

	// Mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional
	// information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
	Mode *AgentPoolMode `json:"mode,omitempty"`

	// NetworkProfile: Network-related settings of an agent pool.
	NetworkProfile *AgentPoolNetworkProfile `json:"networkProfile,omitempty"`

	// NodeCustomizationProfile: Settings to determine the node customization used to provision nodes in a pool.
	NodeCustomizationProfile *NodeCustomizationProfile `json:"nodeCustomizationProfile,omitempty"`

	// NodeInitializationTaints: Taints added on the nodes during creation that will not be reconciled by AKS. These taints
	// will not be reconciled by AKS and can be removed with a kubectl call. This field can be modified after node pool is
	// created, but nodes will not be recreated with new taints until another operation that requires recreation (e.g. node
	// image upgrade) happens. These taints allow for required configuration to run before the node is ready to accept
	// workloads, for example 'key1=value1:NoSchedule' that then can be removed with `kubectl taint nodes node1
	// key1=value1:NoSchedule-`
	NodeInitializationTaints []string `json:"nodeInitializationTaints"`

	// NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels" serializationType:"explicitEmptyCollection"`

	// NodePublicIPPrefixID: The public IP prefix ID which VM nodes should use IPs from. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixID *string `json:"nodePublicIPPrefixID,omitempty"`

	// NodeTaints: The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints" serializationType:"explicitEmptyCollection"`

	// OrchestratorVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade
	// all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version
	// as the control plane. The node pool minor version must be within two minor versions of the control plane version. The
	// node pool version cannot be greater than the control plane version. For more information see [upgrading a node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`

	// OsDiskSizeGB: OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you
	// specify 0, it will apply the default osDisk size according to the vmSize specified.
	OsDiskSizeGB *int `json:"osDiskSizeGB,omitempty"`

	// OsDiskType: The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it
	// and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after
	// creation. For more information see [Ephemeral
	// OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
	OsDiskType *OSDiskType `json:"osDiskType,omitempty"`

	// OsSKU: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019
	// when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
	OsSKU *OSSKU `json:"osSKU,omitempty"`

	// OsType: The operating system type. The default is Linux.
	OsType *ManagedClusterAgentPoolProfileProperties_OsType `json:"osType,omitempty"`

	// PodIPAllocationMode: Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with
	// podSubnetId. The default is 'DynamicIndividual'.
	PodIPAllocationMode *PodIPAllocationMode `json:"podIPAllocationMode,omitempty"`

	// PodSubnetID: The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically assigned on the
	// node subnet (see vnetSubnetID for more details). This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetID *string `json:"podSubnetID,omitempty"`

	// PowerState: Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is initially Running.
	// The Agent Pool can be stopped by setting this field to Stopped. A stopped Agent Pool stops all of its VMs and does not
	// accrue billing charges. An Agent Pool can only be stopped if it is Running and provisioning state is Succeeded
	PowerState *PowerState `json:"powerState,omitempty"`

	// ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	// ScaleDownMode: The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler
	// behavior. If not specified, it defaults to Delete.
	ScaleDownMode *ScaleDownMode `json:"scaleDownMode,omitempty"`

	// ScaleSetEvictionPolicy: The Virtual Machine Scale Set eviction policy. The eviction policy specifies what to do with the
	// VM when it is evicted. The default is Delete. For more information about eviction see [spot
	// VMs](https://docs.microsoft.com/azure/virtual-machines/spot-vms)
	ScaleSetEvictionPolicy *ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy `json:"scaleSetEvictionPolicy,omitempty"`

	// ScaleSetPriority: The Virtual Machine Scale Set priority.
	ScaleSetPriority *ManagedClusterAgentPoolProfileProperties_ScaleSetPriority `json:"scaleSetPriority,omitempty"`

	// SecurityProfile: The security settings of an agent pool.
	SecurityProfile *AgentPoolSecurityProfile `json:"securityProfile,omitempty"`

	// SpotMaxPrice: The max price (in US Dollars) you are willing to pay for spot instances. Possible values are any decimal
	// value greater than zero or -1 which indicates default price to be up-to on-demand. Possible values are any decimal value
	// greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing,
	// see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	// Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string `json:"tags" serializationType:"explicitEmptyCollection"`

	// Type: The type of Agent Pool.
	Type *AgentPoolType `json:"type,omitempty"`

	// UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings `json:"upgradeSettings,omitempty"`

	// UpgradeSettingsBlueGreen: Settings for Blue-Green upgrade on the agentpool. Applies when upgrade strategy is set to
	// BlueGreen.
	UpgradeSettingsBlueGreen *AgentPoolBlueGreenUpgradeSettings `json:"upgradeSettingsBlueGreen,omitempty"`

	// UpgradeStrategy: Defines the upgrade strategy for the agent pool. The default is Rolling.
	UpgradeStrategy *UpgradeStrategy `json:"upgradeStrategy,omitempty"`

	// VirtualMachineNodesStatus: The status of nodes in a VirtualMachines agent pool.
	VirtualMachineNodesStatus []VirtualMachineNodes `json:"virtualMachineNodesStatus"`

	// VirtualMachinesProfile: Specifications on VirtualMachines agent pool.
	VirtualMachinesProfile *VirtualMachinesProfile `json:"virtualMachinesProfile,omitempty"`

	// VmSize: The size of the agent pool VMs. VM size availability varies by region. If a node contains insufficient compute
	// resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see:
	// https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	// VnetSubnetID: The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this is not
	// specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods,
	// otherwise it applies to just nodes. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetID *string `json:"vnetSubnetID,omitempty"`

	// WindowsProfile: The Windows agent pool's specific profile.
	WindowsProfile *AgentPoolWindowsProfile `json:"windowsProfile,omitempty"`

	// WorkloadRuntime: Determines the type of workload a node can run.
	WorkloadRuntime *WorkloadRuntime `json:"workloadRuntime,omitempty"`
}

type AgentPoolArtifactStreamingProfile struct {
	// Enabled: Artifact streaming speeds up the cold-start of containers on a node through on-demand image loading. To use
	// this feature, container images must also enable artifact streaming on ACR. If not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`
}

// Settings for blue-green upgrade on an agentpool
type AgentPoolBlueGreenUpgradeSettings struct {
	// BatchSoakDurationInMinutes: The soak duration after draining a batch of nodes, i.e., the amount of time (in minutes) to
	// wait after draining a batch of nodes before moving on the next batch. If not specified, the default is 15 minutes.
	BatchSoakDurationInMinutes *int `json:"batchSoakDurationInMinutes,omitempty"`

	// DrainBatchSize: The number or percentage of nodes to drain in batch during blue-green upgrade. Must be a non-zero
	// number. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it
	// is the percentage of the total number of blue nodes of the initial upgrade operation. For percentages, fractional nodes
	// are rounded up. If not specified, the default is 10%. For more information, including best practices, see:
	// https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
	DrainBatchSize *string `json:"drainBatchSize,omitempty"`

	// DrainTimeoutInMinutes: The drain timeout for a node, i.e., the amount of time (in minutes) to wait on eviction of pods
	// and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is
	// exceeded, the upgrade fails. If not specified, the default is 30 minutes.
	DrainTimeoutInMinutes *int `json:"drainTimeoutInMinutes,omitempty"`

	// FinalSoakDurationInMinutes: The soak duration for a node pool, i.e., the amount of time (in minutes) to wait after all
	// old nodes are drained before we remove the old nodes. If not specified, the default is 60 minutes. Only applicable for
	// blue-green upgrade strategy.
	FinalSoakDurationInMinutes *int `json:"finalSoakDurationInMinutes,omitempty"`
}

// Profile of the managed cluster gateway agent pool.
type AgentPoolGatewayProfile struct {
	// PublicIPPrefixSize: The Gateway agent pool associates one public IPPrefix for each static egress gateway to provide
	// public egress. The size of Public IPPrefix should be selected by the user. Each node in the agent pool is assigned with
	// one IP from the IPPrefix. The IPPrefix size thus serves as a cap on the size of the Gateway agent pool. Due to Azure
	// public IPPrefix size limitation, the valid value range is [28, 31] (/31 = 2 nodes/IPs, /30 = 4 nodes/IPs, /29 = 8
	// nodes/IPs, /28 = 16 nodes/IPs). The default value is 31.
	PublicIPPrefixSize *int `json:"publicIPPrefixSize,omitempty"`
}

// The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional information
// on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
// +kubebuilder:validation:Enum={"Gateway","Machines","ManagedSystem","System","User"}
type AgentPoolMode string

const (
	AgentPoolMode_Gateway       = AgentPoolMode("Gateway")
	AgentPoolMode_Machines      = AgentPoolMode("Machines")
	AgentPoolMode_ManagedSystem = AgentPoolMode("ManagedSystem")
	AgentPoolMode_System        = AgentPoolMode("System")
	AgentPoolMode_User          = AgentPoolMode("User")
)

// Mapping from string to AgentPoolMode
var agentPoolMode_Values = map[string]AgentPoolMode{
	"gateway":       AgentPoolMode_Gateway,
	"machines":      AgentPoolMode_Machines,
	"managedsystem": AgentPoolMode_ManagedSystem,
	"system":        AgentPoolMode_System,
	"user":          AgentPoolMode_User,
}

// Network settings of an agent pool.
type AgentPoolNetworkProfile struct {
	// AllowedHostPorts: The port ranges that are allowed to access. The specified ranges are allowed to overlap.
	AllowedHostPorts []PortRange `json:"allowedHostPorts"`

	// ApplicationSecurityGroups: The IDs of the application security groups which agent pool will associate when created.
	ApplicationSecurityGroups []string `json:"applicationSecurityGroups,omitempty"`

	// NodePublicIPTags: IPTags of instance-level public IPs.
	NodePublicIPTags []IPTag `json:"nodePublicIPTags"`
}

// The security settings of an agent pool.
type AgentPoolSecurityProfile struct {
	// EnableSecureBoot: Secure Boot is a feature of Trusted Launch which ensures that only signed operating systems and
	// drivers can boot. For more details, see aka.ms/aks/trustedlaunch.  If not specified, the default is false.
	EnableSecureBoot *bool `json:"enableSecureBoot,omitempty"`

	// EnableVTPM: vTPM is a Trusted Launch feature for configuring a dedicated secure vault for keys and measurements held
	// locally on the node. For more details, see aka.ms/aks/trustedlaunch. If not specified, the default is false.
	EnableVTPM *bool `json:"enableVTPM,omitempty"`

	// SshAccess: SSH access method of an agent pool.
	SshAccess *AgentPoolSSHAccess `json:"sshAccess,omitempty"`
}

// The type of Agent Pool.
// +kubebuilder:validation:Enum={"AvailabilitySet","VirtualMachineScaleSets","VirtualMachines"}
type AgentPoolType string

const (
	AgentPoolType_AvailabilitySet         = AgentPoolType("AvailabilitySet")
	AgentPoolType_VirtualMachineScaleSets = AgentPoolType("VirtualMachineScaleSets")
	AgentPoolType_VirtualMachines         = AgentPoolType("VirtualMachines")
)

// Mapping from string to AgentPoolType
var agentPoolType_Values = map[string]AgentPoolType{
	"availabilityset":         AgentPoolType_AvailabilitySet,
	"virtualmachinescalesets": AgentPoolType_VirtualMachineScaleSets,
	"virtualmachines":         AgentPoolType_VirtualMachines,
}

// Settings for upgrading an agentpool
type AgentPoolUpgradeSettings struct {
	// DrainTimeoutInMinutes: The drain timeout for a node. The amount of time (in minutes) to wait on eviction of pods and
	// graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is
	// exceeded, the upgrade fails. If not specified, the default is 30 minutes.
	DrainTimeoutInMinutes *int `json:"drainTimeoutInMinutes,omitempty"`

	// MaxBlockedNodes: The maximum number or percentage of extra nodes that are allowed to be blocked in the agent pool during
	// an upgrade when undrainable node behavior is Cordon. This can either be set to an integer (e.g. '5') or a percentage
	// (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the
	// upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is maxSurge. This must always
	// be greater than or equal to maxSurge. For more information, including best practices, see:
	// https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
	MaxBlockedNodes *string `json:"maxBlockedNodes,omitempty"`

	// MaxSurge: The maximum number or percentage of nodes that are surged during upgrade. This can either be set to an integer
	// (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size
	// at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 10%. For
	// more information, including best practices, see: https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
	MaxSurge *string `json:"maxSurge,omitempty"`

	// MaxUnavailable: The maximum number or percentage of nodes that can be simultaneously unavailable during upgrade. This
	// can either be set to an integer (e.g. '1') or a percentage (e.g. '5%'). If a percentage is specified, it is the
	// percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If
	// not specified, the default is 0. For more information, including best practices, see:
	// https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
	MaxUnavailable *string `json:"maxUnavailable,omitempty"`

	// NodeSoakDurationInMinutes: The soak duration for a node. The amount of time (in minutes) to wait after draining a node
	// and before reimaging it and moving on to next node. If not specified, the default is 0 minutes.
	NodeSoakDurationInMinutes *int `json:"nodeSoakDurationInMinutes,omitempty"`

	// UndrainableNodeBehavior: Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable
	// nodes is Pod Disruption Budgets (PDBs), but other issues, such as pod termination grace period is exceeding the
	// remaining per-node drain timeout or pod is still being in a running state, can also cause undrainable nodes.
	UndrainableNodeBehavior *UndrainableNodeBehavior `json:"undrainableNodeBehavior,omitempty"`
}

// The Windows agent pool's specific profile.
type AgentPoolWindowsProfile struct {
	// DisableOutboundNat: Whether to disable OutboundNAT in windows nodes. The default value is false. Outbound NAT can only
	// be disabled if the cluster outboundType is NAT Gateway and the Windows agent pool does not have node public IP enabled.
	DisableOutboundNat *bool `json:"disableOutboundNat,omitempty"`
}

// GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
// +kubebuilder:validation:Enum={"MIG1g","MIG2g","MIG3g","MIG4g","MIG7g"}
type GPUInstanceProfile string

const (
	GPUInstanceProfile_MIG1G = GPUInstanceProfile("MIG1g")
	GPUInstanceProfile_MIG2G = GPUInstanceProfile("MIG2g")
	GPUInstanceProfile_MIG3G = GPUInstanceProfile("MIG3g")
	GPUInstanceProfile_MIG4G = GPUInstanceProfile("MIG4g")
	GPUInstanceProfile_MIG7G = GPUInstanceProfile("MIG7g")
)

// Mapping from string to GPUInstanceProfile
var gPUInstanceProfile_Values = map[string]GPUInstanceProfile{
	"mig1g": GPUInstanceProfile_MIG1G,
	"mig2g": GPUInstanceProfile_MIG2G,
	"mig3g": GPUInstanceProfile_MIG3G,
	"mig4g": GPUInstanceProfile_MIG4G,
	"mig7g": GPUInstanceProfile_MIG7G,
}

// GPU settings for the Agent Pool.
type GPUProfile struct {
	// Driver: Whether to install GPU drivers. When it's not specified, default is Install.
	Driver *GPUDriver `json:"driver,omitempty"`

	// DriverType: Specify the type of GPU driver to install when creating Windows agent pools. If not provided, AKS selects
	// the driver based on system compatibility. This cannot be changed once the AgentPool has been created. This cannot be set
	// on Linux AgentPools. For Linux AgentPools, the driver is selected based on system compatibility.
	DriverType *DriverType `json:"driverType,omitempty"`
}

// Kubelet configurations of agent nodes. See [AKS custom node
// configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration) for more details.
type KubeletConfig struct {
	// AllowedUnsafeSysctls: Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in `*`).
	AllowedUnsafeSysctls []string `json:"allowedUnsafeSysctls"`

	// ContainerLogMaxFiles: The maximum number of container log files that can be present for a container. The number must be
	// â‰¥ 2.
	ContainerLogMaxFiles *int `json:"containerLogMaxFiles,omitempty"`

	// ContainerLogMaxSizeMB: The maximum size (e.g. 10Mi) of container log file before it is rotated.
	ContainerLogMaxSizeMB *int `json:"containerLogMaxSizeMB,omitempty"`

	// CpuCfsQuota: If CPU CFS quota enforcement is enabled for containers that specify CPU limits. The default is true.
	CpuCfsQuota *bool `json:"cpuCfsQuota,omitempty"`

	// CpuCfsQuotaPeriod: The CPU CFS quota period value. The default is '100ms.' Valid values are a sequence of decimal
	// numbers with an optional fraction and a unit suffix. For example: '300ms', '2h45m'. Supported units are 'ns', 'us',
	// 'ms', 's', 'm', and 'h'.
	CpuCfsQuotaPeriod *string `json:"cpuCfsQuotaPeriod,omitempty"`

	// CpuManagerPolicy: The CPU Manager policy to use. The default is 'none'. See [Kubernetes CPU management
	// policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies) for more
	// information. Allowed values are 'none' and 'static'.
	CpuManagerPolicy *string `json:"cpuManagerPolicy,omitempty"`

	// FailSwapOn: If set to true it will make the Kubelet fail to start if swap is enabled on the node.
	FailSwapOn *bool `json:"failSwapOn,omitempty"`

	// ImageGcHighThreshold: The percent of disk usage after which image garbage collection is always run. To disable image
	// garbage collection, set to 100. The default is 85%
	ImageGcHighThreshold *int `json:"imageGcHighThreshold,omitempty"`

	// ImageGcLowThreshold: The percent of disk usage before which image garbage collection is never run. This cannot be set
	// higher than imageGcHighThreshold. The default is 80%
	ImageGcLowThreshold *int `json:"imageGcLowThreshold,omitempty"`

	// PodMaxPids: The maximum number of processes per pod.
	PodMaxPids *int `json:"podMaxPids,omitempty"`

	// SeccompDefault: Specifies the default seccomp profile applied to all workloads. If not specified, 'Unconfined' will be
	// used by default.
	SeccompDefault *SeccompDefault `json:"seccompDefault,omitempty"`

	// TopologyManagerPolicy: The Topology Manager policy to use. For more information see [Kubernetes Topology
	// Manager](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager). The default is 'none'. Allowed values
	// are 'none', 'best-effort', 'restricted', and 'single-numa-node'.
	TopologyManagerPolicy *string `json:"topologyManagerPolicy,omitempty"`
}

// Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
// +kubebuilder:validation:Enum={"OS","Temporary"}
type KubeletDiskType string

const (
	KubeletDiskType_OS        = KubeletDiskType("OS")
	KubeletDiskType_Temporary = KubeletDiskType("Temporary")
)

// Mapping from string to KubeletDiskType
var kubeletDiskType_Values = map[string]KubeletDiskType{
	"os":        KubeletDiskType_OS,
	"temporary": KubeletDiskType_Temporary,
}

// OS configurations of Linux agent nodes. See [AKS custom node
// configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration) for more details.
type LinuxOSConfig struct {
	// SwapFileSizeMB: The size in MB of a swap file that will be created on each node.
	SwapFileSizeMB *int `json:"swapFileSizeMB,omitempty"`

	// Sysctls: Sysctl settings for Linux agent nodes.
	Sysctls *SysctlConfig `json:"sysctls,omitempty"`

	// TransparentHugePageDefrag: Whether the kernel should make aggressive use of memory compaction to make more hugepages
	// available. Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For
	// more information see [Transparent
	// Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
	TransparentHugePageDefrag *string `json:"transparentHugePageDefrag,omitempty"`

	// TransparentHugePageEnabled: Whether transparent hugepages are enabled. Valid values are 'always', 'madvise', and
	// 'never'. The default is 'always'. For more information see [Transparent
	// Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
	TransparentHugePageEnabled *string `json:"transparentHugePageEnabled,omitempty"`
}

// Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve performance and
// reliability of DNS resolution in an AKS cluster. For more details see aka.ms/aks/localdns.
type LocalDNSProfile struct {
	// KubeDNSOverrides: KubeDNS overrides apply to DNS traffic from pods with dnsPolicy:ClusterFirst (referred to as KubeDNS
	// traffic).
	KubeDNSOverrides map[string]LocalDNSOverride `json:"kubeDNSOverrides"`

	// Mode: Mode of enablement for localDNS.
	Mode *LocalDNSProfile_Mode `json:"mode,omitempty"`

	// VnetDNSOverrides: VnetDNS overrides apply to DNS traffic from pods with dnsPolicy:default or kubelet (referred to as
	// VnetDNS traffic).
	VnetDNSOverrides map[string]LocalDNSOverride `json:"vnetDNSOverrides"`
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ManagedClusterAgentPoolProfileProperties_OsType string

const (
	ManagedClusterAgentPoolProfileProperties_OsType_Linux   = ManagedClusterAgentPoolProfileProperties_OsType("Linux")
	ManagedClusterAgentPoolProfileProperties_OsType_Windows = ManagedClusterAgentPoolProfileProperties_OsType("Windows")
)

// Mapping from string to ManagedClusterAgentPoolProfileProperties_OsType
var managedClusterAgentPoolProfileProperties_OsType_Values = map[string]ManagedClusterAgentPoolProfileProperties_OsType{
	"linux":   ManagedClusterAgentPoolProfileProperties_OsType_Linux,
	"windows": ManagedClusterAgentPoolProfileProperties_OsType_Windows,
}

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy string

const (
	ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy_Deallocate = ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy("Deallocate")
	ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy_Delete     = ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy("Delete")
)

// Mapping from string to ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy
var managedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy_Values = map[string]ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy{
	"deallocate": ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy_Deallocate,
	"delete":     ManagedClusterAgentPoolProfileProperties_ScaleSetEvictionPolicy_Delete,
}

// +kubebuilder:validation:Enum={"Regular","Spot"}
type ManagedClusterAgentPoolProfileProperties_ScaleSetPriority string

const (
	ManagedClusterAgentPoolProfileProperties_ScaleSetPriority_Regular = ManagedClusterAgentPoolProfileProperties_ScaleSetPriority("Regular")
	ManagedClusterAgentPoolProfileProperties_ScaleSetPriority_Spot    = ManagedClusterAgentPoolProfileProperties_ScaleSetPriority("Spot")
)

// Mapping from string to ManagedClusterAgentPoolProfileProperties_ScaleSetPriority
var managedClusterAgentPoolProfileProperties_ScaleSetPriority_Values = map[string]ManagedClusterAgentPoolProfileProperties_ScaleSetPriority{
	"regular": ManagedClusterAgentPoolProfileProperties_ScaleSetPriority_Regular,
	"spot":    ManagedClusterAgentPoolProfileProperties_ScaleSetPriority_Spot,
}

// Settings to determine the node customization used to provision nodes in a pool.
type NodeCustomizationProfile struct {
	// NodeCustomizationId: The resource ID of the node customization resource to use. This can be a version. Omitting the
	// version will use the latest version of the node customization.
	NodeCustomizationId *string `json:"nodeCustomizationId,omitempty"`
}

// The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it and has a
// cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation.
// For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
// +kubebuilder:validation:Enum={"Ephemeral","Managed"}
type OSDiskType string

const (
	OSDiskType_Ephemeral = OSDiskType("Ephemeral")
	OSDiskType_Managed   = OSDiskType("Managed")
)

// Mapping from string to OSDiskType
var oSDiskType_Values = map[string]OSDiskType{
	"ephemeral": OSDiskType_Ephemeral,
	"managed":   OSDiskType_Managed,
}

// Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when
// Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
// +kubebuilder:validation:Enum={"AzureLinux","AzureLinux3","CBLMariner","Flatcar","Mariner","Ubuntu","Ubuntu2204","Ubuntu2404","Windows2019","Windows2022","Windows2025","WindowsAnnual"}
type OSSKU string

const (
	OSSKU_AzureLinux    = OSSKU("AzureLinux")
	OSSKU_AzureLinux3   = OSSKU("AzureLinux3")
	OSSKU_CBLMariner    = OSSKU("CBLMariner")
	OSSKU_Flatcar       = OSSKU("Flatcar")
	OSSKU_Mariner       = OSSKU("Mariner")
	OSSKU_Ubuntu        = OSSKU("Ubuntu")
	OSSKU_Ubuntu2204    = OSSKU("Ubuntu2204")
	OSSKU_Ubuntu2404    = OSSKU("Ubuntu2404")
	OSSKU_Windows2019   = OSSKU("Windows2019")
	OSSKU_Windows2022   = OSSKU("Windows2022")
	OSSKU_Windows2025   = OSSKU("Windows2025")
	OSSKU_WindowsAnnual = OSSKU("WindowsAnnual")
)

// Mapping from string to OSSKU
var oSSKU_Values = map[string]OSSKU{
	"azurelinux":    OSSKU_AzureLinux,
	"azurelinux3":   OSSKU_AzureLinux3,
	"cblmariner":    OSSKU_CBLMariner,
	"flatcar":       OSSKU_Flatcar,
	"mariner":       OSSKU_Mariner,
	"ubuntu":        OSSKU_Ubuntu,
	"ubuntu2204":    OSSKU_Ubuntu2204,
	"ubuntu2404":    OSSKU_Ubuntu2404,
	"windows2019":   OSSKU_Windows2019,
	"windows2022":   OSSKU_Windows2022,
	"windows2025":   OSSKU_Windows2025,
	"windowsannual": OSSKU_WindowsAnnual,
}

// Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with podSubnetId. The default is
// 'DynamicIndividual'.
// +kubebuilder:validation:Enum={"DynamicIndividual","StaticBlock"}
type PodIPAllocationMode string

const (
	PodIPAllocationMode_DynamicIndividual = PodIPAllocationMode("DynamicIndividual")
	PodIPAllocationMode_StaticBlock       = PodIPAllocationMode("StaticBlock")
)

// Mapping from string to PodIPAllocationMode
var podIPAllocationMode_Values = map[string]PodIPAllocationMode{
	"dynamicindividual": PodIPAllocationMode_DynamicIndividual,
	"staticblock":       PodIPAllocationMode_StaticBlock,
}

// Describes the Power State of the cluster
type PowerState struct {
	// Code: Tells whether the cluster is Running or Stopped
	Code *Code `json:"code,omitempty"`
}

// Describes how VMs are added to or removed from Agent Pools. See [billing
// states](https://docs.microsoft.com/azure/virtual-machines/states-billing).
// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type ScaleDownMode string

const (
	ScaleDownMode_Deallocate = ScaleDownMode("Deallocate")
	ScaleDownMode_Delete     = ScaleDownMode("Delete")
)

// Mapping from string to ScaleDownMode
var scaleDownMode_Values = map[string]ScaleDownMode{
	"deallocate": ScaleDownMode_Deallocate,
	"delete":     ScaleDownMode_Delete,
}

// Defines the upgrade strategy for the agent pool. The default is Rolling.
// +kubebuilder:validation:Enum={"BlueGreen","Rolling"}
type UpgradeStrategy string

const (
	UpgradeStrategy_BlueGreen = UpgradeStrategy("BlueGreen")
	UpgradeStrategy_Rolling   = UpgradeStrategy("Rolling")
)

// Mapping from string to UpgradeStrategy
var upgradeStrategy_Values = map[string]UpgradeStrategy{
	"bluegreen": UpgradeStrategy_BlueGreen,
	"rolling":   UpgradeStrategy_Rolling,
}

// Current status on a group of nodes of the same vm size.
type VirtualMachineNodes struct {
	// Count: Number of nodes.
	Count *int `json:"count,omitempty"`

	// Size: The VM size of the agents used to host this group of nodes.
	Size *string `json:"size,omitempty"`
}

// Specifications on VirtualMachines agent pool.
type VirtualMachinesProfile struct {
	// Scale: Specifications on how to scale a VirtualMachines agent pool.
	Scale *ScaleProfile `json:"scale,omitempty"`
}

// Determines the type of workload a node can run.
// +kubebuilder:validation:Enum={"KataMshvVmIsolation","KataVmIsolation","OCIContainer","WasmWasi"}
type WorkloadRuntime string

const (
	WorkloadRuntime_KataMshvVmIsolation = WorkloadRuntime("KataMshvVmIsolation")
	WorkloadRuntime_KataVmIsolation     = WorkloadRuntime("KataVmIsolation")
	WorkloadRuntime_OCIContainer        = WorkloadRuntime("OCIContainer")
	WorkloadRuntime_WasmWasi            = WorkloadRuntime("WasmWasi")
)

// Mapping from string to WorkloadRuntime
var workloadRuntime_Values = map[string]WorkloadRuntime{
	"katamshvvmisolation": WorkloadRuntime_KataMshvVmIsolation,
	"katavmisolation":     WorkloadRuntime_KataVmIsolation,
	"ocicontainer":        WorkloadRuntime_OCIContainer,
	"wasmwasi":            WorkloadRuntime_WasmWasi,
}

// SSH access method of an agent pool.
// +kubebuilder:validation:Enum={"Disabled","EntraId","LocalUser"}
type AgentPoolSSHAccess string

const (
	AgentPoolSSHAccess_Disabled  = AgentPoolSSHAccess("Disabled")
	AgentPoolSSHAccess_EntraId   = AgentPoolSSHAccess("EntraId")
	AgentPoolSSHAccess_LocalUser = AgentPoolSSHAccess("LocalUser")
)

// Mapping from string to AgentPoolSSHAccess
var agentPoolSSHAccess_Values = map[string]AgentPoolSSHAccess{
	"disabled":  AgentPoolSSHAccess_Disabled,
	"entraid":   AgentPoolSSHAccess_EntraId,
	"localuser": AgentPoolSSHAccess_LocalUser,
}

// Tells whether the cluster is Running or Stopped
// +kubebuilder:validation:Enum={"Running","Stopped"}
type Code string

const (
	Code_Running = Code("Running")
	Code_Stopped = Code("Stopped")
)

// Mapping from string to Code
var code_Values = map[string]Code{
	"running": Code_Running,
	"stopped": Code_Stopped,
}

// Specify the type of GPU driver to install when creating Windows agent pools. If not provided, AKS selects the driver
// based on system compatibility. This cannot be changed once the AgentPool has been created. This cannot be set on Linux
// AgentPools. For Linux AgentPools, the driver is selected based on system compatibility.
// +kubebuilder:validation:Enum={"CUDA","GRID"}
type DriverType string

const (
	DriverType_CUDA = DriverType("CUDA")
	DriverType_GRID = DriverType("GRID")
)

// Mapping from string to DriverType
var driverType_Values = map[string]DriverType{
	"cuda": DriverType_CUDA,
	"grid": DriverType_GRID,
}

// Whether to install GPU drivers. When it's not specified, default is Install.
// +kubebuilder:validation:Enum={"Install","None"}
type GPUDriver string

const (
	GPUDriver_Install = GPUDriver("Install")
	GPUDriver_None    = GPUDriver("None")
)

// Mapping from string to GPUDriver
var gPUDriver_Values = map[string]GPUDriver{
	"install": GPUDriver_Install,
	"none":    GPUDriver_None,
}

// Contains the IPTag associated with the object.
type IPTag struct {
	// IpTagType: The IP tag type. Example: RoutingPreference.
	IpTagType *string `json:"ipTagType,omitempty"`

	// Tag: The value of the IP tag associated with the public IP. Example: Internet.
	Tag *string `json:"tag,omitempty"`
}

// Overrides for localDNS profile.
type LocalDNSOverride struct {
	// CacheDurationInSeconds: Cache max TTL in seconds. See [cache plugin](https://coredns.io/plugins/cache) for more
	// information.
	CacheDurationInSeconds *int `json:"cacheDurationInSeconds,omitempty"`

	// ForwardDestination: Destination server for DNS queries to be forwarded from localDNS.
	ForwardDestination *LocalDNSOverride_ForwardDestination `json:"forwardDestination,omitempty"`

	// ForwardPolicy: Forward policy for selecting upstream DNS server. See [forward
	// plugin](https://coredns.io/plugins/forward) for more information.
	ForwardPolicy *LocalDNSOverride_ForwardPolicy `json:"forwardPolicy,omitempty"`

	// MaxConcurrent: Maximum number of concurrent queries. See [forward plugin](https://coredns.io/plugins/forward) for more
	// information.
	MaxConcurrent *int `json:"maxConcurrent,omitempty"`

	// Protocol: Enforce TCP or prefer UDP protocol for connections from localDNS to upstream DNS server.
	Protocol *LocalDNSOverride_Protocol `json:"protocol,omitempty"`

	// QueryLogging: Log level for DNS queries in localDNS.
	QueryLogging *LocalDNSOverride_QueryLogging `json:"queryLogging,omitempty"`

	// ServeStale: Policy for serving stale data. See [cache plugin](https://coredns.io/plugins/cache) for more information.
	ServeStale *LocalDNSOverride_ServeStale `json:"serveStale,omitempty"`

	// ServeStaleDurationInSeconds: Serve stale duration in seconds. See [cache plugin](https://coredns.io/plugins/cache) for
	// more information.
	ServeStaleDurationInSeconds *int `json:"serveStaleDurationInSeconds,omitempty"`
}

// +kubebuilder:validation:Enum={"Disabled","Preferred","Required"}
type LocalDNSProfile_Mode string

const (
	LocalDNSProfile_Mode_Disabled  = LocalDNSProfile_Mode("Disabled")
	LocalDNSProfile_Mode_Preferred = LocalDNSProfile_Mode("Preferred")
	LocalDNSProfile_Mode_Required  = LocalDNSProfile_Mode("Required")
)

// Mapping from string to LocalDNSProfile_Mode
var localDNSProfile_Mode_Values = map[string]LocalDNSProfile_Mode{
	"disabled":  LocalDNSProfile_Mode_Disabled,
	"preferred": LocalDNSProfile_Mode_Preferred,
	"required":  LocalDNSProfile_Mode_Required,
}

// The port range.
type PortRange struct {
	// PortEnd: The maximum port that is included in the range. It should be ranged from 1 to 65535, and be greater than or
	// equal to portStart.
	PortEnd *int `json:"portEnd,omitempty"`

	// PortStart: The minimum port that is included in the range. It should be ranged from 1 to 65535, and be less than or
	// equal to portEnd.
	PortStart *int `json:"portStart,omitempty"`

	// Protocol: The network protocol of the port.
	Protocol *Protocol `json:"protocol,omitempty"`
}

// Specifications on how to scale a VirtualMachines agent pool.
type ScaleProfile struct {
	// Autoscale: Specifications on how to auto-scale the VirtualMachines agent pool within a predefined size range.
	Autoscale *AutoScaleProfile `json:"autoscale,omitempty"`

	// Manual: Specifications on how to scale the VirtualMachines agent pool to a fixed size.
	Manual []ManualScaleProfile `json:"manual"`
}

// Specifies the default seccomp profile applied to all workloads. If not specified, 'Unconfined' will be used by default.
// +kubebuilder:validation:Enum={"RuntimeDefault","Unconfined"}
type SeccompDefault string

const (
	SeccompDefault_RuntimeDefault = SeccompDefault("RuntimeDefault")
	SeccompDefault_Unconfined     = SeccompDefault("Unconfined")
)

// Mapping from string to SeccompDefault
var seccompDefault_Values = map[string]SeccompDefault{
	"runtimedefault": SeccompDefault_RuntimeDefault,
	"unconfined":     SeccompDefault_Unconfined,
}

// Sysctl settings for Linux agent nodes.
type SysctlConfig struct {
	// FsAioMaxNr: Sysctl setting fs.aio-max-nr.
	FsAioMaxNr *int `json:"fsAioMaxNr,omitempty"`

	// FsFileMax: Sysctl setting fs.file-max.
	FsFileMax *int `json:"fsFileMax,omitempty"`

	// FsInotifyMaxUserWatches: Sysctl setting fs.inotify.max_user_watches.
	FsInotifyMaxUserWatches *int `json:"fsInotifyMaxUserWatches,omitempty"`

	// FsNrOpen: Sysctl setting fs.nr_open.
	FsNrOpen *int `json:"fsNrOpen,omitempty"`

	// KernelThreadsMax: Sysctl setting kernel.threads-max.
	KernelThreadsMax *int `json:"kernelThreadsMax,omitempty"`

	// NetCoreNetdevMaxBacklog: Sysctl setting net.core.netdev_max_backlog.
	NetCoreNetdevMaxBacklog *int `json:"netCoreNetdevMaxBacklog,omitempty"`

	// NetCoreOptmemMax: Sysctl setting net.core.optmem_max.
	NetCoreOptmemMax *int `json:"netCoreOptmemMax,omitempty"`

	// NetCoreRmemDefault: Sysctl setting net.core.rmem_default.
	NetCoreRmemDefault *int `json:"netCoreRmemDefault,omitempty"`

	// NetCoreRmemMax: Sysctl setting net.core.rmem_max.
	NetCoreRmemMax *int `json:"netCoreRmemMax,omitempty"`

	// NetCoreSomaxconn: Sysctl setting net.core.somaxconn.
	NetCoreSomaxconn *int `json:"netCoreSomaxconn,omitempty"`

	// NetCoreWmemDefault: Sysctl setting net.core.wmem_default.
	NetCoreWmemDefault *int `json:"netCoreWmemDefault,omitempty"`

	// NetCoreWmemMax: Sysctl setting net.core.wmem_max.
	NetCoreWmemMax *int `json:"netCoreWmemMax,omitempty"`

	// NetIpv4IpLocalPortRange: Sysctl setting net.ipv4.ip_local_port_range.
	NetIpv4IpLocalPortRange *string `json:"netIpv4IpLocalPortRange,omitempty"`

	// NetIpv4NeighDefaultGcThresh1: Sysctl setting net.ipv4.neigh.default.gc_thresh1.
	NetIpv4NeighDefaultGcThresh1 *int `json:"netIpv4NeighDefaultGcThresh1,omitempty"`

	// NetIpv4NeighDefaultGcThresh2: Sysctl setting net.ipv4.neigh.default.gc_thresh2.
	NetIpv4NeighDefaultGcThresh2 *int `json:"netIpv4NeighDefaultGcThresh2,omitempty"`

	// NetIpv4NeighDefaultGcThresh3: Sysctl setting net.ipv4.neigh.default.gc_thresh3.
	NetIpv4NeighDefaultGcThresh3 *int `json:"netIpv4NeighDefaultGcThresh3,omitempty"`

	// NetIpv4TcpFinTimeout: Sysctl setting net.ipv4.tcp_fin_timeout.
	NetIpv4TcpFinTimeout *int `json:"netIpv4TcpFinTimeout,omitempty"`

	// NetIpv4TcpKeepaliveProbes: Sysctl setting net.ipv4.tcp_keepalive_probes.
	NetIpv4TcpKeepaliveProbes *int `json:"netIpv4TcpKeepaliveProbes,omitempty"`

	// NetIpv4TcpKeepaliveTime: Sysctl setting net.ipv4.tcp_keepalive_time.
	NetIpv4TcpKeepaliveTime *int `json:"netIpv4TcpKeepaliveTime,omitempty"`

	// NetIpv4TcpMaxSynBacklog: Sysctl setting net.ipv4.tcp_max_syn_backlog.
	NetIpv4TcpMaxSynBacklog *int `json:"netIpv4TcpMaxSynBacklog,omitempty"`

	// NetIpv4TcpMaxTwBuckets: Sysctl setting net.ipv4.tcp_max_tw_buckets.
	NetIpv4TcpMaxTwBuckets *int `json:"netIpv4TcpMaxTwBuckets,omitempty"`

	// NetIpv4TcpTwReuse: Sysctl setting net.ipv4.tcp_tw_reuse.
	NetIpv4TcpTwReuse *bool `json:"netIpv4TcpTwReuse,omitempty"`

	// NetIpv4TcpkeepaliveIntvl: Sysctl setting net.ipv4.tcp_keepalive_intvl.
	NetIpv4TcpkeepaliveIntvl *int `json:"netIpv4TcpkeepaliveIntvl,omitempty"`

	// NetNetfilterNfConntrackBuckets: Sysctl setting net.netfilter.nf_conntrack_buckets.
	NetNetfilterNfConntrackBuckets *int `json:"netNetfilterNfConntrackBuckets,omitempty"`

	// NetNetfilterNfConntrackMax: Sysctl setting net.netfilter.nf_conntrack_max.
	NetNetfilterNfConntrackMax *int `json:"netNetfilterNfConntrackMax,omitempty"`

	// VmMaxMapCount: Sysctl setting vm.max_map_count.
	VmMaxMapCount *int `json:"vmMaxMapCount,omitempty"`

	// VmSwappiness: Sysctl setting vm.swappiness.
	VmSwappiness *int `json:"vmSwappiness,omitempty"`

	// VmVfsCachePressure: Sysctl setting vm.vfs_cache_pressure.
	VmVfsCachePressure *int `json:"vmVfsCachePressure,omitempty"`
}

// Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable nodes is Pod Disruption
// Budgets (PDBs), but other issues, such as pod termination grace period is exceeding the remaining per-node drain timeout
// or pod is still being in a running state, can also cause undrainable nodes.
// +kubebuilder:validation:Enum={"Cordon","Schedule"}
type UndrainableNodeBehavior string

const (
	UndrainableNodeBehavior_Cordon   = UndrainableNodeBehavior("Cordon")
	UndrainableNodeBehavior_Schedule = UndrainableNodeBehavior("Schedule")
)

// Mapping from string to UndrainableNodeBehavior
var undrainableNodeBehavior_Values = map[string]UndrainableNodeBehavior{
	"cordon":   UndrainableNodeBehavior_Cordon,
	"schedule": UndrainableNodeBehavior_Schedule,
}

// Specifications on auto-scaling.
type AutoScaleProfile struct {
	// MaxCount: The maximum number of nodes of the specified sizes.
	MaxCount *int `json:"maxCount,omitempty"`

	// MinCount: The minimum number of nodes of the specified sizes.
	MinCount *int `json:"minCount,omitempty"`

	// Size: VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3', 'Standard_E16s_v3' or
	// 'Standard_D16s_v5'.
	Size *string `json:"size,omitempty"`
}

// +kubebuilder:validation:Enum={"ClusterCoreDNS","VnetDNS"}
type LocalDNSOverride_ForwardDestination string

const (
	LocalDNSOverride_ForwardDestination_ClusterCoreDNS = LocalDNSOverride_ForwardDestination("ClusterCoreDNS")
	LocalDNSOverride_ForwardDestination_VnetDNS        = LocalDNSOverride_ForwardDestination("VnetDNS")
)

// Mapping from string to LocalDNSOverride_ForwardDestination
var localDNSOverride_ForwardDestination_Values = map[string]LocalDNSOverride_ForwardDestination{
	"clustercoredns": LocalDNSOverride_ForwardDestination_ClusterCoreDNS,
	"vnetdns":        LocalDNSOverride_ForwardDestination_VnetDNS,
}

// +kubebuilder:validation:Enum={"Random","RoundRobin","Sequential"}
type LocalDNSOverride_ForwardPolicy string

const (
	LocalDNSOverride_ForwardPolicy_Random     = LocalDNSOverride_ForwardPolicy("Random")
	LocalDNSOverride_ForwardPolicy_RoundRobin = LocalDNSOverride_ForwardPolicy("RoundRobin")
	LocalDNSOverride_ForwardPolicy_Sequential = LocalDNSOverride_ForwardPolicy("Sequential")
)

// Mapping from string to LocalDNSOverride_ForwardPolicy
var localDNSOverride_ForwardPolicy_Values = map[string]LocalDNSOverride_ForwardPolicy{
	"random":     LocalDNSOverride_ForwardPolicy_Random,
	"roundrobin": LocalDNSOverride_ForwardPolicy_RoundRobin,
	"sequential": LocalDNSOverride_ForwardPolicy_Sequential,
}

// +kubebuilder:validation:Enum={"ForceTCP","PreferUDP"}
type LocalDNSOverride_Protocol string

const (
	LocalDNSOverride_Protocol_ForceTCP  = LocalDNSOverride_Protocol("ForceTCP")
	LocalDNSOverride_Protocol_PreferUDP = LocalDNSOverride_Protocol("PreferUDP")
)

// Mapping from string to LocalDNSOverride_Protocol
var localDNSOverride_Protocol_Values = map[string]LocalDNSOverride_Protocol{
	"forcetcp":  LocalDNSOverride_Protocol_ForceTCP,
	"preferudp": LocalDNSOverride_Protocol_PreferUDP,
}

// +kubebuilder:validation:Enum={"Error","Log"}
type LocalDNSOverride_QueryLogging string

const (
	LocalDNSOverride_QueryLogging_Error = LocalDNSOverride_QueryLogging("Error")
	LocalDNSOverride_QueryLogging_Log   = LocalDNSOverride_QueryLogging("Log")
)

// Mapping from string to LocalDNSOverride_QueryLogging
var localDNSOverride_QueryLogging_Values = map[string]LocalDNSOverride_QueryLogging{
	"error": LocalDNSOverride_QueryLogging_Error,
	"log":   LocalDNSOverride_QueryLogging_Log,
}

// +kubebuilder:validation:Enum={"Disable","Immediate","Verify"}
type LocalDNSOverride_ServeStale string

const (
	LocalDNSOverride_ServeStale_Disable   = LocalDNSOverride_ServeStale("Disable")
	LocalDNSOverride_ServeStale_Immediate = LocalDNSOverride_ServeStale("Immediate")
	LocalDNSOverride_ServeStale_Verify    = LocalDNSOverride_ServeStale("Verify")
)

// Mapping from string to LocalDNSOverride_ServeStale
var localDNSOverride_ServeStale_Values = map[string]LocalDNSOverride_ServeStale{
	"disable":   LocalDNSOverride_ServeStale_Disable,
	"immediate": LocalDNSOverride_ServeStale_Immediate,
	"verify":    LocalDNSOverride_ServeStale_Verify,
}

// Specifications on number of machines.
type ManualScaleProfile struct {
	// Count: Number of nodes.
	Count *int `json:"count,omitempty"`

	// Size: VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3', 'Standard_E16s_v3' or
	// 'Standard_D16s_v5'.
	Size *string `json:"size,omitempty"`
}

// The network protocol of the port.
// +kubebuilder:validation:Enum={"TCP","UDP"}
type Protocol string

const (
	Protocol_TCP = Protocol("TCP")
	Protocol_UDP = Protocol("UDP")
)

// Mapping from string to Protocol
var protocol_Values = map[string]Protocol{
	"tcp": Protocol_TCP,
	"udp": Protocol_UDP,
}
