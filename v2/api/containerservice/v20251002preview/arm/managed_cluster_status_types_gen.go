// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"

// Managed cluster.
type ManagedCluster_STATUS struct {
	// ETag: If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
	// Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in
	// the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header
	// fields.
	ETag *string `json:"eTag,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the managed cluster, if configured.
	Identity *ManagedClusterIdentity_STATUS `json:"identity,omitempty"`

	// Kind: This is primarily used to expose different UI experiences in the portal for different kinds
	Kind *string `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Properties of a managed cluster.
	Properties *ManagedClusterProperties_STATUS `json:"properties,omitempty"`

	// Sku: The managed cluster SKU.
	Sku *ManagedClusterSKU_STATUS `json:"sku,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// The complex type of the extended location.
type ExtendedLocation_STATUS struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationTypes_STATUS `json:"type,omitempty"`
}

// Identity for the managed cluster.
type ManagedClusterIdentity_STATUS struct {
	// DelegatedResources: The delegated identity resources assigned to this managed cluster. This can only be set by another
	// Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.
	DelegatedResources map[string]DelegatedResource_STATUS `json:"delegatedResources"`

	// PrincipalId: The principal id of the system assigned identity which is used by master components.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id of the system assigned identity which is used by master components.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the managed cluster. For more information see [use managed identities in
	// AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
	Type *ResourceIdentityType_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The user identity associated with the managed cluster. This identity will be used in control
	// plane. Only one user assigned identity is allowed. The keys must be ARM resource IDs in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS `json:"userAssignedIdentities"`
}

// Properties of the managed cluster.
type ManagedClusterProperties_STATUS struct {
	// AadProfile: The Azure Active Directory configuration.
	AadProfile *ManagedClusterAADProfile_STATUS `json:"aadProfile,omitempty"`

	// AddonProfiles: The profile of managed cluster add-on.
	AddonProfiles map[string]ManagedClusterAddonProfile_STATUS `json:"addonProfiles"`

	// AgentPoolProfiles: The agent pool properties.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile_STATUS `json:"agentPoolProfiles"`

	// AiToolchainOperatorProfile: AI toolchain operator settings that apply to the whole cluster.
	AiToolchainOperatorProfile *ManagedClusterAIToolchainOperatorProfile_STATUS `json:"aiToolchainOperatorProfile,omitempty"`

	// ApiServerAccessProfile: The access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile_STATUS `json:"apiServerAccessProfile,omitempty"`

	// AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when enabled
	AutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile_STATUS `json:"autoScalerProfile,omitempty"`

	// AutoUpgradeProfile: The auto upgrade configuration.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile_STATUS `json:"autoUpgradeProfile,omitempty"`

	// AzureMonitorProfile: Azure Monitor addon profiles for monitoring the managed cluster.
	AzureMonitorProfile *ManagedClusterAzureMonitorProfile_STATUS `json:"azureMonitorProfile,omitempty"`

	// AzurePortalFQDN: The special FQDN used by the Azure Portal to access the Managed Cluster. This FQDN is for use only by
	// the Azure Portal and should not be used by other clients. The Azure Portal requires certain Cross-Origin Resource
	// Sharing (CORS) headers to be sent in some responses, which Kubernetes APIServer doesn't handle by default. This special
	// FQDN supports CORS, allowing the Azure Portal to function properly.
	AzurePortalFQDN *string `json:"azurePortalFQDN,omitempty"`

	// BootstrapProfile: Profile of the cluster bootstrap configuration.
	BootstrapProfile *ManagedClusterBootstrapProfile_STATUS `json:"bootstrapProfile,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the cluster will be created/upgraded using a
	// snapshot.
	CreationData *CreationData_STATUS `json:"creationData,omitempty"`

	// CurrentKubernetesVersion: The version of Kubernetes the Managed Cluster is running. If kubernetesVersion was a fully
	// specified version <major.minor.patch>, this field will be exactly equal to it. If kubernetesVersion was <major.minor>,
	// this field will contain the full <major.minor.patch> version being used.
	CurrentKubernetesVersion *string `json:"currentKubernetesVersion,omitempty"`

	// DisableLocalAccounts: If local accounts should be disabled on the Managed Cluster. If set to true, getting static
	// credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more
	// details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	// DiskEncryptionSetID: The Resource ID of the disk encryption set to use for enabling encryption at rest. This is of the
	// form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
	DiskEncryptionSetID *string `json:"diskEncryptionSetID,omitempty"`

	// DnsPrefix: The DNS prefix of the Managed Cluster. This cannot be updated once the Managed Cluster has been created.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	// EnableNamespaceResources: Enable namespace as Azure resource. The default value is false. It can be enabled/disabled on
	// creation and updating of the managed cluster. See
	// [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource) for more details on Namespace as a ARM
	// Resource.
	EnableNamespaceResources *bool `json:"enableNamespaceResources,omitempty"`

	// EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	// Fqdn: The FQDN of the master pool.
	Fqdn *string `json:"fqdn,omitempty"`

	// FqdnSubdomain: The FQDN subdomain of the private cluster with custom private dns zone. This cannot be updated once the
	// Managed Cluster has been created.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	// HostedSystemProfile: Settings for hosted system addons. For more information, see
	// https://aka.ms/aks/automatic/systemcomponents.
	HostedSystemProfile *ManagedClusterHostedSystemProfile_STATUS `json:"hostedSystemProfile,omitempty"`

	// HttpProxyConfig: Configurations for provisioning the cluster with HTTP proxy servers.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig_STATUS `json:"httpProxyConfig,omitempty"`

	// IdentityProfile: The user identity associated with the managed cluster. This identity will be used by the kubelet. Only
	// one user assigned identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId":
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
	IdentityProfile map[string]UserAssignedIdentity_STATUS `json:"identityProfile"`

	// IngressProfile: Ingress profile for the managed cluster.
	IngressProfile *ManagedClusterIngressProfile_STATUS `json:"ingressProfile,omitempty"`

	// KubernetesVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS
	// cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version
	// number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not
	// allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	// LinuxProfile: The profile for Linux VMs in the Managed Cluster.
	LinuxProfile *ContainerServiceLinuxProfile_STATUS `json:"linuxProfile,omitempty"`

	// MaxAgentPools: The max number of agent pools for the managed cluster.
	MaxAgentPools *int `json:"maxAgentPools,omitempty"`

	// MetricsProfile: Optional cluster metrics configuration.
	MetricsProfile *ManagedClusterMetricsProfile_STATUS `json:"metricsProfile,omitempty"`

	// NetworkProfile: The network configuration profile.
	NetworkProfile *ContainerServiceNetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// NodeProvisioningProfile: Node provisioning settings that apply to the whole cluster.
	NodeProvisioningProfile *ManagedClusterNodeProvisioningProfile_STATUS `json:"nodeProvisioningProfile,omitempty"`

	// NodeResourceGroup: The name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	// NodeResourceGroupProfile: Profile of the node resource group configuration.
	NodeResourceGroupProfile *ManagedClusterNodeResourceGroupProfile_STATUS `json:"nodeResourceGroupProfile,omitempty"`

	// OidcIssuerProfile: The OIDC issuer profile of the Managed Cluster.
	OidcIssuerProfile *ManagedClusterOIDCIssuerProfile_STATUS `json:"oidcIssuerProfile,omitempty"`

	// PodIdentityProfile: The pod identity profile of the Managed Cluster. See [use AAD pod
	// identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on AAD pod identity
	// integration.
	PodIdentityProfile *ManagedClusterPodIdentityProfile_STATUS `json:"podIdentityProfile,omitempty"`

	// PowerState: The Power State of the cluster.
	PowerState *PowerState_STATUS `json:"powerState,omitempty"`

	// PrivateFQDN: The FQDN of private cluster.
	PrivateFQDN *string `json:"privateFQDN,omitempty"`

	// PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource_STATUS `json:"privateLinkResources"`

	// ProvisioningState: The current provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
	PublicNetworkAccess *PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ResourceUID: The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create, delete, create
	// sequence)
	ResourceUID *string `json:"resourceUID,omitempty"`

	// SchedulerProfile: Profile of the pod scheduler configuration.
	SchedulerProfile *SchedulerProfile_STATUS `json:"schedulerProfile,omitempty"`

	// SecurityProfile: Security profile for the managed cluster.
	SecurityProfile *ManagedClusterSecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// ServiceMeshProfile: Service mesh profile for a managed cluster.
	ServiceMeshProfile *ServiceMeshProfile_STATUS `json:"serviceMeshProfile,omitempty"`

	// ServicePrincipalProfile: Information about a service principal identity for the cluster to use for manipulating Azure
	// APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_STATUS `json:"servicePrincipalProfile,omitempty"`

	// Status: Contains read-only information about the Managed Cluster.
	Status *ManagedClusterStatus_STATUS `json:"status,omitempty"`

	// StorageProfile: Storage profile for the managed cluster.
	StorageProfile *ManagedClusterStorageProfile_STATUS `json:"storageProfile,omitempty"`

	// SupportPlan: The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
	SupportPlan *KubernetesSupportPlan_STATUS `json:"supportPlan,omitempty"`

	// UpgradeSettings: Settings for upgrading a cluster.
	UpgradeSettings *ClusterUpgradeSettings_STATUS `json:"upgradeSettings,omitempty"`

	// WindowsProfile: The profile for Windows VMs in the Managed Cluster.
	WindowsProfile *ManagedClusterWindowsProfile_STATUS `json:"windowsProfile,omitempty"`

	// WorkloadAutoScalerProfile: Workload Auto-scaler profile for the managed cluster.
	WorkloadAutoScalerProfile *ManagedClusterWorkloadAutoScalerProfile_STATUS `json:"workloadAutoScalerProfile,omitempty"`
}

// The SKU of a Managed Cluster.
type ManagedClusterSKU_STATUS struct {
	// Name: The name of a managed cluster SKU.
	Name *ManagedClusterSKUName_STATUS `json:"name,omitempty"`

	// Tier: The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing
	// Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
	Tier *ManagedClusterSKUTier_STATUS `json:"tier,omitempty"`
}

// Settings for upgrading a cluster.
type ClusterUpgradeSettings_STATUS struct {
	// OverrideSettings: Settings for overrides.
	OverrideSettings *UpgradeOverrideSettings_STATUS `json:"overrideSettings,omitempty"`
}

// Profile for Linux VMs in the container service cluster.
type ContainerServiceLinuxProfile_STATUS struct {
	// AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// Ssh: The SSH configuration for Linux-based VMs running on Azure.
	Ssh *ContainerServiceSshConfiguration_STATUS `json:"ssh,omitempty"`
}

// Profile of network configuration.
type ContainerServiceNetworkProfile_STATUS struct {
	// AdvancedNetworking: Advanced Networking profile for enabling observability and security feature suite on a cluster. For
	// more information see aka.ms/aksadvancednetworking.
	AdvancedNetworking *AdvancedNetworking_STATUS `json:"advancedNetworking,omitempty"`

	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// IpFamilies: The IP families used to specify IP versions available to the cluster. IP families are used to determine
	// single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values
	// are IPv4 and IPv6.
	IpFamilies []IPFamily_STATUS `json:"ipFamilies"`

	// KubeProxyConfig: Holds configuration customizations for kube-proxy. Any values not defined will use the kube-proxy
	// defaulting behavior. See https://v<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
	// where <version> is represented by a <major version>-<minor version> string. Kubernetes version 1.23 would be '1-23'.
	KubeProxyConfig *ContainerServiceNetworkProfileKubeProxyConfig_STATUS `json:"kubeProxyConfig,omitempty"`

	// LoadBalancerProfile: Profile of the cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_STATUS `json:"loadBalancerProfile,omitempty"`

	// LoadBalancerSku: The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer
	// SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load
	// balancer SKUs.
	LoadBalancerSku *LoadBalancerSku_STATUS `json:"loadBalancerSku,omitempty"`

	// NatGatewayProfile: Profile of the cluster NAT gateway.
	NatGatewayProfile *ManagedClusterNATGatewayProfile_STATUS `json:"natGatewayProfile,omitempty"`

	// NetworkDataplane: Network dataplane used in the Kubernetes cluster.
	NetworkDataplane *NetworkDataplane_STATUS `json:"networkDataplane,omitempty"`

	// NetworkMode: The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other
	// than 'azure'.
	NetworkMode *NetworkMode_STATUS `json:"networkMode,omitempty"`

	// NetworkPlugin: Network plugin used for building the Kubernetes network.
	NetworkPlugin *NetworkPlugin_STATUS `json:"networkPlugin,omitempty"`

	// NetworkPluginMode: The mode the network plugin should use.
	NetworkPluginMode *NetworkPluginMode_STATUS `json:"networkPluginMode,omitempty"`

	// NetworkPolicy: Network policy used for building the Kubernetes network.
	NetworkPolicy *NetworkPolicy_STATUS `json:"networkPolicy,omitempty"`

	// OutboundType: The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed
	// later. For more information see [egress outbound type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
	OutboundType *ContainerServiceNetworkProfile_OutboundType_STATUS `json:"outboundType,omitempty"`

	// PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is used.
	PodCidr *string `json:"podCidr,omitempty"`

	// PodCidrs: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack
	// networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
	PodCidrs []string `json:"podCidrs"`

	// PodLinkLocalAccess: Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods
	// with hostNetwork=false. if not specified, the default is 'IMDS'.
	PodLinkLocalAccess *PodLinkLocalAccess_STATUS `json:"podLinkLocalAccess,omitempty"`

	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// ServiceCidrs: The CIDR notation IP ranges from which to assign service cluster IPs. One IPv4 CIDR is expected for
	// single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must
	// not overlap with any Subnet IP ranges.
	ServiceCidrs []string `json:"serviceCidrs"`

	// StaticEgressGatewayProfile: The profile for Static Egress Gateway addon. For more details about Static Egress Gateway,
	// see https://aka.ms/aks/static-egress-gateway.
	StaticEgressGatewayProfile *ManagedClusterStaticEgressGatewayProfile_STATUS `json:"staticEgressGatewayProfile,omitempty"`
}

// Data used when creating a target resource from a source resource.
type CreationData_STATUS struct {
	// SourceResourceId: This is the ARM ID of the source object to be used to create the target object.
	SourceResourceId *string `json:"sourceResourceId,omitempty"`
}

// Delegated resource properties - internal use only.
type DelegatedResource_STATUS struct {
	// Location: The source resource location - internal use only.
	Location *string `json:"location,omitempty"`

	// ReferralResource: The delegation id of the referral delegation (optional) - internal use only.
	ReferralResource *string `json:"referralResource,omitempty"`

	// ResourceId: The ARM resource id of the delegated resource - internal use only.
	ResourceId *string `json:"resourceId,omitempty"`

	// TenantId: The tenant id of the delegated resource - internal use only.
	TenantId *string `json:"tenantId,omitempty"`
}

// The type of extendedLocation.
type ExtendedLocationTypes_STATUS string

const ExtendedLocationTypes_STATUS_EdgeZone = ExtendedLocationTypes_STATUS("EdgeZone")

// Mapping from string to ExtendedLocationTypes_STATUS
var extendedLocationTypes_STATUS_Values = map[string]ExtendedLocationTypes_STATUS{
	"edgezone": ExtendedLocationTypes_STATUS_EdgeZone,
}

// Different support tiers for AKS managed clusters
type KubernetesSupportPlan_STATUS string

const (
	KubernetesSupportPlan_STATUS_AKSLongTermSupport = KubernetesSupportPlan_STATUS("AKSLongTermSupport")
	KubernetesSupportPlan_STATUS_KubernetesOfficial = KubernetesSupportPlan_STATUS("KubernetesOfficial")
)

// Mapping from string to KubernetesSupportPlan_STATUS
var kubernetesSupportPlan_STATUS_Values = map[string]KubernetesSupportPlan_STATUS{
	"akslongtermsupport": KubernetesSupportPlan_STATUS_AKSLongTermSupport,
	"kubernetesofficial": KubernetesSupportPlan_STATUS_KubernetesOfficial,
}

// AADProfile specifies attributes for Azure Active Directory integration. For more details see [managed AAD on
// AKS](https://docs.microsoft.com/azure/aks/managed-aad).
type ManagedClusterAADProfile_STATUS struct {
	// AdminGroupObjectIDs: The list of AAD group object IDs that will have admin role of the cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs"`

	// ClientAppID: (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
	ClientAppID *string `json:"clientAppID,omitempty"`

	// EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	// Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	// ServerAppID: (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
	ServerAppID *string `json:"serverAppID,omitempty"`

	// ServerAppSecret: (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	// TenantID: The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment
	// subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

// A Kubernetes add-on profile for a managed cluster.
type ManagedClusterAddonProfile_STATUS struct {
	// Config: Key-value pairs for configuring an add-on.
	Config map[string]string `json:"config"`

	// Enabled: Whether the add-on is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Identity: Information of user assigned identity used by this add-on.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

// Profile for the container service agent pool.
type ManagedClusterAgentPoolProfile_STATUS struct {
	// ArtifactStreamingProfile: Configuration for using artifact streaming on AKS.
	ArtifactStreamingProfile *AgentPoolArtifactStreamingProfile_STATUS `json:"artifactStreamingProfile,omitempty"`

	// AvailabilityZones: The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType
	// property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones"`

	// CapacityReservationGroupID: The fully qualified resource ID of the Capacity Reservation Group to provide virtual
	// machines from a reserved group of Virtual Machines. This is of the form:
	// '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
	// Customers use it to create an agentpool with a specified CRG. For more information see [Capacity
	// Reservation](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview)
	CapacityReservationGroupID *string `json:"capacityReservationGroupID,omitempty"`

	// Count: Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive)
	// for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using
	// a snapshot.
	CreationData *CreationData_STATUS `json:"creationData,omitempty"`

	// CurrentOrchestratorVersion: The version of Kubernetes the Agent Pool is running. If orchestratorVersion is a fully
	// specified version <major.minor.patch>, this field will be exactly equal to it. If orchestratorVersion is <major.minor>,
	// this field will contain the full <major.minor.patch> version being used.
	CurrentOrchestratorVersion *string `json:"currentOrchestratorVersion,omitempty"`

	// ETag: Unique read-only string used to implement optimistic concurrency. The eTag value will change when the resource is
	// updated. Specify an if-match or if-none-match header with the eTag value for a subsequent request to enable optimistic
	// concurrency per the normal eTag convention.
	ETag *string `json:"eTag,omitempty"`

	// EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption. This is only supported on certain VM
	// sizes and in certain Azure regions. For more information, see:
	// https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// EnableFIPS: Whether to use a FIPS-enabled OS. See [Add a FIPS-enabled node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more
	// details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	// EnableNodePublicIP: Whether each node is allocated its own public IP. Some scenarios may require nodes in a node pool to
	// receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to
	// make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP
	// per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	// The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	// EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	// GatewayProfile: Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent pool mode is
	// not Gateway.
	GatewayProfile *AgentPoolGatewayProfile_STATUS `json:"gatewayProfile,omitempty"`

	// GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile_STATUS `json:"gpuInstanceProfile,omitempty"`

	// GpuProfile: GPU settings for the Agent Pool.
	GpuProfile *GPUProfile_STATUS `json:"gpuProfile,omitempty"`

	// HostGroupID: The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from, used only
	// in creation scenario and not allowed to changed once set. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
	// For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
	HostGroupID *string `json:"hostGroupID,omitempty"`

	// KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig *KubeletConfig_STATUS `json:"kubeletConfig,omitempty"`

	// KubeletDiskType: Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral
	// storage.
	KubeletDiskType *KubeletDiskType_STATUS `json:"kubeletDiskType,omitempty"`

	// LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig_STATUS `json:"linuxOSConfig,omitempty"`

	// LocalDNSProfile: Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve
	// performance and reliability of DNS resolution in an AKS cluster. For more details see aka.ms/aks/localdns.
	LocalDNSProfile *LocalDNSProfile_STATUS `json:"localDNSProfile,omitempty"`

	// MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	// MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	// MessageOfTheDay: Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be written to
	// /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It must not be specified
	// for Windows nodes. It must be a static string (i.e., will be printed raw and not be executed as a script).
	MessageOfTheDay *string `json:"messageOfTheDay,omitempty"`

	// MinCount: The minimum number of nodes for auto-scaling
	MinCount *int `json:"minCount,omitempty"`

	// Mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional
	// information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
	Mode *AgentPoolMode_STATUS `json:"mode,omitempty"`

	// Name: Unique name of the agent pool profile in the context of the subscription and resource group. Windows agent pool
	// names must be 6 characters or less.
	Name *string `json:"name,omitempty"`

	// NetworkProfile: Network-related settings of an agent pool.
	NetworkProfile *AgentPoolNetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// NodeCustomizationProfile: Settings to determine the node customization used to provision nodes in a pool.
	NodeCustomizationProfile *NodeCustomizationProfile_STATUS `json:"nodeCustomizationProfile,omitempty"`

	// NodeImageVersion: The version of node image
	NodeImageVersion *string `json:"nodeImageVersion,omitempty"`

	// NodeInitializationTaints: Taints added on the nodes during creation that will not be reconciled by AKS. These taints
	// will not be reconciled by AKS and can be removed with a kubectl call. This field can be modified after node pool is
	// created, but nodes will not be recreated with new taints until another operation that requires recreation (e.g. node
	// image upgrade) happens. These taints allow for required configuration to run before the node is ready to accept
	// workloads, for example 'key1=value1:NoSchedule' that then can be removed with `kubectl taint nodes node1
	// key1=value1:NoSchedule-`
	NodeInitializationTaints []string `json:"nodeInitializationTaints"`

	// NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels"`

	// NodePublicIPPrefixID: The public IP prefix ID which VM nodes should use IPs from. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixID *string `json:"nodePublicIPPrefixID,omitempty"`

	// NodeTaints: The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints"`

	// OrchestratorVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade
	// all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version
	// as the control plane. The node pool minor version must be within two minor versions of the control plane version. The
	// node pool version cannot be greater than the control plane version. For more information see [upgrading a node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`

	// OsDiskSizeGB: OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you
	// specify 0, it will apply the default osDisk size according to the vmSize specified.
	OsDiskSizeGB *int `json:"osDiskSizeGB,omitempty"`

	// OsDiskType: The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it
	// and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after
	// creation. For more information see [Ephemeral
	// OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
	OsDiskType *OSDiskType_STATUS `json:"osDiskType,omitempty"`

	// OsSKU: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019
	// when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
	OsSKU *OSSKU_STATUS `json:"osSKU,omitempty"`

	// OsType: The operating system type. The default is Linux.
	OsType *ManagedClusterAgentPoolProfile_OsType_STATUS `json:"osType,omitempty"`

	// PodIPAllocationMode: Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with
	// podSubnetId. The default is 'DynamicIndividual'.
	PodIPAllocationMode *PodIPAllocationMode_STATUS `json:"podIPAllocationMode,omitempty"`

	// PodSubnetID: The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically assigned on the
	// node subnet (see vnetSubnetID for more details). This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetID *string `json:"podSubnetID,omitempty"`

	// PowerState: Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is initially Running.
	// The Agent Pool can be stopped by setting this field to Stopped. A stopped Agent Pool stops all of its VMs and does not
	// accrue billing charges. An Agent Pool can only be stopped if it is Running and provisioning state is Succeeded
	PowerState *PowerState_STATUS `json:"powerState,omitempty"`

	// ProvisioningState: The current deployment or provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	// ScaleDownMode: The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler
	// behavior. If not specified, it defaults to Delete.
	ScaleDownMode *ScaleDownMode_STATUS `json:"scaleDownMode,omitempty"`

	// ScaleSetEvictionPolicy: The Virtual Machine Scale Set eviction policy. The eviction policy specifies what to do with the
	// VM when it is evicted. The default is Delete. For more information about eviction see [spot
	// VMs](https://docs.microsoft.com/azure/virtual-machines/spot-vms)
	ScaleSetEvictionPolicy *ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS `json:"scaleSetEvictionPolicy,omitempty"`

	// ScaleSetPriority: The Virtual Machine Scale Set priority.
	ScaleSetPriority *ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS `json:"scaleSetPriority,omitempty"`

	// SecurityProfile: The security settings of an agent pool.
	SecurityProfile *AgentPoolSecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// SpotMaxPrice: The max price (in US Dollars) you are willing to pay for spot instances. Possible values are any decimal
	// value greater than zero or -1 which indicates default price to be up-to on-demand. Possible values are any decimal value
	// greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing,
	// see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	// Status: Contains read-only information about the Agent Pool.
	Status *AgentPoolStatus_STATUS `json:"status,omitempty"`

	// Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string `json:"tags"`

	// Type: The type of Agent Pool.
	Type *AgentPoolType_STATUS `json:"type,omitempty"`

	// UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings_STATUS `json:"upgradeSettings,omitempty"`

	// UpgradeSettingsBlueGreen: Settings for Blue-Green upgrade on the agentpool. Applies when upgrade strategy is set to
	// BlueGreen.
	UpgradeSettingsBlueGreen *AgentPoolBlueGreenUpgradeSettings_STATUS `json:"upgradeSettingsBlueGreen,omitempty"`

	// UpgradeStrategy: Defines the upgrade strategy for the agent pool. The default is Rolling.
	UpgradeStrategy *UpgradeStrategy_STATUS `json:"upgradeStrategy,omitempty"`

	// VirtualMachineNodesStatus: The status of nodes in a VirtualMachines agent pool.
	VirtualMachineNodesStatus []VirtualMachineNodes_STATUS `json:"virtualMachineNodesStatus"`

	// VirtualMachinesProfile: Specifications on VirtualMachines agent pool.
	VirtualMachinesProfile *VirtualMachinesProfile_STATUS `json:"virtualMachinesProfile,omitempty"`

	// VmSize: The size of the agent pool VMs. VM size availability varies by region. If a node contains insufficient compute
	// resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see:
	// https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	// VnetSubnetID: The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this is not
	// specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods,
	// otherwise it applies to just nodes. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetID *string `json:"vnetSubnetID,omitempty"`

	// WindowsProfile: The Windows agent pool's specific profile.
	WindowsProfile *AgentPoolWindowsProfile_STATUS `json:"windowsProfile,omitempty"`

	// WorkloadRuntime: Determines the type of workload a node can run.
	WorkloadRuntime *WorkloadRuntime_STATUS `json:"workloadRuntime,omitempty"`
}

// When enabling the operator, a set of AKS managed CRDs and controllers will be installed in the cluster. The operator
// automates the deployment of OSS models for inference and/or training purposes. It provides a set of preset models and
// enables distributed inference against them.
type ManagedClusterAIToolchainOperatorProfile_STATUS struct {
	// Enabled: Whether to enable AI toolchain operator to the cluster. Indicates if AI toolchain operator  enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

// Access profile for managed cluster API server.
type ManagedClusterAPIServerAccessProfile_STATUS struct {
	// AuthorizedIPRanges: The IP ranges authorized to access the Kubernetes API server. IP ranges are specified in CIDR
	// format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters
	// that are using a Basic Load Balancer. For more information see [API server authorized IP
	// ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
	AuthorizedIPRanges []string `json:"authorizedIPRanges"`

	// DisableRunCommand: Whether to disable run command for the cluster or not.
	DisableRunCommand *bool `json:"disableRunCommand,omitempty"`

	// EnablePrivateCluster: Whether to create the cluster as a private cluster or not. For more details, see [Creating a
	// private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	// EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	// EnableVnetIntegration: Whether to enable apiserver vnet integration for the cluster or not. See
	// aka.ms/AksVnetIntegration for more details.
	EnableVnetIntegration *bool `json:"enableVnetIntegration,omitempty"`

	// PrivateDNSZone: The private DNS zone mode for the cluster. The default is System. For more details see [configure
	// private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are
	// 'system' and 'none'.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`

	// SubnetId: The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new cluster
	// with BYO Vnet, or when updating an existing cluster to enable apiserver vnet integration.
	SubnetId *string `json:"subnetId,omitempty"`
}

// Auto upgrade profile for a managed cluster.
type ManagedClusterAutoUpgradeProfile_STATUS struct {
	// NodeOSUpgradeChannel: Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
	NodeOSUpgradeChannel *NodeOSUpgradeChannel_STATUS `json:"nodeOSUpgradeChannel,omitempty"`

	// UpgradeChannel: The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS
	// cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
	UpgradeChannel *UpgradeChannel_STATUS `json:"upgradeChannel,omitempty"`
}

// Azure Monitor addon profiles for monitoring the managed cluster.
type ManagedClusterAzureMonitorProfile_STATUS struct {
	// AppMonitoring: Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics
	// and traces through auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	AppMonitoring *ManagedClusterAzureMonitorProfileAppMonitoring_STATUS `json:"appMonitoring,omitempty"`

	// ContainerInsights: Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout &
	// stderr logs etc. See aka.ms/AzureMonitorContainerInsights for an overview.
	ContainerInsights *ManagedClusterAzureMonitorProfileContainerInsights_STATUS `json:"containerInsights,omitempty"`

	// Metrics: Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes
	// infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See
	// aka.ms/AzureManagedPrometheus for an overview.
	Metrics *ManagedClusterAzureMonitorProfileMetrics_STATUS `json:"metrics,omitempty"`
}

// The bootstrap profile.
type ManagedClusterBootstrapProfile_STATUS struct {
	// ArtifactSource: The artifact source. The source where the artifacts are downloaded from.
	ArtifactSource *ManagedClusterBootstrapProfile_ArtifactSource_STATUS `json:"artifactSource,omitempty"`

	// ContainerRegistryId: The resource Id of Azure Container Registry. The registry must have private network access, premium
	// SKU and zone redundancy.
	ContainerRegistryId *string `json:"containerRegistryId,omitempty"`
}

// Settings for hosted system addons.
type ManagedClusterHostedSystemProfile_STATUS struct {
	// Enabled: Whether to enable hosted system addons for the cluster.
	Enabled *bool `json:"enabled,omitempty"`
}

// Cluster HTTP proxy configuration.
type ManagedClusterHTTPProxyConfig_STATUS struct {
	// EffectiveNoProxy: A read-only list of all endpoints for which traffic should not be sent to the proxy. This list is a
	// superset of noProxy and values injected by AKS.
	EffectiveNoProxy []string `json:"effectiveNoProxy"`

	// Enabled: Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and
	// nodes.
	Enabled *bool `json:"enabled,omitempty"`

	// HttpProxy: The HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	// HttpsProxy: The HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	// NoProxy: The endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy"`

	// TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

// Ingress profile for the container service cluster.
type ManagedClusterIngressProfile_STATUS struct {
	// ApplicationLoadBalancer: Settings for the managed Application Load Balancer installation
	ApplicationLoadBalancer *ManagedClusterIngressProfileApplicationLoadBalancer_STATUS `json:"applicationLoadBalancer,omitempty"`

	// GatewayAPI: Settings for the managed Gateway API installation
	GatewayAPI *ManagedClusterIngressProfileGatewayConfiguration_STATUS `json:"gatewayAPI,omitempty"`

	// WebAppRouting: App Routing settings for the ingress profile. You can find an overview and onboarding guide for this
	// feature at https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default.
	WebAppRouting *ManagedClusterIngressProfileWebAppRouting_STATUS `json:"webAppRouting,omitempty"`
}

// The metrics profile for the ManagedCluster.
type ManagedClusterMetricsProfile_STATUS struct {
	// CostAnalysis: The configuration for detailed per-Kubernetes resource cost analysis.
	CostAnalysis *ManagedClusterCostAnalysis_STATUS `json:"costAnalysis,omitempty"`
}

type ManagedClusterNodeProvisioningProfile_STATUS struct {
	// DefaultNodePools: The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has no
	// effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default
	// Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools. It is strongly
	// recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified,
	// the default is Auto. For more information see aka.ms/aks/nap#node-pools.
	DefaultNodePools *ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS `json:"defaultNodePools,omitempty"`

	// Mode: The node provisioning mode. If not specified, the default is Manual.
	Mode *NodeProvisioningMode_STATUS `json:"mode,omitempty"`
}

// Node resource group lockdown profile for a managed cluster.
type ManagedClusterNodeResourceGroupProfile_STATUS struct {
	// RestrictionLevel: The restriction level applied to the cluster's node resource group. If not specified, the default is
	// 'Unrestricted'
	RestrictionLevel *RestrictionLevel_STATUS `json:"restrictionLevel,omitempty"`
}

// The OIDC issuer profile of the Managed Cluster.
type ManagedClusterOIDCIssuerProfile_STATUS struct {
	// Enabled: Whether the OIDC issuer is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// IssuerURL: The OIDC issuer url of the Managed Cluster.
	IssuerURL *string `json:"issuerURL,omitempty"`
}

// The pod identity profile of the Managed Cluster. See [use AAD pod
// identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on pod identity integration.
type ManagedClusterPodIdentityProfile_STATUS struct {
	// AllowNetworkPluginKubenet: Whether pod identity is allowed to run on clusters with Kubenet networking. Running in
	// Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See
	// [using Kubenet network plugin with AAD Pod
	// Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
	// for more information.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	// Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// UserAssignedIdentities: The pod identities to use in the cluster.
	UserAssignedIdentities []ManagedClusterPodIdentity_STATUS `json:"userAssignedIdentities"`

	// UserAssignedIdentityExceptions: The pod identity exceptions to allow.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_STATUS `json:"userAssignedIdentityExceptions"`
}

// Parameters to be applied to the cluster-autoscaler when enabled
type ManagedClusterPropertiesAutoScalerProfile_STATUS struct {
	// BalanceSimilarNodeGroups: Detects similar node pools and balances the number of nodes between them. Valid values are
	// 'true' and 'false'
	BalanceSimilarNodeGroups *string `json:"balance-similar-node-groups,omitempty"`

	// DaemonsetEvictionForEmptyNodes: DaemonSet pods will be gracefully terminated from empty nodes. If set to true, all
	// daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted
	// another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods
	// are deleted or evicted.
	DaemonsetEvictionForEmptyNodes *bool `json:"daemonset-eviction-for-empty-nodes,omitempty"`

	// DaemonsetEvictionForOccupiedNodes: DaemonSet pods will be gracefully terminated from non-empty nodes. If set to true,
	// all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted
	// another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods
	// are deleted or evicted.
	DaemonsetEvictionForOccupiedNodes *bool `json:"daemonset-eviction-for-occupied-nodes,omitempty"`

	// Expander: The expander to use when scaling up. If not specified, the default is 'random'. See
	// [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more
	// information.
	Expander *Expander_STATUS `json:"expander,omitempty"`

	// IgnoreDaemonsetsUtilization: Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. If
	// set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
	IgnoreDaemonsetsUtilization *bool `json:"ignore-daemonsets-utilization,omitempty"`

	// MaxEmptyBulkDelete: The maximum number of empty nodes that can be deleted at the same time. This must be a positive
	// integer. The default is 10.
	MaxEmptyBulkDelete *string `json:"max-empty-bulk-delete,omitempty"`

	// MaxGracefulTerminationSec: The maximum number of seconds the cluster autoscaler waits for pod termination when trying to
	// scale down a node. The default is 600.
	MaxGracefulTerminationSec *string `json:"max-graceful-termination-sec,omitempty"`

	// MaxNodeProvisionTime: The maximum time the autoscaler waits for a node to be provisioned. The default is '15m'. Values
	// must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	MaxNodeProvisionTime *string `json:"max-node-provision-time,omitempty"`

	// MaxTotalUnreadyPercentage: The maximum percentage of unready nodes in the cluster. After this percentage is exceeded,
	// cluster autoscaler halts operations. The default is 45. The maximum is 100 and the minimum is 0.
	MaxTotalUnreadyPercentage *string `json:"max-total-unready-percentage,omitempty"`

	// NewPodScaleUpDelay: Ignore unscheduled pods before they're a certain age. For scenarios like burst/batch scale where you
	// don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled
	// pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds,
	// 'm' for minutes, 'h' for hours, etc).
	NewPodScaleUpDelay *string `json:"new-pod-scale-up-delay,omitempty"`

	// OkTotalUnreadyCount: The number of allowed unready nodes, irrespective of max-total-unready-percentage. This must be an
	// integer. The default is 3.
	OkTotalUnreadyCount *string `json:"ok-total-unready-count,omitempty"`

	// ScaleDownDelayAfterAdd: How long after scale up that scale down evaluation resumes. The default is '10m'. Values must be
	// an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterAdd *string `json:"scale-down-delay-after-add,omitempty"`

	// ScaleDownDelayAfterDelete: How long after node deletion that scale down evaluation resumes. The default is the
	// scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterDelete *string `json:"scale-down-delay-after-delete,omitempty"`

	// ScaleDownDelayAfterFailure: How long after scale down failure that scale down evaluation resumes. The default is '3m'.
	// Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterFailure *string `json:"scale-down-delay-after-failure,omitempty"`

	// ScaleDownUnneededTime: How long a node should be unneeded before it is eligible for scale down. The default is '10m'.
	// Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnneededTime *string `json:"scale-down-unneeded-time,omitempty"`

	// ScaleDownUnreadyTime: How long an unready node should be unneeded before it is eligible for scale down. The default is
	// '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnreadyTime *string `json:"scale-down-unready-time,omitempty"`

	// ScaleDownUtilizationThreshold: Node utilization level, defined as sum of requested resources divided by capacity, below
	// which a node can be considered for scale down. The default is '0.5'.
	ScaleDownUtilizationThreshold *string `json:"scale-down-utilization-threshold,omitempty"`

	// ScanInterval: How often cluster is reevaluated for scale up or down. The default is '10'. Values must be an integer
	// number of seconds.
	ScanInterval *string `json:"scan-interval,omitempty"`

	// SkipNodesWithLocalStorage: If cluster autoscaler will skip deleting nodes with pods with local storage, for example,
	// EmptyDir or HostPath. The default is true.
	SkipNodesWithLocalStorage *string `json:"skip-nodes-with-local-storage,omitempty"`

	// SkipNodesWithSystemPods: If cluster autoscaler will skip deleting nodes with pods from kube-system (except for DaemonSet
	// or mirror pods). The default is true.
	SkipNodesWithSystemPods *string `json:"skip-nodes-with-system-pods,omitempty"`
}

// Security profile for the container service cluster.
type ManagedClusterSecurityProfile_STATUS struct {
	// AzureKeyVaultKms: Azure Key Vault [key management
	// service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for the security profile.
	AzureKeyVaultKms *AzureKeyVaultKms_STATUS `json:"azureKeyVaultKms,omitempty"`

	// CustomCATrustCertificates: A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in
	// the cluster. For more information see [Custom CA Trust
	// Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
	CustomCATrustCertificates []string `json:"customCATrustCertificates"`

	// Defender: Microsoft Defender settings for the security profile.
	Defender *ManagedClusterSecurityProfileDefender_STATUS `json:"defender,omitempty"`

	// ImageCleaner: Image Cleaner settings for the security profile.
	ImageCleaner *ManagedClusterSecurityProfileImageCleaner_STATUS `json:"imageCleaner,omitempty"`

	// ImageIntegrity: Image integrity is a feature that works with Azure Policy to verify image integrity by signature. This
	// will not have any effect unless Azure Policy is applied to enforce image signatures. See
	// https://aka.ms/aks/image-integrity for how to use this feature via policy.
	ImageIntegrity *ManagedClusterSecurityProfileImageIntegrity_STATUS `json:"imageIntegrity,omitempty"`

	// KubernetesResourceObjectEncryptionProfile: Encryption at rest of Kubernetes resource objects. More information on this
	// can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption
	KubernetesResourceObjectEncryptionProfile *KubernetesResourceObjectEncryptionProfile_STATUS `json:"kubernetesResourceObjectEncryptionProfile,omitempty"`

	// NodeRestriction: [Node
	// Restriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) settings
	// for the security profile.
	NodeRestriction *ManagedClusterSecurityProfileNodeRestriction_STATUS `json:"nodeRestriction,omitempty"`

	// WorkloadIdentity: Workload identity settings for the security profile. Workload identity enables Kubernetes applications
	// to access Azure cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
	WorkloadIdentity *ManagedClusterSecurityProfileWorkloadIdentity_STATUS `json:"workloadIdentity,omitempty"`
}

// Information about a service principal identity for the cluster to use for manipulating Azure APIs.
type ManagedClusterServicePrincipalProfile_STATUS struct {
	// ClientId: The ID for the service principal.
	ClientId *string `json:"clientId,omitempty"`
}

// The name of a managed cluster SKU.
type ManagedClusterSKUName_STATUS string

const (
	ManagedClusterSKUName_STATUS_Automatic = ManagedClusterSKUName_STATUS("Automatic")
	ManagedClusterSKUName_STATUS_Base      = ManagedClusterSKUName_STATUS("Base")
)

// Mapping from string to ManagedClusterSKUName_STATUS
var managedClusterSKUName_STATUS_Values = map[string]ManagedClusterSKUName_STATUS{
	"automatic": ManagedClusterSKUName_STATUS_Automatic,
	"base":      ManagedClusterSKUName_STATUS_Base,
}

// The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing
// Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
type ManagedClusterSKUTier_STATUS string

const (
	ManagedClusterSKUTier_STATUS_Free     = ManagedClusterSKUTier_STATUS("Free")
	ManagedClusterSKUTier_STATUS_Premium  = ManagedClusterSKUTier_STATUS("Premium")
	ManagedClusterSKUTier_STATUS_Standard = ManagedClusterSKUTier_STATUS("Standard")
)

// Mapping from string to ManagedClusterSKUTier_STATUS
var managedClusterSKUTier_STATUS_Values = map[string]ManagedClusterSKUTier_STATUS{
	"free":     ManagedClusterSKUTier_STATUS_Free,
	"premium":  ManagedClusterSKUTier_STATUS_Premium,
	"standard": ManagedClusterSKUTier_STATUS_Standard,
}

// Contains read-only information about the Managed Cluster.
type ManagedClusterStatus_STATUS struct {
	// ProvisioningError: The error details information of the managed cluster. Preserves the detailed info of failure. If
	// there was no error, this field is omitted.
	ProvisioningError *ErrorDetail_STATUS `json:"provisioningError,omitempty"`
}

// Storage profile for the container service cluster.
type ManagedClusterStorageProfile_STATUS struct {
	// BlobCSIDriver: AzureBlob CSI Driver settings for the storage profile.
	BlobCSIDriver *ManagedClusterStorageProfileBlobCSIDriver_STATUS `json:"blobCSIDriver,omitempty"`

	// DiskCSIDriver: AzureDisk CSI Driver settings for the storage profile.
	DiskCSIDriver *ManagedClusterStorageProfileDiskCSIDriver_STATUS `json:"diskCSIDriver,omitempty"`

	// FileCSIDriver: AzureFile CSI Driver settings for the storage profile.
	FileCSIDriver *ManagedClusterStorageProfileFileCSIDriver_STATUS `json:"fileCSIDriver,omitempty"`

	// SnapshotController: Snapshot Controller settings for the storage profile.
	SnapshotController *ManagedClusterStorageProfileSnapshotController_STATUS `json:"snapshotController,omitempty"`
}

// Profile for Windows VMs in the managed cluster.
type ManagedClusterWindowsProfile_STATUS struct {
	// AdminUsername: Specifies the name of the administrator account.
	// Restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length: 1 character
	// Max-length: 20 characters
	AdminUsername *string `json:"adminUsername,omitempty"`

	// EnableCSIProxy: Whether to enable CSI proxy. For more details on CSI proxy, see the [CSI proxy GitHub
	// repo](https://github.com/kubernetes-csi/csi-proxy).
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	// GmsaProfile: The Windows gMSA Profile in the Managed Cluster.
	GmsaProfile *WindowsGmsaProfile_STATUS `json:"gmsaProfile,omitempty"`

	// LicenseType: The license type to use for Windows VMs. See [Azure Hybrid User
	// Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
	LicenseType *LicenseType_STATUS `json:"licenseType,omitempty"`
}

// Workload Auto-scaler profile for the managed cluster.
type ManagedClusterWorkloadAutoScalerProfile_STATUS struct {
	// Keda: KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
	Keda *ManagedClusterWorkloadAutoScalerProfileKeda_STATUS `json:"keda,omitempty"`

	// VerticalPodAutoscaler: VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
	VerticalPodAutoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS `json:"verticalPodAutoscaler,omitempty"`
}

type ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

// Describes the Power State of the cluster
type PowerState_STATUS struct {
	// Code: Tells whether the cluster is Running or Stopped
	Code *Code_STATUS `json:"code,omitempty"`
}

// A private link resource
type PrivateLinkResource_STATUS struct {
	// GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	// Id: The ID of the private link resource.
	Id *string `json:"id,omitempty"`

	// Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	// PrivateLinkServiceID: The private link service ID of the resource, this field is exposed only to NRP internally.
	PrivateLinkServiceID *string `json:"privateLinkServiceID,omitempty"`

	// RequiredMembers: The RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`
}

// PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
type PublicNetworkAccess_STATUS string

const (
	PublicNetworkAccess_STATUS_Disabled           = PublicNetworkAccess_STATUS("Disabled")
	PublicNetworkAccess_STATUS_Enabled            = PublicNetworkAccess_STATUS("Enabled")
	PublicNetworkAccess_STATUS_SecuredByPerimeter = PublicNetworkAccess_STATUS("SecuredByPerimeter")
)

// Mapping from string to PublicNetworkAccess_STATUS
var publicNetworkAccess_STATUS_Values = map[string]PublicNetworkAccess_STATUS{
	"disabled":           PublicNetworkAccess_STATUS_Disabled,
	"enabled":            PublicNetworkAccess_STATUS_Enabled,
	"securedbyperimeter": PublicNetworkAccess_STATUS_SecuredByPerimeter,
}

// The type of identity used for the managed cluster. For more information see [use managed identities in
// AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
type ResourceIdentityType_STATUS string

const (
	ResourceIdentityType_STATUS_None           = ResourceIdentityType_STATUS("None")
	ResourceIdentityType_STATUS_SystemAssigned = ResourceIdentityType_STATUS("SystemAssigned")
	ResourceIdentityType_STATUS_UserAssigned   = ResourceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ResourceIdentityType_STATUS
var resourceIdentityType_STATUS_Values = map[string]ResourceIdentityType_STATUS{
	"none":           ResourceIdentityType_STATUS_None,
	"systemassigned": ResourceIdentityType_STATUS_SystemAssigned,
	"userassigned":   ResourceIdentityType_STATUS_UserAssigned,
}

// The pod scheduler profile for the cluster.
type SchedulerProfile_STATUS struct {
	// SchedulerInstanceProfiles: Mapping of each scheduler instance to its profile.
	SchedulerInstanceProfiles *SchedulerProfileSchedulerInstanceProfiles_STATUS `json:"schedulerInstanceProfiles,omitempty"`
}

// Service mesh profile for a managed cluster.
type ServiceMeshProfile_STATUS struct {
	// Istio: Istio service mesh configuration.
	Istio *IstioServiceMesh_STATUS `json:"istio,omitempty"`

	// Mode: Mode of the service mesh.
	Mode *ServiceMeshMode_STATUS `json:"mode,omitempty"`
}

// Details about a user assigned identity.
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	// ResourceId: The resource ID of the user assigned identity.
	ResourceId *string `json:"resourceId,omitempty"`
}

// Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see
// aka.ms/aksadvancednetworking.
type AdvancedNetworking_STATUS struct {
	// Enabled: Indicates the enablement of Advanced Networking functionalities of observability and security on AKS clusters.
	// When this is set to true, all observability and security features will be set to enabled unless explicitly disabled. If
	// not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// Observability: Observability profile to enable advanced network metrics and flow logs with historical contexts.
	Observability *AdvancedNetworkingObservability_STATUS `json:"observability,omitempty"`

	// Performance: Profile to enable performance-enhancing features on clusters that use Azure CNI powered by Cilium.
	Performance *AdvancedNetworkingPerformance_STATUS `json:"performance,omitempty"`

	// Security: Security profile to enable security features on cilium based cluster.
	Security *AdvancedNetworkingSecurity_STATUS `json:"security,omitempty"`
}

// Azure Key Vault key management service settings for the security profile.
type AzureKeyVaultKms_STATUS struct {
	// Enabled: Whether to enable Azure Key Vault key management service. The default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// KeyId: Identifier of Azure Key Vault key. See [key identifier
	// format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
	// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
	// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
	KeyId *string `json:"keyId,omitempty"`

	// KeyVaultNetworkAccess: Network access of the key vault. Network access of key vault. The possible values are `Public`
	// and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault
	// disables public access and enables private link. The default value is `Public`.
	KeyVaultNetworkAccess *AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS `json:"keyVaultNetworkAccess,omitempty"`

	// KeyVaultResourceId: Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must
	// be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
	KeyVaultResourceId *string `json:"keyVaultResourceId,omitempty"`
}

// Tells whether the cluster is Running or Stopped
type Code_STATUS string

const (
	Code_STATUS_Running = Code_STATUS("Running")
	Code_STATUS_Stopped = Code_STATUS("Stopped")
)

// Mapping from string to Code_STATUS
var code_STATUS_Values = map[string]Code_STATUS{
	"running": Code_STATUS_Running,
	"stopped": Code_STATUS_Stopped,
}

type ContainerServiceNetworkProfile_OutboundType_STATUS string

const (
	ContainerServiceNetworkProfile_OutboundType_STATUS_LoadBalancer           = ContainerServiceNetworkProfile_OutboundType_STATUS("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_STATUS_ManagedNATGateway      = ContainerServiceNetworkProfile_OutboundType_STATUS("managedNATGateway")
	ContainerServiceNetworkProfile_OutboundType_STATUS_None                   = ContainerServiceNetworkProfile_OutboundType_STATUS("none")
	ContainerServiceNetworkProfile_OutboundType_STATUS_UserAssignedNATGateway = ContainerServiceNetworkProfile_OutboundType_STATUS("userAssignedNATGateway")
	ContainerServiceNetworkProfile_OutboundType_STATUS_UserDefinedRouting     = ContainerServiceNetworkProfile_OutboundType_STATUS("userDefinedRouting")
)

// Mapping from string to ContainerServiceNetworkProfile_OutboundType_STATUS
var containerServiceNetworkProfile_OutboundType_STATUS_Values = map[string]ContainerServiceNetworkProfile_OutboundType_STATUS{
	"loadbalancer":           ContainerServiceNetworkProfile_OutboundType_STATUS_LoadBalancer,
	"managednatgateway":      ContainerServiceNetworkProfile_OutboundType_STATUS_ManagedNATGateway,
	"none":                   ContainerServiceNetworkProfile_OutboundType_STATUS_None,
	"userassignednatgateway": ContainerServiceNetworkProfile_OutboundType_STATUS_UserAssignedNATGateway,
	"userdefinedrouting":     ContainerServiceNetworkProfile_OutboundType_STATUS_UserDefinedRouting,
}

// Holds configuration customizations for kube-proxy. Any values not defined will use the kube-proxy defaulting behavior.
// See https://v<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/ where <version> is
// represented by a <major version>-<minor version> string. Kubernetes version 1.23 would be '1-23'.
type ContainerServiceNetworkProfileKubeProxyConfig_STATUS struct {
	// Enabled: Whether to enable on kube-proxy on the cluster (if no 'kubeProxyConfig' exists, kube-proxy is enabled in AKS by
	// default without these customizations).
	Enabled *bool `json:"enabled,omitempty"`

	// IpvsConfig: Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.
	IpvsConfig *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS `json:"ipvsConfig,omitempty"`

	// Mode: Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
	Mode *Mode_STATUS `json:"mode,omitempty"`
}

// SSH configuration for Linux-based VMs running on Azure.
type ContainerServiceSshConfiguration_STATUS struct {
	// PublicKeys: The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
	PublicKeys []ContainerServiceSshPublicKey_STATUS `json:"publicKeys"`
}

// The error detail.
type ErrorDetail_STATUS struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The error details.
	Details []ErrorDetail_STATUS_Unrolled `json:"details"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

// The expander to use when scaling up. If not specified, the default is 'random'. See
// [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more
// information.
type Expander_STATUS string

const (
	Expander_STATUS_LeastWaste = Expander_STATUS("least-waste")
	Expander_STATUS_MostPods   = Expander_STATUS("most-pods")
	Expander_STATUS_Priority   = Expander_STATUS("priority")
	Expander_STATUS_Random     = Expander_STATUS("random")
)

// Mapping from string to Expander_STATUS
var expander_STATUS_Values = map[string]Expander_STATUS{
	"least-waste": Expander_STATUS_LeastWaste,
	"most-pods":   Expander_STATUS_MostPods,
	"priority":    Expander_STATUS_Priority,
	"random":      Expander_STATUS_Random,
}

// To determine if address belongs IPv4 or IPv6 family
type IPFamily_STATUS string

const (
	IPFamily_STATUS_IPv4 = IPFamily_STATUS("IPv4")
	IPFamily_STATUS_IPv6 = IPFamily_STATUS("IPv6")
)

// Mapping from string to IPFamily_STATUS
var iPFamily_STATUS_Values = map[string]IPFamily_STATUS{
	"ipv4": IPFamily_STATUS_IPv4,
	"ipv6": IPFamily_STATUS_IPv6,
}

// Istio service mesh configuration.
type IstioServiceMesh_STATUS struct {
	// CertificateAuthority: Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin
	// certificates as described here https://aka.ms/asm-plugin-ca
	CertificateAuthority *IstioCertificateAuthority_STATUS `json:"certificateAuthority,omitempty"`

	// Components: Istio components configuration.
	Components *IstioComponents_STATUS `json:"components,omitempty"`

	// Revisions: The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value.
	// When canary upgrade is in progress, this can only hold two consecutive values. For more information, see:
	// https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
	Revisions []string `json:"revisions"`
}

// Encryption at rest of Kubernetes resource objects using service-managed keys. More information on this can be found
// under https://aka.ms/aks/kubernetesResourceObjectEncryption.
type KubernetesResourceObjectEncryptionProfile_STATUS struct {
	// InfrastructureEncryption: Whether to enable encryption at rest of Kubernetes resource objects using service-managed
	// keys. More information on this can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption.
	InfrastructureEncryption *KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS `json:"infrastructureEncryption,omitempty"`
}

// The license type to use for Windows VMs. See [Azure Hybrid User
// Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
type LicenseType_STATUS string

const (
	LicenseType_STATUS_None           = LicenseType_STATUS("None")
	LicenseType_STATUS_Windows_Server = LicenseType_STATUS("Windows_Server")
)

// Mapping from string to LicenseType_STATUS
var licenseType_STATUS_Values = map[string]LicenseType_STATUS{
	"none":           LicenseType_STATUS_None,
	"windows_server": LicenseType_STATUS_Windows_Server,
}

// The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer
// SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load
// balancer SKUs.
type LoadBalancerSku_STATUS string

const (
	LoadBalancerSku_STATUS_Basic    = LoadBalancerSku_STATUS("basic")
	LoadBalancerSku_STATUS_Standard = LoadBalancerSku_STATUS("standard")
)

// Mapping from string to LoadBalancerSku_STATUS
var loadBalancerSku_STATUS_Values = map[string]LoadBalancerSku_STATUS{
	"basic":    LoadBalancerSku_STATUS_Basic,
	"standard": LoadBalancerSku_STATUS_Standard,
}

type ManagedClusterAgentPoolProfile_OsType_STATUS string

const (
	ManagedClusterAgentPoolProfile_OsType_STATUS_Linux   = ManagedClusterAgentPoolProfile_OsType_STATUS("Linux")
	ManagedClusterAgentPoolProfile_OsType_STATUS_Windows = ManagedClusterAgentPoolProfile_OsType_STATUS("Windows")
)

// Mapping from string to ManagedClusterAgentPoolProfile_OsType_STATUS
var managedClusterAgentPoolProfile_OsType_STATUS_Values = map[string]ManagedClusterAgentPoolProfile_OsType_STATUS{
	"linux":   ManagedClusterAgentPoolProfile_OsType_STATUS_Linux,
	"windows": ManagedClusterAgentPoolProfile_OsType_STATUS_Windows,
}

type ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS string

const (
	ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Deallocate = ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS("Deallocate")
	ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Delete     = ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS("Delete")
)

// Mapping from string to ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS
var managedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Values = map[string]ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS{
	"deallocate": ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Deallocate,
	"delete":     ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Delete,
}

type ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS string

const (
	ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Regular = ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS("Regular")
	ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Spot    = ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS("Spot")
)

// Mapping from string to ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS
var managedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Values = map[string]ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS{
	"regular": ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Regular,
	"spot":    ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Spot,
}

// Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics and traces
// through auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoring_STATUS struct {
	// AutoInstrumentation: Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook
	// to auto-instrument Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the
	// application. See aka.ms/AzureMonitorApplicationMonitoring for an overview.
	AutoInstrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS `json:"autoInstrumentation,omitempty"`

	// OpenTelemetryLogs: Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and
	// Traces. Collects OpenTelemetry logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	OpenTelemetryLogs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS `json:"openTelemetryLogs,omitempty"`

	// OpenTelemetryMetrics: Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container
	// Metrics. Collects OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	OpenTelemetryMetrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS `json:"openTelemetryMetrics,omitempty"`
}

// Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout & stderr logs etc. See
// aka.ms/AzureMonitorContainerInsights for an overview.
type ManagedClusterAzureMonitorProfileContainerInsights_STATUS struct {
	// DisableCustomMetrics: Indicates whether custom metrics collection has to be disabled or not. If not specified the
	// default is false. No custom metrics will be emitted if this field is false but the container insights enabled field is
	// false
	DisableCustomMetrics *bool `json:"disableCustomMetrics,omitempty"`

	// DisablePrometheusMetricsScraping: Indicates whether prometheus metrics scraping is disabled or not. If not specified the
	// default is false. No prometheus metrics will be emitted if this field is false but the container insights enabled field
	// is false
	DisablePrometheusMetricsScraping *bool `json:"disablePrometheusMetricsScraping,omitempty"`

	// Enabled: Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// LogAnalyticsWorkspaceResourceId: Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure
	// Monitor Container Insights Logs.
	LogAnalyticsWorkspaceResourceId *string `json:"logAnalyticsWorkspaceResourceId,omitempty"`

	// SyslogPort: The syslog host port. If not specified, the default port is 28330.
	SyslogPort *int `json:"syslogPort,omitempty"`
}

// Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes
// infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See
// aka.ms/AzureManagedPrometheus for an overview.
type ManagedClusterAzureMonitorProfileMetrics_STATUS struct {
	// Enabled: Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See
	// aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.
	Enabled *bool `json:"enabled,omitempty"`

	// KubeStateMetrics: Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the
	// kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for
	// details.
	KubeStateMetrics *ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS `json:"kubeStateMetrics,omitempty"`
}

type ManagedClusterBootstrapProfile_ArtifactSource_STATUS string

const (
	ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Cache  = ManagedClusterBootstrapProfile_ArtifactSource_STATUS("Cache")
	ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Direct = ManagedClusterBootstrapProfile_ArtifactSource_STATUS("Direct")
)

// Mapping from string to ManagedClusterBootstrapProfile_ArtifactSource_STATUS
var managedClusterBootstrapProfile_ArtifactSource_STATUS_Values = map[string]ManagedClusterBootstrapProfile_ArtifactSource_STATUS{
	"cache":  ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Cache,
	"direct": ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Direct,
}

// The cost analysis configuration for the cluster
type ManagedClusterCostAnalysis_STATUS struct {
	// Enabled: Whether to enable cost analysis. The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable
	// this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure
	// portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.
	Enabled *bool `json:"enabled,omitempty"`
}

// Application Load Balancer settings for the ingress profile.
type ManagedClusterIngressProfileApplicationLoadBalancer_STATUS struct {
	// Enabled: Whether to enable Application Load Balancer.
	Enabled *bool `json:"enabled,omitempty"`

	// Identity: Managed identity of the Application Load Balancer add-on. This is the identity that should be granted
	// permissions to manage the associated Application Gateway for Containers resource.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

type ManagedClusterIngressProfileGatewayConfiguration_STATUS struct {
	// Installation: Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'. See
	// https://aka.ms/k8s-gateway-api for more details.
	Installation *ManagedGatewayType_STATUS `json:"installation,omitempty"`
}

// Application Routing add-on settings for the ingress profile.
type ManagedClusterIngressProfileWebAppRouting_STATUS struct {
	// DefaultDomain: Configuration for the Default Domain. This is a unique, autogenerated domain that comes with a signed TLS
	// Certificate allowing for secure HTTPS. See [the Default Domain documentation](https://aka.ms/aks/defaultdomain) for more
	// instructions.
	DefaultDomain *ManagedClusterIngressDefaultDomainProfile_STATUS `json:"defaultDomain,omitempty"`

	// DnsZoneResourceIds: Resource IDs of the DNS zones to be associated with the Application Routing add-on. Used only when
	// Application Routing add-on is enabled. Public and private DNS zones can be in different resource groups, but all public
	// DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.
	DnsZoneResourceIds []string `json:"dnsZoneResourceIds"`

	// Enabled: Whether to enable the Application Routing add-on.
	Enabled *bool `json:"enabled,omitempty"`

	// Identity: Managed identity of the Application Routing add-on. This is the identity that should be granted permissions,
	// for example, to manage the associated Azure DNS resource and get certificates from Azure Key Vault. See [this overview
	// of the add-on](https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm) for more instructions.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`

	// Nginx: Configuration for the default NginxIngressController. See more at
	// https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller.
	Nginx *ManagedClusterIngressProfileNginx_STATUS `json:"nginx,omitempty"`
}

// Profile of the managed cluster load balancer.
type ManagedClusterLoadBalancerProfile_STATUS struct {
	// AllocatedOutboundPorts: The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000
	// (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	// BackendPoolType: The type of the managed inbound Load Balancer BackendPool.
	BackendPoolType *ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS `json:"backendPoolType,omitempty"`

	// ClusterServiceLoadBalancerHealthProbeMode: The health probing behavior for External Traffic Policy Cluster services.
	ClusterServiceLoadBalancerHealthProbeMode *ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS `json:"clusterServiceLoadBalancerHealthProbeMode,omitempty"`

	// EffectiveOutboundIPs: The effective outbound IP resources of the cluster load balancer.
	EffectiveOutboundIPs []ResourceReference_STATUS `json:"effectiveOutboundIPs"`

	// EnableMultipleStandardLoadBalancers: Enable multiple standard load balancers per AKS cluster or not.
	EnableMultipleStandardLoadBalancers *bool `json:"enableMultipleStandardLoadBalancers,omitempty"`

	// IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
	// (inclusive). The default value is 30 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS `json:"managedOutboundIPs,omitempty"`

	// OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS `json:"outboundIPPrefixes,omitempty"`

	// OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs_STATUS `json:"outboundIPs,omitempty"`
}

// Profile of the managed cluster NAT gateway.
type ManagedClusterNATGatewayProfile_STATUS struct {
	// EffectiveOutboundIPs: The effective outbound IP resources of the cluster NAT gateway.
	EffectiveOutboundIPs []ResourceReference_STATUS `json:"effectiveOutboundIPs"`

	// IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
	// (inclusive). The default value is 4 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// ManagedOutboundIPProfile: Profile of the managed outbound IP resources of the cluster NAT gateway.
	ManagedOutboundIPProfile *ManagedClusterManagedOutboundIPProfile_STATUS `json:"managedOutboundIPProfile,omitempty"`
}

type ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS string

const (
	ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Auto = ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS("Auto")
	ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_None = ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS("None")
)

// Mapping from string to ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS
var managedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Values = map[string]ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS{
	"auto": ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Auto,
	"none": ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_None,
}

// Details about the pod identity assigned to the Managed Cluster.
type ManagedClusterPodIdentity_STATUS struct {
	// BindingSelector: The binding selector to use for the AzureIdentityBinding resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// Identity: The user assigned identity details.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`

	// Name: The name of the pod identity.
	Name *string `json:"name,omitempty"`

	// Namespace: The namespace of the pod identity.
	Namespace        *string                                           `json:"namespace,omitempty"`
	ProvisioningInfo *ManagedClusterPodIdentityProvisioningInfo_STATUS `json:"provisioningInfo,omitempty"`

	// ProvisioningState: The current provisioning state of the pod identity.
	ProvisioningState *ManagedClusterPodIdentityProvisioningState_STATUS `json:"provisioningState,omitempty"`
}

// A pod identity exception, which allows pods with certain labels to access the Azure Instance Metadata Service (IMDS)
// endpoint without being intercepted by the node-managed identity (NMI) server. See [disable AAD Pod Identity for a
// specific Pod/Application](https://azure.github.io/aad-pod-identity/docs/configure/application_exception/) for more
// details.
type ManagedClusterPodIdentityException_STATUS struct {
	// Name: The name of the pod identity exception.
	Name *string `json:"name,omitempty"`

	// Namespace: The namespace of the pod identity exception.
	Namespace *string `json:"namespace,omitempty"`

	// PodLabels: The pod labels to match.
	PodLabels map[string]string `json:"podLabels"`
}

// Microsoft Defender settings for the security profile.
type ManagedClusterSecurityProfileDefender_STATUS struct {
	// LogAnalyticsWorkspaceResourceId: Resource ID of the Log Analytics workspace to be associated with Microsoft Defender.
	// When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft
	// Defender is disabled, leave the field empty.
	LogAnalyticsWorkspaceResourceId *string `json:"logAnalyticsWorkspaceResourceId,omitempty"`

	// SecurityGating: Microsoft Defender settings for security gating, validates container images eligibility for deployment
	// based on Defender for Containers security findings. Using Admission Controller, it either audits or prevents the
	// deployment of images that do not meet security standards.
	SecurityGating *ManagedClusterSecurityProfileDefenderSecurityGating_STATUS `json:"securityGating,omitempty"`

	// SecurityMonitoring: Microsoft Defender threat detection for Cloud settings for the security profile.
	SecurityMonitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS `json:"securityMonitoring,omitempty"`
}

// Image Cleaner removes unused images from nodes, freeing up disk space and helping to reduce attack surface area. Here
// are settings for the security profile.
type ManagedClusterSecurityProfileImageCleaner_STATUS struct {
	// Enabled: Whether to enable Image Cleaner on AKS cluster.
	Enabled *bool `json:"enabled,omitempty"`

	// IntervalHours: Image Cleaner scanning interval in hours.
	IntervalHours *int `json:"intervalHours,omitempty"`
}

// Image integrity related settings for the security profile.
type ManagedClusterSecurityProfileImageIntegrity_STATUS struct {
	// Enabled: Whether to enable image integrity. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

// Node Restriction settings for the security profile.
type ManagedClusterSecurityProfileNodeRestriction_STATUS struct {
	// Enabled: Whether to enable Node Restriction
	Enabled *bool `json:"enabled,omitempty"`
}

// Workload identity settings for the security profile.
type ManagedClusterSecurityProfileWorkloadIdentity_STATUS struct {
	// Enabled: Whether to enable workload identity.
	Enabled *bool `json:"enabled,omitempty"`
}

// The Static Egress Gateway addon configuration for the cluster.
type ManagedClusterStaticEgressGatewayProfile_STATUS struct {
	// Enabled: Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

// AzureBlob CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileBlobCSIDriver_STATUS struct {
	// Enabled: Whether to enable AzureBlob CSI Driver. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

// AzureDisk CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileDiskCSIDriver_STATUS struct {
	// Enabled: Whether to enable AzureDisk CSI Driver. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`

	// Version: The version of AzureDisk CSI Driver. The default value is v1.
	Version *string `json:"version,omitempty"`
}

// AzureFile CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileFileCSIDriver_STATUS struct {
	// Enabled: Whether to enable AzureFile CSI Driver. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`
}

// Snapshot Controller settings for the storage profile.
type ManagedClusterStorageProfileSnapshotController_STATUS struct {
	// Enabled: Whether to enable Snapshot Controller. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`
}

// KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
type ManagedClusterWorkloadAutoScalerProfileKeda_STATUS struct {
	// Enabled: Whether to enable KEDA.
	Enabled *bool `json:"enabled,omitempty"`
}

// VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
type ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS struct {
	// AddonAutoscaling: Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.
	AddonAutoscaling *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS `json:"addonAutoscaling,omitempty"`

	// Enabled: Whether to enable VPA. Default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

// Network dataplane used in the Kubernetes cluster.
type NetworkDataplane_STATUS string

const (
	NetworkDataplane_STATUS_Azure  = NetworkDataplane_STATUS("azure")
	NetworkDataplane_STATUS_Cilium = NetworkDataplane_STATUS("cilium")
)

// Mapping from string to NetworkDataplane_STATUS
var networkDataplane_STATUS_Values = map[string]NetworkDataplane_STATUS{
	"azure":  NetworkDataplane_STATUS_Azure,
	"cilium": NetworkDataplane_STATUS_Cilium,
}

// The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other than 'azure'.
type NetworkMode_STATUS string

const (
	NetworkMode_STATUS_Bridge      = NetworkMode_STATUS("bridge")
	NetworkMode_STATUS_Transparent = NetworkMode_STATUS("transparent")
)

// Mapping from string to NetworkMode_STATUS
var networkMode_STATUS_Values = map[string]NetworkMode_STATUS{
	"bridge":      NetworkMode_STATUS_Bridge,
	"transparent": NetworkMode_STATUS_Transparent,
}

// Network plugin used for building the Kubernetes network.
type NetworkPlugin_STATUS string

const (
	NetworkPlugin_STATUS_Azure   = NetworkPlugin_STATUS("azure")
	NetworkPlugin_STATUS_Kubenet = NetworkPlugin_STATUS("kubenet")
	NetworkPlugin_STATUS_None    = NetworkPlugin_STATUS("none")
)

// Mapping from string to NetworkPlugin_STATUS
var networkPlugin_STATUS_Values = map[string]NetworkPlugin_STATUS{
	"azure":   NetworkPlugin_STATUS_Azure,
	"kubenet": NetworkPlugin_STATUS_Kubenet,
	"none":    NetworkPlugin_STATUS_None,
}

// The mode the network plugin should use.
type NetworkPluginMode_STATUS string

const NetworkPluginMode_STATUS_Overlay = NetworkPluginMode_STATUS("overlay")

// Mapping from string to NetworkPluginMode_STATUS
var networkPluginMode_STATUS_Values = map[string]NetworkPluginMode_STATUS{
	"overlay": NetworkPluginMode_STATUS_Overlay,
}

// Network policy used for building the Kubernetes network.
type NetworkPolicy_STATUS string

const (
	NetworkPolicy_STATUS_Azure  = NetworkPolicy_STATUS("azure")
	NetworkPolicy_STATUS_Calico = NetworkPolicy_STATUS("calico")
	NetworkPolicy_STATUS_Cilium = NetworkPolicy_STATUS("cilium")
	NetworkPolicy_STATUS_None   = NetworkPolicy_STATUS("none")
)

// Mapping from string to NetworkPolicy_STATUS
var networkPolicy_STATUS_Values = map[string]NetworkPolicy_STATUS{
	"azure":  NetworkPolicy_STATUS_Azure,
	"calico": NetworkPolicy_STATUS_Calico,
	"cilium": NetworkPolicy_STATUS_Cilium,
	"none":   NetworkPolicy_STATUS_None,
}

// Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
type NodeOSUpgradeChannel_STATUS string

const (
	NodeOSUpgradeChannel_STATUS_NodeImage     = NodeOSUpgradeChannel_STATUS("NodeImage")
	NodeOSUpgradeChannel_STATUS_None          = NodeOSUpgradeChannel_STATUS("None")
	NodeOSUpgradeChannel_STATUS_SecurityPatch = NodeOSUpgradeChannel_STATUS("SecurityPatch")
	NodeOSUpgradeChannel_STATUS_Unmanaged     = NodeOSUpgradeChannel_STATUS("Unmanaged")
)

// Mapping from string to NodeOSUpgradeChannel_STATUS
var nodeOSUpgradeChannel_STATUS_Values = map[string]NodeOSUpgradeChannel_STATUS{
	"nodeimage":     NodeOSUpgradeChannel_STATUS_NodeImage,
	"none":          NodeOSUpgradeChannel_STATUS_None,
	"securitypatch": NodeOSUpgradeChannel_STATUS_SecurityPatch,
	"unmanaged":     NodeOSUpgradeChannel_STATUS_Unmanaged,
}

// The node provisioning mode. If not specified, the default is Manual.
type NodeProvisioningMode_STATUS string

const (
	NodeProvisioningMode_STATUS_Auto   = NodeProvisioningMode_STATUS("Auto")
	NodeProvisioningMode_STATUS_Manual = NodeProvisioningMode_STATUS("Manual")
)

// Mapping from string to NodeProvisioningMode_STATUS
var nodeProvisioningMode_STATUS_Values = map[string]NodeProvisioningMode_STATUS{
	"auto":   NodeProvisioningMode_STATUS_Auto,
	"manual": NodeProvisioningMode_STATUS_Manual,
}

// Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods with
// hostNetwork=false. If not specified, the default is 'IMDS'.
type PodLinkLocalAccess_STATUS string

const (
	PodLinkLocalAccess_STATUS_IMDS = PodLinkLocalAccess_STATUS("IMDS")
	PodLinkLocalAccess_STATUS_None = PodLinkLocalAccess_STATUS("None")
)

// Mapping from string to PodLinkLocalAccess_STATUS
var podLinkLocalAccess_STATUS_Values = map[string]PodLinkLocalAccess_STATUS{
	"imds": PodLinkLocalAccess_STATUS_IMDS,
	"none": PodLinkLocalAccess_STATUS_None,
}

// The restriction level applied to the cluster's node resource group. If not specified, the default is 'Unrestricted'
type RestrictionLevel_STATUS string

const (
	RestrictionLevel_STATUS_ReadOnly     = RestrictionLevel_STATUS("ReadOnly")
	RestrictionLevel_STATUS_Unrestricted = RestrictionLevel_STATUS("Unrestricted")
)

// Mapping from string to RestrictionLevel_STATUS
var restrictionLevel_STATUS_Values = map[string]RestrictionLevel_STATUS{
	"readonly":     RestrictionLevel_STATUS_ReadOnly,
	"unrestricted": RestrictionLevel_STATUS_Unrestricted,
}

// Mapping of each scheduler instance to its profile.
type SchedulerProfileSchedulerInstanceProfiles_STATUS struct {
	// Upstream: The scheduler profile for the upstream scheduler instance.
	Upstream *SchedulerInstanceProfile_STATUS `json:"upstream,omitempty"`
}

// Mode of the service mesh.
type ServiceMeshMode_STATUS string

const (
	ServiceMeshMode_STATUS_Disabled = ServiceMeshMode_STATUS("Disabled")
	ServiceMeshMode_STATUS_Istio    = ServiceMeshMode_STATUS("Istio")
)

// Mapping from string to ServiceMeshMode_STATUS
var serviceMeshMode_STATUS_Values = map[string]ServiceMeshMode_STATUS{
	"disabled": ServiceMeshMode_STATUS_Disabled,
	"istio":    ServiceMeshMode_STATUS_Istio,
}

// The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS cluster
// auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
type UpgradeChannel_STATUS string

const (
	UpgradeChannel_STATUS_NodeImage = UpgradeChannel_STATUS("node-image")
	UpgradeChannel_STATUS_None      = UpgradeChannel_STATUS("none")
	UpgradeChannel_STATUS_Patch     = UpgradeChannel_STATUS("patch")
	UpgradeChannel_STATUS_Rapid     = UpgradeChannel_STATUS("rapid")
	UpgradeChannel_STATUS_Stable    = UpgradeChannel_STATUS("stable")
)

// Mapping from string to UpgradeChannel_STATUS
var upgradeChannel_STATUS_Values = map[string]UpgradeChannel_STATUS{
	"node-image": UpgradeChannel_STATUS_NodeImage,
	"none":       UpgradeChannel_STATUS_None,
	"patch":      UpgradeChannel_STATUS_Patch,
	"rapid":      UpgradeChannel_STATUS_Rapid,
	"stable":     UpgradeChannel_STATUS_Stable,
}

// Settings for overrides when upgrading a cluster.
type UpgradeOverrideSettings_STATUS struct {
	// ForceUpgrade: Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade
	// protections such as checking for deprecated API usage. Enable this option only with caution.
	ForceUpgrade *bool `json:"forceUpgrade,omitempty"`

	// Until: Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the
	// effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set
	// by default. It must be set for the overrides to take effect.
	Until *string `json:"until,omitempty"`
}

// Windows gMSA Profile in the managed cluster.
type WindowsGmsaProfile_STATUS struct {
	// DnsServer: Specifies the DNS server for Windows gMSA.
	// Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
	DnsServer *string `json:"dnsServer,omitempty"`

	// Enabled: Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the managed cluster.
	Enabled *bool `json:"enabled,omitempty"`

	// RootDomainName: Specifies the root domain name for Windows gMSA.
	// Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
	RootDomainName *string `json:"rootDomainName,omitempty"`
}

// Observability profile to enable advanced network metrics and flow logs with historical contexts.
type AdvancedNetworkingObservability_STATUS struct {
	// Enabled: Indicates the enablement of Advanced Networking observability functionalities on clusters.
	Enabled *bool `json:"enabled,omitempty"`
}

// Profile to enable performance-enhancing features on clusters that use Azure CNI powered by Cilium.
type AdvancedNetworkingPerformance_STATUS struct {
	// AccelerationMode: Enable advanced network acceleration options. This allows users to configure acceleration using BPF
	// host routing. This can be enabled only with Cilium dataplane. If not specified, the default value is None (no
	// acceleration). The acceleration mode can be changed on a pre-existing cluster. See https://aka.ms/acnsperformance for a
	// detailed explanation
	AccelerationMode *AdvancedNetworkingPerformance_AccelerationMode_STATUS `json:"accelerationMode,omitempty"`
}

// Security profile to enable security features on cilium based cluster.
type AdvancedNetworkingSecurity_STATUS struct {
	// AdvancedNetworkPolicies: Enable advanced network policies. This allows users to configure Layer 7 network policies
	// (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see
	// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
	// specified, the default value is FQDN if security.enabled is set to true.
	AdvancedNetworkPolicies *AdvancedNetworkPolicies_STATUS `json:"advancedNetworkPolicies,omitempty"`

	// Enabled: This feature allows user to configure network policy based on DNS (FQDN) names. It can be enabled only on
	// cilium based clusters. If not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// TransitEncryption: Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium managed
	// pods will be encrypted when it leaves the node boundary.
	TransitEncryption *AdvancedNetworkingSecurityTransitEncryption_STATUS `json:"transitEncryption,omitempty"`
}

type AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS string

const (
	AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Private = AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS("Private")
	AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Public  = AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS("Public")
)

// Mapping from string to AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS
var azureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Values = map[string]AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS{
	"private": AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Private,
	"public":  AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Public,
}

// Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.
type ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS struct {
	// Scheduler: IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
	Scheduler *IpvsScheduler_STATUS `json:"scheduler,omitempty"`

	// TcpFinTimeoutSeconds: The timeout value used for IPVS TCP sessions after receiving a FIN in seconds. Must be a positive
	// integer value.
	TcpFinTimeoutSeconds *int `json:"tcpFinTimeoutSeconds,omitempty"`

	// TcpTimeoutSeconds: The timeout value used for idle IPVS TCP sessions in seconds. Must be a positive integer value.
	TcpTimeoutSeconds *int `json:"tcpTimeoutSeconds,omitempty"`

	// UdpTimeoutSeconds: The timeout value used for IPVS UDP packets in seconds. Must be a positive integer value.
	UdpTimeoutSeconds *int `json:"udpTimeoutSeconds,omitempty"`
}

// Contains information about SSH certificate public key data.
type ContainerServiceSshPublicKey_STATUS struct {
	// KeyData: Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or
	// without headers.
	KeyData *string `json:"keyData,omitempty"`
}

// The resource management error additional info.
type ErrorAdditionalInfo_STATUS struct {
	// Info: The additional info.
	Info map[string]v1.JSON `json:"info"`

	// Type: The additional info type.
	Type *string `json:"type,omitempty"`
}

type ErrorDetail_STATUS_Unrolled struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

// Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described
// here https://aka.ms/asm-plugin-ca
type IstioCertificateAuthority_STATUS struct {
	// Plugin: Plugin certificates information for Service Mesh.
	Plugin *IstioPluginCertificateAuthority_STATUS `json:"plugin,omitempty"`
}

// Istio components configuration.
type IstioComponents_STATUS struct {
	// EgressGateways: Istio egress gateways.
	EgressGateways []IstioEgressGateway_STATUS `json:"egressGateways"`

	// IngressGateways: Istio ingress gateways.
	IngressGateways []IstioIngressGateway_STATUS `json:"ingressGateways"`

	// ProxyRedirectionMechanism: Mode of traffic redirection.
	ProxyRedirectionMechanism *ProxyRedirectionMechanism_STATUS `json:"proxyRedirectionMechanism,omitempty"`
}

type KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS string

const (
	KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Disabled = KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS("Disabled")
	KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Enabled  = KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS("Enabled")
)

// Mapping from string to KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS
var kubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Values = map[string]KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS{
	"disabled": KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Disabled,
	"enabled":  KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Enabled,
}

// Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook to auto-instrument
// Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the application. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS struct {
	// Enabled: Indicates if Application Monitoring Auto Instrumentation is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and Traces. Collects
// OpenTelemetry logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS struct {
	// Enabled: Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Port: The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
	Port *int `json:"port,omitempty"`
}

// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Metrics. Collects
// OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS struct {
	// Enabled: Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Port: The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
	Port *int `json:"port,omitempty"`
}

// Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the
// kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for
// details.
type ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS struct {
	// MetricAnnotationsAllowList: Comma-separated list of Kubernetes annotation keys that will be used in the resource's
	// labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric
	// contains only resource name and namespace labels.
	MetricAnnotationsAllowList *string `json:"metricAnnotationsAllowList,omitempty"`

	// MetricLabelsAllowlist: Comma-separated list of additional Kubernetes label keys that will be used in the resource's
	// labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only
	// resource name and namespace labels.
	MetricLabelsAllowlist *string `json:"metricLabelsAllowlist,omitempty"`
}

type ManagedClusterIngressDefaultDomainProfile_STATUS struct {
	// DomainName: The unique fully qualified domain name assigned to the cluster. This will not change even if disabled then
	// reenabled.
	DomainName *string `json:"domainName,omitempty"`

	// Enabled: Whether to enable Default Domain.
	Enabled *bool `json:"enabled,omitempty"`
}

type ManagedClusterIngressProfileNginx_STATUS struct {
	// DefaultIngressControllerType: Ingress type for the default NginxIngressController custom resource
	DefaultIngressControllerType *NginxIngressControllerType_STATUS `json:"defaultIngressControllerType,omitempty"`
}

type ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS string

const (
	ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIP              = ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS("NodeIP")
	ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIPConfiguration = ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS("NodeIPConfiguration")
)

// Mapping from string to ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS
var managedClusterLoadBalancerProfile_BackendPoolType_STATUS_Values = map[string]ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS{
	"nodeip":              ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIP,
	"nodeipconfiguration": ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIPConfiguration,
}

type ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS string

const (
	ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_ServiceNodePort = ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS("ServiceNodePort")
	ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Shared          = ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS("Shared")
)

// Mapping from string to ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS
var managedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Values = map[string]ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS{
	"servicenodeport": ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_ServiceNodePort,
	"shared":          ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Shared,
}

// Desired managed outbound IPs for the cluster load balancer.
type ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS struct {
	// Count: The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values
	// must be in the range of 1 to 100 (inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`

	// CountIPv6: The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed
	// values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
	CountIPv6 *int `json:"countIPv6,omitempty"`
}

// Desired outbound IP Prefix resources for the cluster load balancer.
type ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS struct {
	// PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference_STATUS `json:"publicIPPrefixes"`
}

// Desired outbound IP resources for the cluster load balancer.
type ManagedClusterLoadBalancerProfileOutboundIPs_STATUS struct {
	// PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference_STATUS `json:"publicIPs"`
}

// Profile of the managed outbound IP resources of the managed cluster.
type ManagedClusterManagedOutboundIPProfile_STATUS struct {
	// Count: The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16
	// (inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`
}

type ManagedClusterPodIdentityProvisioningInfo_STATUS struct {
	// Error: Pod identity assignment error (if any).
	Error *ManagedClusterPodIdentityProvisioningError_STATUS `json:"error,omitempty"`
}

// The current provisioning state of the pod identity.
type ManagedClusterPodIdentityProvisioningState_STATUS string

const (
	ManagedClusterPodIdentityProvisioningState_STATUS_Assigned  = ManagedClusterPodIdentityProvisioningState_STATUS("Assigned")
	ManagedClusterPodIdentityProvisioningState_STATUS_Canceled  = ManagedClusterPodIdentityProvisioningState_STATUS("Canceled")
	ManagedClusterPodIdentityProvisioningState_STATUS_Deleting  = ManagedClusterPodIdentityProvisioningState_STATUS("Deleting")
	ManagedClusterPodIdentityProvisioningState_STATUS_Failed    = ManagedClusterPodIdentityProvisioningState_STATUS("Failed")
	ManagedClusterPodIdentityProvisioningState_STATUS_Succeeded = ManagedClusterPodIdentityProvisioningState_STATUS("Succeeded")
	ManagedClusterPodIdentityProvisioningState_STATUS_Updating  = ManagedClusterPodIdentityProvisioningState_STATUS("Updating")
)

// Mapping from string to ManagedClusterPodIdentityProvisioningState_STATUS
var managedClusterPodIdentityProvisioningState_STATUS_Values = map[string]ManagedClusterPodIdentityProvisioningState_STATUS{
	"assigned":  ManagedClusterPodIdentityProvisioningState_STATUS_Assigned,
	"canceled":  ManagedClusterPodIdentityProvisioningState_STATUS_Canceled,
	"deleting":  ManagedClusterPodIdentityProvisioningState_STATUS_Deleting,
	"failed":    ManagedClusterPodIdentityProvisioningState_STATUS_Failed,
	"succeeded": ManagedClusterPodIdentityProvisioningState_STATUS_Succeeded,
	"updating":  ManagedClusterPodIdentityProvisioningState_STATUS_Updating,
}

// Microsoft Defender settings for security gating, validates container images eligibility for deployment based on Defender
// for Containers security findings. Using Admission Controller, it either audits or prevents the deployment of images that
// do not meet security standards.
type ManagedClusterSecurityProfileDefenderSecurityGating_STATUS struct {
	// AllowSecretAccess: In use only while registry access granted by secret rather than managed identity. Set whether to
	// grant the Defender gating agent access to the cluster's secrets for pulling images from registries. If secret access is
	// denied and the registry requires pull secrets, the add-on will not perform any image validation. Default value is false.
	AllowSecretAccess *bool `json:"allowSecretAccess,omitempty"`

	// Enabled: Whether to enable Defender security gating. When enabled, the gating feature will scan container images and
	// audit or block the deployment of images that do not meet security standards according to the configured security rules.
	Enabled *bool `json:"enabled,omitempty"`

	// Identities: List of identities that the admission controller will make use of in order to pull security artifacts from
	// the registry. These are the same identities used by the cluster to pull container images. Each identity provided should
	// have federated identity credential attached to it.
	Identities []ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS `json:"identities"`
}

// Microsoft Defender settings for the security profile threat detection.
type ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS struct {
	// Enabled: Whether to enable Defender threat detection
	Enabled *bool `json:"enabled,omitempty"`
}

type ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS string

const (
	ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Disabled = ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS("Disabled")
	ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Enabled  = ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS("Enabled")
)

// Mapping from string to ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS
var managedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Values = map[string]ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS{
	"disabled": ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Disabled,
	"enabled":  ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Enabled,
}

// Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'. See
// https://aka.ms/k8s-gateway-api for more details.
type ManagedGatewayType_STATUS string

const (
	ManagedGatewayType_STATUS_Disabled = ManagedGatewayType_STATUS("Disabled")
	ManagedGatewayType_STATUS_Standard = ManagedGatewayType_STATUS("Standard")
)

// Mapping from string to ManagedGatewayType_STATUS
var managedGatewayType_STATUS_Values = map[string]ManagedGatewayType_STATUS{
	"disabled": ManagedGatewayType_STATUS_Disabled,
	"standard": ManagedGatewayType_STATUS_Standard,
}

// Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
type Mode_STATUS string

const (
	Mode_STATUS_IPTABLES = Mode_STATUS("IPTABLES")
	Mode_STATUS_IPVS     = Mode_STATUS("IPVS")
	Mode_STATUS_NFTABLES = Mode_STATUS("NFTABLES")
)

// Mapping from string to Mode_STATUS
var mode_STATUS_Values = map[string]Mode_STATUS{
	"iptables": Mode_STATUS_IPTABLES,
	"ipvs":     Mode_STATUS_IPVS,
	"nftables": Mode_STATUS_NFTABLES,
}

// A reference to an Azure resource.
type ResourceReference_STATUS struct {
	// Id: The fully qualified Azure resource id.
	Id *string `json:"id,omitempty"`
}

// The scheduler profile for a single scheduler instance.
type SchedulerInstanceProfile_STATUS struct {
	// SchedulerConfigMode: The config customization mode for this scheduler instance.
	SchedulerConfigMode *SchedulerConfigMode_STATUS `json:"schedulerConfigMode,omitempty"`
}

type AdvancedNetworkingPerformance_AccelerationMode_STATUS string

const (
	AdvancedNetworkingPerformance_AccelerationMode_STATUS_BpfVeth = AdvancedNetworkingPerformance_AccelerationMode_STATUS("BpfVeth")
	AdvancedNetworkingPerformance_AccelerationMode_STATUS_None    = AdvancedNetworkingPerformance_AccelerationMode_STATUS("None")
)

// Mapping from string to AdvancedNetworkingPerformance_AccelerationMode_STATUS
var advancedNetworkingPerformance_AccelerationMode_STATUS_Values = map[string]AdvancedNetworkingPerformance_AccelerationMode_STATUS{
	"bpfveth": AdvancedNetworkingPerformance_AccelerationMode_STATUS_BpfVeth,
	"none":    AdvancedNetworkingPerformance_AccelerationMode_STATUS_None,
}

// Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium managed pods will be
// encrypted when it leaves the node boundary.
type AdvancedNetworkingSecurityTransitEncryption_STATUS struct {
	// Type: Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified, the default
	// value is None.
	Type *TransitEncryptionType_STATUS `json:"type,omitempty"`
}

// Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies
// themselves must be configured via the Cilium Network Policy resources, see
// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
// specified, the default value is FQDN if security.enabled is set to true.
type AdvancedNetworkPolicies_STATUS string

const (
	AdvancedNetworkPolicies_STATUS_FQDN = AdvancedNetworkPolicies_STATUS("FQDN")
	AdvancedNetworkPolicies_STATUS_L7   = AdvancedNetworkPolicies_STATUS("L7")
	AdvancedNetworkPolicies_STATUS_None = AdvancedNetworkPolicies_STATUS("None")
)

// Mapping from string to AdvancedNetworkPolicies_STATUS
var advancedNetworkPolicies_STATUS_Values = map[string]AdvancedNetworkPolicies_STATUS{
	"fqdn": AdvancedNetworkPolicies_STATUS_FQDN,
	"l7":   AdvancedNetworkPolicies_STATUS_L7,
	"none": AdvancedNetworkPolicies_STATUS_None,
}

// IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
type IpvsScheduler_STATUS string

const (
	IpvsScheduler_STATUS_LeastConnection = IpvsScheduler_STATUS("LeastConnection")
	IpvsScheduler_STATUS_RoundRobin      = IpvsScheduler_STATUS("RoundRobin")
)

// Mapping from string to IpvsScheduler_STATUS
var ipvsScheduler_STATUS_Values = map[string]IpvsScheduler_STATUS{
	"leastconnection": IpvsScheduler_STATUS_LeastConnection,
	"roundrobin":      IpvsScheduler_STATUS_RoundRobin,
}

// Istio egress gateway configuration.
type IstioEgressGateway_STATUS struct {
	// Enabled: Whether to enable the egress gateway.
	Enabled *bool `json:"enabled,omitempty"`

	// GatewayConfigurationName: Name of the gateway configuration custom resource for the Istio add-on egress gateway. Must be
	// specified when enabling the Istio egress gateway. Must be deployed in the same namespace that the Istio egress gateway
	// will be deployed in.
	GatewayConfigurationName *string `json:"gatewayConfigurationName,omitempty"`

	// Name: Name of the Istio add-on egress gateway.
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace that the Istio add-on egress gateway should be deployed in. If unspecified, the default is
	// aks-istio-egress.
	Namespace *string `json:"namespace,omitempty"`
}

// Istio ingress gateway configuration. For now, we support up to one external ingress gateway named
// `aks-istio-ingressgateway-external` and one internal ingress gateway named `aks-istio-ingressgateway-internal`.
type IstioIngressGateway_STATUS struct {
	// Enabled: Whether to enable the ingress gateway.
	Enabled *bool `json:"enabled,omitempty"`

	// Mode: Mode of an ingress gateway.
	Mode *IstioIngressGatewayMode_STATUS `json:"mode,omitempty"`
}

// Plugin certificates information for Service Mesh.
type IstioPluginCertificateAuthority_STATUS struct {
	// CertChainObjectName: Certificate chain object name in Azure Key Vault.
	CertChainObjectName *string `json:"certChainObjectName,omitempty"`

	// CertObjectName: Intermediate certificate object name in Azure Key Vault.
	CertObjectName *string `json:"certObjectName,omitempty"`

	// KeyObjectName: Intermediate certificate private key object name in Azure Key Vault.
	KeyObjectName *string `json:"keyObjectName,omitempty"`

	// KeyVaultId: The resource ID of the Key Vault.
	KeyVaultId *string `json:"keyVaultId,omitempty"`

	// RootCertObjectName: Root certificate object name in Azure Key Vault.
	RootCertObjectName *string `json:"rootCertObjectName,omitempty"`
}

// An error response from the pod identity provisioning.
type ManagedClusterPodIdentityProvisioningError_STATUS struct {
	// Error: Details about the error.
	Error *ManagedClusterPodIdentityProvisioningErrorBody_STATUS `json:"error,omitempty"`
}

type ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS struct {
	// AzureContainerRegistry: The container registry for which the identity will be used; the identity specified here should
	// have a federated identity credential attached to it.
	AzureContainerRegistry *string `json:"azureContainerRegistry,omitempty"`

	// Identity: The identity object used to access the registry
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

// Ingress type for the default NginxIngressController custom resource
type NginxIngressControllerType_STATUS string

const (
	NginxIngressControllerType_STATUS_AnnotationControlled = NginxIngressControllerType_STATUS("AnnotationControlled")
	NginxIngressControllerType_STATUS_External             = NginxIngressControllerType_STATUS("External")
	NginxIngressControllerType_STATUS_Internal             = NginxIngressControllerType_STATUS("Internal")
	NginxIngressControllerType_STATUS_None                 = NginxIngressControllerType_STATUS("None")
)

// Mapping from string to NginxIngressControllerType_STATUS
var nginxIngressControllerType_STATUS_Values = map[string]NginxIngressControllerType_STATUS{
	"annotationcontrolled": NginxIngressControllerType_STATUS_AnnotationControlled,
	"external":             NginxIngressControllerType_STATUS_External,
	"internal":             NginxIngressControllerType_STATUS_Internal,
	"none":                 NginxIngressControllerType_STATUS_None,
}

// Mode of traffic redirection.
type ProxyRedirectionMechanism_STATUS string

const (
	ProxyRedirectionMechanism_STATUS_CNIChaining    = ProxyRedirectionMechanism_STATUS("CNIChaining")
	ProxyRedirectionMechanism_STATUS_InitContainers = ProxyRedirectionMechanism_STATUS("InitContainers")
)

// Mapping from string to ProxyRedirectionMechanism_STATUS
var proxyRedirectionMechanism_STATUS_Values = map[string]ProxyRedirectionMechanism_STATUS{
	"cnichaining":    ProxyRedirectionMechanism_STATUS_CNIChaining,
	"initcontainers": ProxyRedirectionMechanism_STATUS_InitContainers,
}

// The config customization mode for this scheduler instance.
type SchedulerConfigMode_STATUS string

const (
	SchedulerConfigMode_STATUS_Default      = SchedulerConfigMode_STATUS("Default")
	SchedulerConfigMode_STATUS_ManagedByCRD = SchedulerConfigMode_STATUS("ManagedByCRD")
)

// Mapping from string to SchedulerConfigMode_STATUS
var schedulerConfigMode_STATUS_Values = map[string]SchedulerConfigMode_STATUS{
	"default":      SchedulerConfigMode_STATUS_Default,
	"managedbycrd": SchedulerConfigMode_STATUS_ManagedByCRD,
}

// Mode of an ingress gateway.
type IstioIngressGatewayMode_STATUS string

const (
	IstioIngressGatewayMode_STATUS_External = IstioIngressGatewayMode_STATUS("External")
	IstioIngressGatewayMode_STATUS_Internal = IstioIngressGatewayMode_STATUS("Internal")
)

// Mapping from string to IstioIngressGatewayMode_STATUS
var istioIngressGatewayMode_STATUS_Values = map[string]IstioIngressGatewayMode_STATUS{
	"external": IstioIngressGatewayMode_STATUS_External,
	"internal": IstioIngressGatewayMode_STATUS_Internal,
}

// An error response from the pod identity provisioning.
type ManagedClusterPodIdentityProvisioningErrorBody_STATUS struct {
	// Code: An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// Details: A list of additional details about the error.
	Details []ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled `json:"details"`

	// Message: A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}

// Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified, the default value
// is None.
type TransitEncryptionType_STATUS string

const (
	TransitEncryptionType_STATUS_None      = TransitEncryptionType_STATUS("None")
	TransitEncryptionType_STATUS_WireGuard = TransitEncryptionType_STATUS("WireGuard")
)

// Mapping from string to TransitEncryptionType_STATUS
var transitEncryptionType_STATUS_Values = map[string]TransitEncryptionType_STATUS{
	"none":      TransitEncryptionType_STATUS_None,
	"wireguard": TransitEncryptionType_STATUS_WireGuard,
}

type ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled struct {
	// Code: An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// Message: A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}
