// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v20251002preview

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/containerservice/v20251002preview/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/containerservice/v20251002preview/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,containerservice}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /containerservice/resource-manager/Microsoft.ContainerService/aks/preview/2025-10-02-preview/managedClusters.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}
type ManagedCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedCluster_Spec   `json:"spec,omitempty"`
	Status            ManagedCluster_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedCluster{}

// GetConditions returns the conditions of the resource
func (cluster *ManagedCluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *ManagedCluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ conversion.Convertible = &ManagedCluster{}

// ConvertFrom populates our ManagedCluster from the provided hub ManagedCluster
func (cluster *ManagedCluster) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.ManagedCluster

	err := source.ConvertFrom(hub)
	if err != nil {
		return eris.Wrap(err, "converting from hub to source")
	}

	err = cluster.AssignProperties_From_ManagedCluster(&source)
	if err != nil {
		return eris.Wrap(err, "converting from source to cluster")
	}

	return nil
}

// ConvertTo populates the provided hub ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.ManagedCluster
	err := cluster.AssignProperties_To_ManagedCluster(&destination)
	if err != nil {
		return eris.Wrap(err, "converting to destination from cluster")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return eris.Wrap(err, "converting from destination to hub")
	}

	return nil
}

var _ configmaps.Exporter = &ManagedCluster{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (cluster *ManagedCluster) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ManagedCluster{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (cluster *ManagedCluster) SecretDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesConfigExporter = &ManagedCluster{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (cluster *ManagedCluster) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(cluster.Namespace)
	if cluster.Spec.OperatorSpec != nil && cluster.Spec.OperatorSpec.ConfigMaps != nil {
		if cluster.Status.OidcIssuerProfile != nil {
			if cluster.Status.OidcIssuerProfile.IssuerURL != nil {
				collector.AddValue(cluster.Spec.OperatorSpec.ConfigMaps.OIDCIssuerProfile, *cluster.Status.OidcIssuerProfile.IssuerURL)
			}
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &ManagedCluster{}

// AzureName returns the Azure name of the resource
func (cluster *ManagedCluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2025-10-02-preview"
func (cluster ManagedCluster) GetAPIVersion() string {
	return "2025-10-02-preview"
}

// GetResourceScope returns the scope of the resource
func (cluster *ManagedCluster) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (cluster *ManagedCluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *ManagedCluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (cluster *ManagedCluster) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/managedClusters"
func (cluster *ManagedCluster) GetType() string {
	return "Microsoft.ContainerService/managedClusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *ManagedCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedCluster_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (cluster *ManagedCluster) Owner() *genruntime.ResourceReference {
	if cluster.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return cluster.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (cluster *ManagedCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedCluster_STATUS); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedCluster_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// AssignProperties_From_ManagedCluster populates our ManagedCluster from the provided source ManagedCluster
func (cluster *ManagedCluster) AssignProperties_From_ManagedCluster(source *storage.ManagedCluster) error {

	// ObjectMeta
	cluster.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ManagedCluster_Spec
	err := spec.AssignProperties_From_ManagedCluster_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ManagedCluster_Spec() to populate field Spec")
	}
	cluster.Spec = spec

	// Status
	var status ManagedCluster_STATUS
	err = status.AssignProperties_From_ManagedCluster_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ManagedCluster_STATUS() to populate field Status")
	}
	cluster.Status = status

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster populates the provided destination ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) AssignProperties_To_ManagedCluster(destination *storage.ManagedCluster) error {

	// ObjectMeta
	destination.ObjectMeta = *cluster.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ManagedCluster_Spec
	err := cluster.Spec.AssignProperties_To_ManagedCluster_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ManagedCluster_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ManagedCluster_STATUS
	err = cluster.Status.AssignProperties_To_ManagedCluster_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ManagedCluster_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *ManagedCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion(),
		Kind:    "ManagedCluster",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /containerservice/resource-manager/Microsoft.ContainerService/aks/preview/2025-10-02-preview/managedClusters.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}
type ManagedClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedCluster `json:"items"`
}

type ManagedCluster_Spec struct {
	// AadProfile: The Azure Active Directory configuration.
	AadProfile *ManagedClusterAADProfile `json:"aadProfile,omitempty"`

	// AddonProfiles: The profile of managed cluster add-on.
	AddonProfiles map[string]ManagedClusterAddonProfile `json:"addonProfiles,omitempty"`

	// AgentPoolProfiles: The agent pool properties.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile `json:"agentPoolProfiles,omitempty"`

	// AiToolchainOperatorProfile: AI toolchain operator settings that apply to the whole cluster.
	AiToolchainOperatorProfile *ManagedClusterAIToolchainOperatorProfile `json:"aiToolchainOperatorProfile,omitempty"`

	// ApiServerAccessProfile: The access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile `json:"apiServerAccessProfile,omitempty"`

	// AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when enabled
	AutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile `json:"autoScalerProfile,omitempty"`

	// AutoUpgradeProfile: The auto upgrade configuration.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile `json:"autoUpgradeProfile,omitempty"`

	// AzureMonitorProfile: Azure Monitor addon profiles for monitoring the managed cluster.
	AzureMonitorProfile *ManagedClusterAzureMonitorProfile `json:"azureMonitorProfile,omitempty"`

	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// BootstrapProfile: Profile of the cluster bootstrap configuration.
	BootstrapProfile *ManagedClusterBootstrapProfile `json:"bootstrapProfile,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the cluster will be created/upgraded using a
	// snapshot.
	CreationData *CreationData `json:"creationData,omitempty"`

	// DisableLocalAccounts: If local accounts should be disabled on the Managed Cluster. If set to true, getting static
	// credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more
	// details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	// DiskEncryptionSetReference: The Resource ID of the disk encryption set to use for enabling encryption at rest. This is
	// of the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
	DiskEncryptionSetReference *genruntime.ResourceReference `armReference:"DiskEncryptionSetID" json:"diskEncryptionSetReference,omitempty"`

	// DnsPrefix: The DNS prefix of the Managed Cluster. This cannot be updated once the Managed Cluster has been created.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	// EnableNamespaceResources: Enable namespace as Azure resource. The default value is false. It can be enabled/disabled on
	// creation and updating of the managed cluster. See
	// [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource) for more details on Namespace as a ARM
	// Resource.
	EnableNamespaceResources *bool `json:"enableNamespaceResources,omitempty"`

	// EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// FqdnSubdomain: The FQDN subdomain of the private cluster with custom private dns zone. This cannot be updated once the
	// Managed Cluster has been created.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	// HostedSystemProfile: Settings for hosted system addons. For more information, see
	// https://aka.ms/aks/automatic/systemcomponents.
	HostedSystemProfile *ManagedClusterHostedSystemProfile `json:"hostedSystemProfile,omitempty"`

	// HttpProxyConfig: Configurations for provisioning the cluster with HTTP proxy servers.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig `json:"httpProxyConfig,omitempty"`

	// Identity: The identity of the managed cluster, if configured.
	Identity *ManagedClusterIdentity `json:"identity,omitempty"`

	// IdentityProfile: The user identity associated with the managed cluster. This identity will be used by the kubelet. Only
	// one user assigned identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId":
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
	IdentityProfile map[string]UserAssignedIdentity `json:"identityProfile,omitempty"`

	// IngressProfile: Ingress profile for the managed cluster.
	IngressProfile *ManagedClusterIngressProfile `json:"ingressProfile,omitempty"`

	// Kind: This is primarily used to expose different UI experiences in the portal for different kinds
	Kind *string `json:"kind,omitempty"`

	// KubernetesVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS
	// cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version
	// number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not
	// allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	// LinuxProfile: The profile for Linux VMs in the Managed Cluster.
	LinuxProfile *ContainerServiceLinuxProfile `json:"linuxProfile,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MetricsProfile: Optional cluster metrics configuration.
	MetricsProfile *ManagedClusterMetricsProfile `json:"metricsProfile,omitempty"`

	// NetworkProfile: The network configuration profile.
	NetworkProfile *ContainerServiceNetworkProfile `json:"networkProfile,omitempty"`

	// NodeProvisioningProfile: Node provisioning settings that apply to the whole cluster.
	NodeProvisioningProfile *ManagedClusterNodeProvisioningProfile `json:"nodeProvisioningProfile,omitempty"`

	// NodeResourceGroup: The name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	// NodeResourceGroupProfile: Profile of the node resource group configuration.
	NodeResourceGroupProfile *ManagedClusterNodeResourceGroupProfile `json:"nodeResourceGroupProfile,omitempty"`

	// OidcIssuerProfile: The OIDC issuer profile of the Managed Cluster.
	OidcIssuerProfile *ManagedClusterOIDCIssuerProfile `json:"oidcIssuerProfile,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ManagedClusterOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PodIdentityProfile: The pod identity profile of the Managed Cluster. See [use AAD pod
	// identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on AAD pod identity
	// integration.
	PodIdentityProfile *ManagedClusterPodIdentityProfile `json:"podIdentityProfile,omitempty"`

	// PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource `json:"privateLinkResources,omitempty"`

	// PublicNetworkAccess: PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// SchedulerProfile: Profile of the pod scheduler configuration.
	SchedulerProfile *SchedulerProfile `json:"schedulerProfile,omitempty"`

	// SecurityProfile: Security profile for the managed cluster.
	SecurityProfile *ManagedClusterSecurityProfile `json:"securityProfile,omitempty"`

	// ServiceMeshProfile: Service mesh profile for a managed cluster.
	ServiceMeshProfile *ServiceMeshProfile `json:"serviceMeshProfile,omitempty"`

	// ServicePrincipalProfile: Information about a service principal identity for the cluster to use for manipulating Azure
	// APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile `json:"servicePrincipalProfile,omitempty"`

	// Sku: The managed cluster SKU.
	Sku *ManagedClusterSKU `json:"sku,omitempty"`

	// StorageProfile: Storage profile for the managed cluster.
	StorageProfile *ManagedClusterStorageProfile `json:"storageProfile,omitempty"`

	// SupportPlan: The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
	SupportPlan *KubernetesSupportPlan `json:"supportPlan,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty" serializationType:"explicitEmptyCollection"`

	// UpgradeSettings: Settings for upgrading a cluster.
	UpgradeSettings *ClusterUpgradeSettings `json:"upgradeSettings,omitempty"`

	// WindowsProfile: The profile for Windows VMs in the Managed Cluster.
	WindowsProfile *ManagedClusterWindowsProfile `json:"windowsProfile,omitempty"`

	// WorkloadAutoScalerProfile: Workload Auto-scaler profile for the managed cluster.
	WorkloadAutoScalerProfile *ManagedClusterWorkloadAutoScalerProfile `json:"workloadAutoScalerProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedCluster_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cluster *ManagedCluster_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cluster == nil {
		return nil, nil
	}
	result := &arm.ManagedCluster_Spec{}

	// Set property "ExtendedLocation":
	if cluster.ExtendedLocation != nil {
		extendedLocation_ARM, err := cluster.ExtendedLocation.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*arm.ExtendedLocation)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if cluster.Identity != nil {
		identity_ARM, err := cluster.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedClusterIdentity)
		result.Identity = &identity
	}

	// Set property "Kind":
	if cluster.Kind != nil {
		kind := *cluster.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if cluster.Location != nil {
		location := *cluster.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if cluster.AadProfile != nil ||
		cluster.AddonProfiles != nil ||
		cluster.AgentPoolProfiles != nil ||
		cluster.AiToolchainOperatorProfile != nil ||
		cluster.ApiServerAccessProfile != nil ||
		cluster.AutoScalerProfile != nil ||
		cluster.AutoUpgradeProfile != nil ||
		cluster.AzureMonitorProfile != nil ||
		cluster.BootstrapProfile != nil ||
		cluster.CreationData != nil ||
		cluster.DisableLocalAccounts != nil ||
		cluster.DiskEncryptionSetReference != nil ||
		cluster.DnsPrefix != nil ||
		cluster.EnableNamespaceResources != nil ||
		cluster.EnableRBAC != nil ||
		cluster.FqdnSubdomain != nil ||
		cluster.HostedSystemProfile != nil ||
		cluster.HttpProxyConfig != nil ||
		cluster.IdentityProfile != nil ||
		cluster.IngressProfile != nil ||
		cluster.KubernetesVersion != nil ||
		cluster.LinuxProfile != nil ||
		cluster.MetricsProfile != nil ||
		cluster.NetworkProfile != nil ||
		cluster.NodeProvisioningProfile != nil ||
		cluster.NodeResourceGroup != nil ||
		cluster.NodeResourceGroupProfile != nil ||
		cluster.OidcIssuerProfile != nil ||
		cluster.PodIdentityProfile != nil ||
		cluster.PrivateLinkResources != nil ||
		cluster.PublicNetworkAccess != nil ||
		cluster.SchedulerProfile != nil ||
		cluster.SecurityProfile != nil ||
		cluster.ServiceMeshProfile != nil ||
		cluster.ServicePrincipalProfile != nil ||
		cluster.StorageProfile != nil ||
		cluster.SupportPlan != nil ||
		cluster.UpgradeSettings != nil ||
		cluster.WindowsProfile != nil ||
		cluster.WorkloadAutoScalerProfile != nil {
		result.Properties = &arm.ManagedClusterProperties{}
	}
	if cluster.AadProfile != nil {
		aadProfile_ARM, err := cluster.AadProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aadProfile := *aadProfile_ARM.(*arm.ManagedClusterAADProfile)
		result.Properties.AadProfile = &aadProfile
	}
	if cluster.AddonProfiles != nil {
		result.Properties.AddonProfiles = make(map[string]arm.ManagedClusterAddonProfile, len(cluster.AddonProfiles))
		for key, value := range cluster.AddonProfiles {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.AddonProfiles[key] = *value_ARM.(*arm.ManagedClusterAddonProfile)
		}
	}
	for _, item := range cluster.AgentPoolProfiles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AgentPoolProfiles = append(result.Properties.AgentPoolProfiles, *item_ARM.(*arm.ManagedClusterAgentPoolProfile))
	}
	if cluster.AiToolchainOperatorProfile != nil {
		aiToolchainOperatorProfile_ARM, err := cluster.AiToolchainOperatorProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aiToolchainOperatorProfile := *aiToolchainOperatorProfile_ARM.(*arm.ManagedClusterAIToolchainOperatorProfile)
		result.Properties.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
	}
	if cluster.ApiServerAccessProfile != nil {
		apiServerAccessProfile_ARM, err := cluster.ApiServerAccessProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiServerAccessProfile := *apiServerAccessProfile_ARM.(*arm.ManagedClusterAPIServerAccessProfile)
		result.Properties.ApiServerAccessProfile = &apiServerAccessProfile
	}
	if cluster.AutoScalerProfile != nil {
		autoScalerProfile_ARM, err := cluster.AutoScalerProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScalerProfile := *autoScalerProfile_ARM.(*arm.ManagedClusterPropertiesAutoScalerProfile)
		result.Properties.AutoScalerProfile = &autoScalerProfile
	}
	if cluster.AutoUpgradeProfile != nil {
		autoUpgradeProfile_ARM, err := cluster.AutoUpgradeProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoUpgradeProfile := *autoUpgradeProfile_ARM.(*arm.ManagedClusterAutoUpgradeProfile)
		result.Properties.AutoUpgradeProfile = &autoUpgradeProfile
	}
	if cluster.AzureMonitorProfile != nil {
		azureMonitorProfile_ARM, err := cluster.AzureMonitorProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureMonitorProfile := *azureMonitorProfile_ARM.(*arm.ManagedClusterAzureMonitorProfile)
		result.Properties.AzureMonitorProfile = &azureMonitorProfile
	}
	if cluster.BootstrapProfile != nil {
		bootstrapProfile_ARM, err := cluster.BootstrapProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bootstrapProfile := *bootstrapProfile_ARM.(*arm.ManagedClusterBootstrapProfile)
		result.Properties.BootstrapProfile = &bootstrapProfile
	}
	if cluster.CreationData != nil {
		creationData_ARM, err := cluster.CreationData.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		creationData := *creationData_ARM.(*arm.CreationData)
		result.Properties.CreationData = &creationData
	}
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccounts := *cluster.DisableLocalAccounts
		result.Properties.DisableLocalAccounts = &disableLocalAccounts
	}
	if cluster.DiskEncryptionSetReference != nil {
		diskEncryptionSetIDARMID, err := resolved.ResolvedReferences.Lookup(*cluster.DiskEncryptionSetReference)
		if err != nil {
			return nil, err
		}
		diskEncryptionSetID := diskEncryptionSetIDARMID
		result.Properties.DiskEncryptionSetID = &diskEncryptionSetID
	}
	if cluster.DnsPrefix != nil {
		dnsPrefix := *cluster.DnsPrefix
		result.Properties.DnsPrefix = &dnsPrefix
	}
	if cluster.EnableNamespaceResources != nil {
		enableNamespaceResources := *cluster.EnableNamespaceResources
		result.Properties.EnableNamespaceResources = &enableNamespaceResources
	}
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		result.Properties.EnableRBAC = &enableRBAC
	}
	if cluster.FqdnSubdomain != nil {
		fqdnSubdomain := *cluster.FqdnSubdomain
		result.Properties.FqdnSubdomain = &fqdnSubdomain
	}
	if cluster.HostedSystemProfile != nil {
		hostedSystemProfile_ARM, err := cluster.HostedSystemProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostedSystemProfile := *hostedSystemProfile_ARM.(*arm.ManagedClusterHostedSystemProfile)
		result.Properties.HostedSystemProfile = &hostedSystemProfile
	}
	if cluster.HttpProxyConfig != nil {
		httpProxyConfig_ARM, err := cluster.HttpProxyConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpProxyConfig := *httpProxyConfig_ARM.(*arm.ManagedClusterHTTPProxyConfig)
		result.Properties.HttpProxyConfig = &httpProxyConfig
	}
	if cluster.IdentityProfile != nil {
		result.Properties.IdentityProfile = make(map[string]arm.UserAssignedIdentity, len(cluster.IdentityProfile))
		for key, value := range cluster.IdentityProfile {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.IdentityProfile[key] = *value_ARM.(*arm.UserAssignedIdentity)
		}
	}
	if cluster.IngressProfile != nil {
		ingressProfile_ARM, err := cluster.IngressProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ingressProfile := *ingressProfile_ARM.(*arm.ManagedClusterIngressProfile)
		result.Properties.IngressProfile = &ingressProfile
	}
	if cluster.KubernetesVersion != nil {
		kubernetesVersion := *cluster.KubernetesVersion
		result.Properties.KubernetesVersion = &kubernetesVersion
	}
	if cluster.LinuxProfile != nil {
		linuxProfile_ARM, err := cluster.LinuxProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxProfile := *linuxProfile_ARM.(*arm.ContainerServiceLinuxProfile)
		result.Properties.LinuxProfile = &linuxProfile
	}
	if cluster.MetricsProfile != nil {
		metricsProfile_ARM, err := cluster.MetricsProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		metricsProfile := *metricsProfile_ARM.(*arm.ManagedClusterMetricsProfile)
		result.Properties.MetricsProfile = &metricsProfile
	}
	if cluster.NetworkProfile != nil {
		networkProfile_ARM, err := cluster.NetworkProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfile_ARM.(*arm.ContainerServiceNetworkProfile)
		result.Properties.NetworkProfile = &networkProfile
	}
	if cluster.NodeProvisioningProfile != nil {
		nodeProvisioningProfile_ARM, err := cluster.NodeProvisioningProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nodeProvisioningProfile := *nodeProvisioningProfile_ARM.(*arm.ManagedClusterNodeProvisioningProfile)
		result.Properties.NodeProvisioningProfile = &nodeProvisioningProfile
	}
	if cluster.NodeResourceGroup != nil {
		nodeResourceGroup := *cluster.NodeResourceGroup
		result.Properties.NodeResourceGroup = &nodeResourceGroup
	}
	if cluster.NodeResourceGroupProfile != nil {
		nodeResourceGroupProfile_ARM, err := cluster.NodeResourceGroupProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nodeResourceGroupProfile := *nodeResourceGroupProfile_ARM.(*arm.ManagedClusterNodeResourceGroupProfile)
		result.Properties.NodeResourceGroupProfile = &nodeResourceGroupProfile
	}
	if cluster.OidcIssuerProfile != nil {
		oidcIssuerProfile_ARM, err := cluster.OidcIssuerProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		oidcIssuerProfile := *oidcIssuerProfile_ARM.(*arm.ManagedClusterOIDCIssuerProfile)
		result.Properties.OidcIssuerProfile = &oidcIssuerProfile
	}
	if cluster.PodIdentityProfile != nil {
		podIdentityProfile_ARM, err := cluster.PodIdentityProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		podIdentityProfile := *podIdentityProfile_ARM.(*arm.ManagedClusterPodIdentityProfile)
		result.Properties.PodIdentityProfile = &podIdentityProfile
	}
	for _, item := range cluster.PrivateLinkResources {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PrivateLinkResources = append(result.Properties.PrivateLinkResources, *item_ARM.(*arm.PrivateLinkResource))
	}
	if cluster.PublicNetworkAccess != nil {
		var temp string
		temp = string(*cluster.PublicNetworkAccess)
		publicNetworkAccess := arm.PublicNetworkAccess(temp)
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if cluster.SchedulerProfile != nil {
		schedulerProfile_ARM, err := cluster.SchedulerProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedulerProfile := *schedulerProfile_ARM.(*arm.SchedulerProfile)
		result.Properties.SchedulerProfile = &schedulerProfile
	}
	if cluster.SecurityProfile != nil {
		securityProfile_ARM, err := cluster.SecurityProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfile_ARM.(*arm.ManagedClusterSecurityProfile)
		result.Properties.SecurityProfile = &securityProfile
	}
	if cluster.ServiceMeshProfile != nil {
		serviceMeshProfile_ARM, err := cluster.ServiceMeshProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serviceMeshProfile := *serviceMeshProfile_ARM.(*arm.ServiceMeshProfile)
		result.Properties.ServiceMeshProfile = &serviceMeshProfile
	}
	if cluster.ServicePrincipalProfile != nil {
		servicePrincipalProfile_ARM, err := cluster.ServicePrincipalProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipalProfile := *servicePrincipalProfile_ARM.(*arm.ManagedClusterServicePrincipalProfile)
		result.Properties.ServicePrincipalProfile = &servicePrincipalProfile
	}
	if cluster.StorageProfile != nil {
		storageProfile_ARM, err := cluster.StorageProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*arm.ManagedClusterStorageProfile)
		result.Properties.StorageProfile = &storageProfile
	}
	if cluster.SupportPlan != nil {
		var temp string
		temp = string(*cluster.SupportPlan)
		supportPlan := arm.KubernetesSupportPlan(temp)
		result.Properties.SupportPlan = &supportPlan
	}
	if cluster.UpgradeSettings != nil {
		upgradeSettings_ARM, err := cluster.UpgradeSettings.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradeSettings := *upgradeSettings_ARM.(*arm.ClusterUpgradeSettings)
		result.Properties.UpgradeSettings = &upgradeSettings
	}
	if cluster.WindowsProfile != nil {
		windowsProfile_ARM, err := cluster.WindowsProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsProfile := *windowsProfile_ARM.(*arm.ManagedClusterWindowsProfile)
		result.Properties.WindowsProfile = &windowsProfile
	}
	if cluster.WorkloadAutoScalerProfile != nil {
		workloadAutoScalerProfile_ARM, err := cluster.WorkloadAutoScalerProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		workloadAutoScalerProfile := *workloadAutoScalerProfile_ARM.(*arm.ManagedClusterWorkloadAutoScalerProfile)
		result.Properties.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
	}

	// Set property "Sku":
	if cluster.Sku != nil {
		sku_ARM, err := cluster.Sku.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.ManagedClusterSKU)
		result.Sku = &sku
	}

	// Set property "Tags":
	if cluster.Tags != nil {
		result.Tags = make(map[string]string, len(cluster.Tags))
		for key, value := range cluster.Tags {
			result.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.Tags = make(map[string]string)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ManagedCluster_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedCluster_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ManagedCluster_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedCluster_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedCluster_Spec, got %T", armInput)
	}

	// Set property "AadProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			cluster.AadProfile = &aadProfile
		}
	}

	// Set property "AddonProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			cluster.AddonProfiles = make(map[string]ManagedClusterAddonProfile, len(typedInput.Properties.AddonProfiles))
			for key, value := range typedInput.Properties.AddonProfiles {
				var value1 ManagedClusterAddonProfile
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.AddonProfiles[key] = value1
			}
		}
	}

	// Set property "AgentPoolProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AgentPoolProfiles = append(cluster.AgentPoolProfiles, item1)
		}
	}

	// Set property "AiToolchainOperatorProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AiToolchainOperatorProfile != nil {
			var aiToolchainOperatorProfile1 ManagedClusterAIToolchainOperatorProfile
			err := aiToolchainOperatorProfile1.PopulateFromARM(owner, *typedInput.Properties.AiToolchainOperatorProfile)
			if err != nil {
				return err
			}
			aiToolchainOperatorProfile := aiToolchainOperatorProfile1
			cluster.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
		}
	}

	// Set property "ApiServerAccessProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			cluster.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property "AutoScalerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterPropertiesAutoScalerProfile
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			cluster.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property "AutoUpgradeProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			cluster.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property "AzureMonitorProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzureMonitorProfile != nil {
			var azureMonitorProfile1 ManagedClusterAzureMonitorProfile
			err := azureMonitorProfile1.PopulateFromARM(owner, *typedInput.Properties.AzureMonitorProfile)
			if err != nil {
				return err
			}
			azureMonitorProfile := azureMonitorProfile1
			cluster.AzureMonitorProfile = &azureMonitorProfile
		}
	}

	// Set property "AzureName":
	cluster.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "BootstrapProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BootstrapProfile != nil {
			var bootstrapProfile1 ManagedClusterBootstrapProfile
			err := bootstrapProfile1.PopulateFromARM(owner, *typedInput.Properties.BootstrapProfile)
			if err != nil {
				return err
			}
			bootstrapProfile := bootstrapProfile1
			cluster.BootstrapProfile = &bootstrapProfile
		}
	}

	// Set property "CreationData":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreationData != nil {
			var creationData1 CreationData
			err := creationData1.PopulateFromARM(owner, *typedInput.Properties.CreationData)
			if err != nil {
				return err
			}
			creationData := creationData1
			cluster.CreationData = &creationData
		}
	}

	// Set property "DisableLocalAccounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			cluster.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// no assignment for property "DiskEncryptionSetReference"

	// Set property "DnsPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			cluster.DnsPrefix = &dnsPrefix
		}
	}

	// Set property "EnableNamespaceResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableNamespaceResources != nil {
			enableNamespaceResources := *typedInput.Properties.EnableNamespaceResources
			cluster.EnableNamespaceResources = &enableNamespaceResources
		}
	}

	// Set property "EnableRBAC":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			cluster.EnableRBAC = &enableRBAC
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		cluster.ExtendedLocation = &extendedLocation
	}

	// Set property "FqdnSubdomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			cluster.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property "HostedSystemProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostedSystemProfile != nil {
			var hostedSystemProfile1 ManagedClusterHostedSystemProfile
			err := hostedSystemProfile1.PopulateFromARM(owner, *typedInput.Properties.HostedSystemProfile)
			if err != nil {
				return err
			}
			hostedSystemProfile := hostedSystemProfile1
			cluster.HostedSystemProfile = &hostedSystemProfile
		}
	}

	// Set property "HttpProxyConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			cluster.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "IdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			cluster.IdentityProfile = make(map[string]UserAssignedIdentity, len(typedInput.Properties.IdentityProfile))
			for key, value := range typedInput.Properties.IdentityProfile {
				var value1 UserAssignedIdentity
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.IdentityProfile[key] = value1
			}
		}
	}

	// Set property "IngressProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IngressProfile != nil {
			var ingressProfile1 ManagedClusterIngressProfile
			err := ingressProfile1.PopulateFromARM(owner, *typedInput.Properties.IngressProfile)
			if err != nil {
				return err
			}
			ingressProfile := ingressProfile1
			cluster.IngressProfile = &ingressProfile
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		cluster.Kind = &kind
	}

	// Set property "KubernetesVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			cluster.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property "LinuxProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			cluster.LinuxProfile = &linuxProfile
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property "MetricsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MetricsProfile != nil {
			var metricsProfile1 ManagedClusterMetricsProfile
			err := metricsProfile1.PopulateFromARM(owner, *typedInput.Properties.MetricsProfile)
			if err != nil {
				return err
			}
			metricsProfile := metricsProfile1
			cluster.MetricsProfile = &metricsProfile
		}
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			cluster.NetworkProfile = &networkProfile
		}
	}

	// Set property "NodeProvisioningProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeProvisioningProfile != nil {
			var nodeProvisioningProfile1 ManagedClusterNodeProvisioningProfile
			err := nodeProvisioningProfile1.PopulateFromARM(owner, *typedInput.Properties.NodeProvisioningProfile)
			if err != nil {
				return err
			}
			nodeProvisioningProfile := nodeProvisioningProfile1
			cluster.NodeProvisioningProfile = &nodeProvisioningProfile
		}
	}

	// Set property "NodeResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			cluster.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// Set property "NodeResourceGroupProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroupProfile != nil {
			var nodeResourceGroupProfile1 ManagedClusterNodeResourceGroupProfile
			err := nodeResourceGroupProfile1.PopulateFromARM(owner, *typedInput.Properties.NodeResourceGroupProfile)
			if err != nil {
				return err
			}
			nodeResourceGroupProfile := nodeResourceGroupProfile1
			cluster.NodeResourceGroupProfile = &nodeResourceGroupProfile
		}
	}

	// Set property "OidcIssuerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OidcIssuerProfile != nil {
			var oidcIssuerProfile1 ManagedClusterOIDCIssuerProfile
			err := oidcIssuerProfile1.PopulateFromARM(owner, *typedInput.Properties.OidcIssuerProfile)
			if err != nil {
				return err
			}
			oidcIssuerProfile := oidcIssuerProfile1
			cluster.OidcIssuerProfile = &oidcIssuerProfile
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	cluster.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PodIdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			cluster.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property "PrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.PrivateLinkResources = append(cluster.PrivateLinkResources, item1)
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := PublicNetworkAccess(temp)
			cluster.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "SchedulerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SchedulerProfile != nil {
			var schedulerProfile1 SchedulerProfile
			err := schedulerProfile1.PopulateFromARM(owner, *typedInput.Properties.SchedulerProfile)
			if err != nil {
				return err
			}
			schedulerProfile := schedulerProfile1
			cluster.SchedulerProfile = &schedulerProfile
		}
	}

	// Set property "SecurityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 ManagedClusterSecurityProfile
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			cluster.SecurityProfile = &securityProfile
		}
	}

	// Set property "ServiceMeshProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceMeshProfile != nil {
			var serviceMeshProfile1 ServiceMeshProfile
			err := serviceMeshProfile1.PopulateFromARM(owner, *typedInput.Properties.ServiceMeshProfile)
			if err != nil {
				return err
			}
			serviceMeshProfile := serviceMeshProfile1
			cluster.ServiceMeshProfile = &serviceMeshProfile
		}
	}

	// Set property "ServicePrincipalProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			cluster.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property "StorageProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 ManagedClusterStorageProfile
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			cluster.StorageProfile = &storageProfile
		}
	}

	// Set property "SupportPlan":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SupportPlan != nil {
			var temp string
			temp = string(*typedInput.Properties.SupportPlan)
			supportPlan := KubernetesSupportPlan(temp)
			cluster.SupportPlan = &supportPlan
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		cluster.Tags = make(map[string]string)
	}

	// Set property "UpgradeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradeSettings != nil {
			var upgradeSettings1 ClusterUpgradeSettings
			err := upgradeSettings1.PopulateFromARM(owner, *typedInput.Properties.UpgradeSettings)
			if err != nil {
				return err
			}
			upgradeSettings := upgradeSettings1
			cluster.UpgradeSettings = &upgradeSettings
		}
	}

	// Set property "WindowsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			cluster.WindowsProfile = &windowsProfile
		}
	}

	// Set property "WorkloadAutoScalerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkloadAutoScalerProfile != nil {
			var workloadAutoScalerProfile1 ManagedClusterWorkloadAutoScalerProfile
			err := workloadAutoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.WorkloadAutoScalerProfile)
			if err != nil {
				return err
			}
			workloadAutoScalerProfile := workloadAutoScalerProfile1
			cluster.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ManagedCluster_Spec{}

// ConvertSpecFrom populates our ManagedCluster_Spec from the provided source
func (cluster *ManagedCluster_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ManagedCluster_Spec)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_ManagedCluster_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ManagedCluster_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_ManagedCluster_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ManagedCluster_Spec)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_ManagedCluster_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ManagedCluster_Spec{}
	err := cluster.AssignProperties_To_ManagedCluster_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ManagedCluster_Spec populates our ManagedCluster_Spec from the provided source ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) AssignProperties_From_ManagedCluster_Spec(source *storage.ManagedCluster_Spec) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile
		err := aadProfile.AssignProperties_From_ManagedClusterAADProfile(source.AadProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAADProfile() to populate field AadProfile")
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfileMap := make(map[string]ManagedClusterAddonProfile, len(source.AddonProfiles))
		for addonProfileKey, addonProfileValue := range source.AddonProfiles {
			var addonProfile ManagedClusterAddonProfile
			err := addonProfile.AssignProperties_From_ManagedClusterAddonProfile(&addonProfileValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAddonProfile() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		cluster.AddonProfiles = addonProfileMap
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			var agentPoolProfile ManagedClusterAgentPoolProfile
			err := agentPoolProfile.AssignProperties_From_ManagedClusterAgentPoolProfile(&agentPoolProfileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// AiToolchainOperatorProfile
	if source.AiToolchainOperatorProfile != nil {
		var aiToolchainOperatorProfile ManagedClusterAIToolchainOperatorProfile
		err := aiToolchainOperatorProfile.AssignProperties_From_ManagedClusterAIToolchainOperatorProfile(source.AiToolchainOperatorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAIToolchainOperatorProfile() to populate field AiToolchainOperatorProfile")
		}
		cluster.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
	} else {
		cluster.AiToolchainOperatorProfile = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile
		err := apiServerAccessProfile.AssignProperties_From_ManagedClusterAPIServerAccessProfile(source.ApiServerAccessProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterPropertiesAutoScalerProfile
		err := autoScalerProfile.AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile() to populate field AutoScalerProfile")
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile
		err := autoUpgradeProfile.AssignProperties_From_ManagedClusterAutoUpgradeProfile(source.AutoUpgradeProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzureMonitorProfile
	if source.AzureMonitorProfile != nil {
		var azureMonitorProfile ManagedClusterAzureMonitorProfile
		err := azureMonitorProfile.AssignProperties_From_ManagedClusterAzureMonitorProfile(source.AzureMonitorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfile() to populate field AzureMonitorProfile")
		}
		cluster.AzureMonitorProfile = &azureMonitorProfile
	} else {
		cluster.AzureMonitorProfile = nil
	}

	// AzureName
	cluster.AzureName = source.AzureName

	// BootstrapProfile
	if source.BootstrapProfile != nil {
		var bootstrapProfile ManagedClusterBootstrapProfile
		err := bootstrapProfile.AssignProperties_From_ManagedClusterBootstrapProfile(source.BootstrapProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterBootstrapProfile() to populate field BootstrapProfile")
		}
		cluster.BootstrapProfile = &bootstrapProfile
	} else {
		cluster.BootstrapProfile = nil
	}

	// CreationData
	if source.CreationData != nil {
		var creationDatum CreationData
		err := creationDatum.AssignProperties_From_CreationData(source.CreationData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CreationData() to populate field CreationData")
		}
		cluster.CreationData = &creationDatum
	} else {
		cluster.CreationData = nil
	}

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetReference
	if source.DiskEncryptionSetReference != nil {
		diskEncryptionSetReference := source.DiskEncryptionSetReference.Copy()
		cluster.DiskEncryptionSetReference = &diskEncryptionSetReference
	} else {
		cluster.DiskEncryptionSetReference = nil
	}

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnableNamespaceResources
	if source.EnableNamespaceResources != nil {
		enableNamespaceResource := *source.EnableNamespaceResources
		cluster.EnableNamespaceResources = &enableNamespaceResource
	} else {
		cluster.EnableNamespaceResources = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HostedSystemProfile
	if source.HostedSystemProfile != nil {
		var hostedSystemProfile ManagedClusterHostedSystemProfile
		err := hostedSystemProfile.AssignProperties_From_ManagedClusterHostedSystemProfile(source.HostedSystemProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterHostedSystemProfile() to populate field HostedSystemProfile")
		}
		cluster.HostedSystemProfile = &hostedSystemProfile
	} else {
		cluster.HostedSystemProfile = nil
	}

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig
		err := httpProxyConfig.AssignProperties_From_ManagedClusterHTTPProxyConfig(source.HttpProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity
		err := identity.AssignProperties_From_ManagedClusterIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfileMap := make(map[string]UserAssignedIdentity, len(source.IdentityProfile))
		for identityProfileKey, identityProfileValue := range source.IdentityProfile {
			var identityProfile UserAssignedIdentity
			err := identityProfile.AssignProperties_From_UserAssignedIdentity(&identityProfileValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		cluster.IdentityProfile = identityProfileMap
	} else {
		cluster.IdentityProfile = nil
	}

	// IngressProfile
	if source.IngressProfile != nil {
		var ingressProfile ManagedClusterIngressProfile
		err := ingressProfile.AssignProperties_From_ManagedClusterIngressProfile(source.IngressProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfile() to populate field IngressProfile")
		}
		cluster.IngressProfile = &ingressProfile
	} else {
		cluster.IngressProfile = nil
	}

	// Kind
	cluster.Kind = genruntime.ClonePointerToString(source.Kind)

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile
		err := linuxProfile.AssignProperties_From_ContainerServiceLinuxProfile(source.LinuxProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// MetricsProfile
	if source.MetricsProfile != nil {
		var metricsProfile ManagedClusterMetricsProfile
		err := metricsProfile.AssignProperties_From_ManagedClusterMetricsProfile(source.MetricsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterMetricsProfile() to populate field MetricsProfile")
		}
		cluster.MetricsProfile = &metricsProfile
	} else {
		cluster.MetricsProfile = nil
	}

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile
		err := networkProfile.AssignProperties_From_ContainerServiceNetworkProfile(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeProvisioningProfile
	if source.NodeProvisioningProfile != nil {
		var nodeProvisioningProfile ManagedClusterNodeProvisioningProfile
		err := nodeProvisioningProfile.AssignProperties_From_ManagedClusterNodeProvisioningProfile(source.NodeProvisioningProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterNodeProvisioningProfile() to populate field NodeProvisioningProfile")
		}
		cluster.NodeProvisioningProfile = &nodeProvisioningProfile
	} else {
		cluster.NodeProvisioningProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// NodeResourceGroupProfile
	if source.NodeResourceGroupProfile != nil {
		var nodeResourceGroupProfile ManagedClusterNodeResourceGroupProfile
		err := nodeResourceGroupProfile.AssignProperties_From_ManagedClusterNodeResourceGroupProfile(source.NodeResourceGroupProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterNodeResourceGroupProfile() to populate field NodeResourceGroupProfile")
		}
		cluster.NodeResourceGroupProfile = &nodeResourceGroupProfile
	} else {
		cluster.NodeResourceGroupProfile = nil
	}

	// OidcIssuerProfile
	if source.OidcIssuerProfile != nil {
		var oidcIssuerProfile ManagedClusterOIDCIssuerProfile
		err := oidcIssuerProfile.AssignProperties_From_ManagedClusterOIDCIssuerProfile(source.OidcIssuerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterOIDCIssuerProfile() to populate field OidcIssuerProfile")
		}
		cluster.OidcIssuerProfile = &oidcIssuerProfile
	} else {
		cluster.OidcIssuerProfile = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ManagedClusterOperatorSpec
		err := operatorSpec.AssignProperties_From_ManagedClusterOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		cluster.OperatorSpec = &operatorSpec
	} else {
		cluster.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		cluster.Owner = &owner
	} else {
		cluster.Owner = nil
	}

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile
		err := podIdentityProfile.AssignProperties_From_ManagedClusterPodIdentityProfile(source.PodIdentityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			var privateLinkResource PrivateLinkResource
			err := privateLinkResource.AssignProperties_From_PrivateLinkResource(&privateLinkResourceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, publicNetworkAccess_Values)
		cluster.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		cluster.PublicNetworkAccess = nil
	}

	// SchedulerProfile
	if source.SchedulerProfile != nil {
		var schedulerProfile SchedulerProfile
		err := schedulerProfile.AssignProperties_From_SchedulerProfile(source.SchedulerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SchedulerProfile() to populate field SchedulerProfile")
		}
		cluster.SchedulerProfile = &schedulerProfile
	} else {
		cluster.SchedulerProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile ManagedClusterSecurityProfile
		err := securityProfile.AssignProperties_From_ManagedClusterSecurityProfile(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfile() to populate field SecurityProfile")
		}
		cluster.SecurityProfile = &securityProfile
	} else {
		cluster.SecurityProfile = nil
	}

	// ServiceMeshProfile
	if source.ServiceMeshProfile != nil {
		var serviceMeshProfile ServiceMeshProfile
		err := serviceMeshProfile.AssignProperties_From_ServiceMeshProfile(source.ServiceMeshProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ServiceMeshProfile() to populate field ServiceMeshProfile")
		}
		cluster.ServiceMeshProfile = &serviceMeshProfile
	} else {
		cluster.ServiceMeshProfile = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile
		err := servicePrincipalProfile.AssignProperties_From_ManagedClusterServicePrincipalProfile(source.ServicePrincipalProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU
		err := sku.AssignProperties_From_ManagedClusterSKU(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSKU() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile ManagedClusterStorageProfile
		err := storageProfile.AssignProperties_From_ManagedClusterStorageProfile(source.StorageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfile() to populate field StorageProfile")
		}
		cluster.StorageProfile = &storageProfile
	} else {
		cluster.StorageProfile = nil
	}

	// SupportPlan
	if source.SupportPlan != nil {
		supportPlan := *source.SupportPlan
		supportPlanTemp := genruntime.ToEnum(supportPlan, kubernetesSupportPlan_Values)
		cluster.SupportPlan = &supportPlanTemp
	} else {
		cluster.SupportPlan = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting ClusterUpgradeSettings
		err := upgradeSetting.AssignProperties_From_ClusterUpgradeSettings(source.UpgradeSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterUpgradeSettings() to populate field UpgradeSettings")
		}
		cluster.UpgradeSettings = &upgradeSetting
	} else {
		cluster.UpgradeSettings = nil
	}

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile
		err := windowsProfile.AssignProperties_From_ManagedClusterWindowsProfile(source.WindowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// WorkloadAutoScalerProfile
	if source.WorkloadAutoScalerProfile != nil {
		var workloadAutoScalerProfile ManagedClusterWorkloadAutoScalerProfile
		err := workloadAutoScalerProfile.AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile(source.WorkloadAutoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile() to populate field WorkloadAutoScalerProfile")
		}
		cluster.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
	} else {
		cluster.WorkloadAutoScalerProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster_Spec populates the provided destination ManagedCluster_Spec from our ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) AssignProperties_To_ManagedCluster_Spec(destination *storage.ManagedCluster_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile storage.ManagedClusterAADProfile
		err := cluster.AadProfile.AssignProperties_To_ManagedClusterAADProfile(&aadProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAADProfile() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfileMap := make(map[string]storage.ManagedClusterAddonProfile, len(cluster.AddonProfiles))
		for addonProfileKey, addonProfileValue := range cluster.AddonProfiles {
			var addonProfile storage.ManagedClusterAddonProfile
			err := addonProfileValue.AssignProperties_To_ManagedClusterAddonProfile(&addonProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAddonProfile() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		destination.AddonProfiles = addonProfileMap
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]storage.ManagedClusterAgentPoolProfile, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			var agentPoolProfile storage.ManagedClusterAgentPoolProfile
			err := agentPoolProfileItem.AssignProperties_To_ManagedClusterAgentPoolProfile(&agentPoolProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// AiToolchainOperatorProfile
	if cluster.AiToolchainOperatorProfile != nil {
		var aiToolchainOperatorProfile storage.ManagedClusterAIToolchainOperatorProfile
		err := cluster.AiToolchainOperatorProfile.AssignProperties_To_ManagedClusterAIToolchainOperatorProfile(&aiToolchainOperatorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAIToolchainOperatorProfile() to populate field AiToolchainOperatorProfile")
		}
		destination.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
	} else {
		destination.AiToolchainOperatorProfile = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile storage.ManagedClusterAPIServerAccessProfile
		err := cluster.ApiServerAccessProfile.AssignProperties_To_ManagedClusterAPIServerAccessProfile(&apiServerAccessProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
		var autoScalerProfile storage.ManagedClusterPropertiesAutoScalerProfile
		err := cluster.AutoScalerProfile.AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile storage.ManagedClusterAutoUpgradeProfile
		err := cluster.AutoUpgradeProfile.AssignProperties_To_ManagedClusterAutoUpgradeProfile(&autoUpgradeProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureMonitorProfile
	if cluster.AzureMonitorProfile != nil {
		var azureMonitorProfile storage.ManagedClusterAzureMonitorProfile
		err := cluster.AzureMonitorProfile.AssignProperties_To_ManagedClusterAzureMonitorProfile(&azureMonitorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfile() to populate field AzureMonitorProfile")
		}
		destination.AzureMonitorProfile = &azureMonitorProfile
	} else {
		destination.AzureMonitorProfile = nil
	}

	// AzureName
	destination.AzureName = cluster.AzureName

	// BootstrapProfile
	if cluster.BootstrapProfile != nil {
		var bootstrapProfile storage.ManagedClusterBootstrapProfile
		err := cluster.BootstrapProfile.AssignProperties_To_ManagedClusterBootstrapProfile(&bootstrapProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterBootstrapProfile() to populate field BootstrapProfile")
		}
		destination.BootstrapProfile = &bootstrapProfile
	} else {
		destination.BootstrapProfile = nil
	}

	// CreationData
	if cluster.CreationData != nil {
		var creationDatum storage.CreationData
		err := cluster.CreationData.AssignProperties_To_CreationData(&creationDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CreationData() to populate field CreationData")
		}
		destination.CreationData = &creationDatum
	} else {
		destination.CreationData = nil
	}

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetReference
	if cluster.DiskEncryptionSetReference != nil {
		diskEncryptionSetReference := cluster.DiskEncryptionSetReference.Copy()
		destination.DiskEncryptionSetReference = &diskEncryptionSetReference
	} else {
		destination.DiskEncryptionSetReference = nil
	}

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// EnableNamespaceResources
	if cluster.EnableNamespaceResources != nil {
		enableNamespaceResource := *cluster.EnableNamespaceResources
		destination.EnableNamespaceResources = &enableNamespaceResource
	} else {
		destination.EnableNamespaceResources = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation
		err := cluster.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HostedSystemProfile
	if cluster.HostedSystemProfile != nil {
		var hostedSystemProfile storage.ManagedClusterHostedSystemProfile
		err := cluster.HostedSystemProfile.AssignProperties_To_ManagedClusterHostedSystemProfile(&hostedSystemProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterHostedSystemProfile() to populate field HostedSystemProfile")
		}
		destination.HostedSystemProfile = &hostedSystemProfile
	} else {
		destination.HostedSystemProfile = nil
	}

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig storage.ManagedClusterHTTPProxyConfig
		err := cluster.HttpProxyConfig.AssignProperties_To_ManagedClusterHTTPProxyConfig(&httpProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Identity
	if cluster.Identity != nil {
		var identity storage.ManagedClusterIdentity
		err := cluster.Identity.AssignProperties_To_ManagedClusterIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfileMap := make(map[string]storage.UserAssignedIdentity, len(cluster.IdentityProfile))
		for identityProfileKey, identityProfileValue := range cluster.IdentityProfile {
			var identityProfile storage.UserAssignedIdentity
			err := identityProfileValue.AssignProperties_To_UserAssignedIdentity(&identityProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		destination.IdentityProfile = identityProfileMap
	} else {
		destination.IdentityProfile = nil
	}

	// IngressProfile
	if cluster.IngressProfile != nil {
		var ingressProfile storage.ManagedClusterIngressProfile
		err := cluster.IngressProfile.AssignProperties_To_ManagedClusterIngressProfile(&ingressProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfile() to populate field IngressProfile")
		}
		destination.IngressProfile = &ingressProfile
	} else {
		destination.IngressProfile = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(cluster.Kind)

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile storage.ContainerServiceLinuxProfile
		err := cluster.LinuxProfile.AssignProperties_To_ContainerServiceLinuxProfile(&linuxProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// MetricsProfile
	if cluster.MetricsProfile != nil {
		var metricsProfile storage.ManagedClusterMetricsProfile
		err := cluster.MetricsProfile.AssignProperties_To_ManagedClusterMetricsProfile(&metricsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterMetricsProfile() to populate field MetricsProfile")
		}
		destination.MetricsProfile = &metricsProfile
	} else {
		destination.MetricsProfile = nil
	}

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile storage.ContainerServiceNetworkProfile
		err := cluster.NetworkProfile.AssignProperties_To_ContainerServiceNetworkProfile(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeProvisioningProfile
	if cluster.NodeProvisioningProfile != nil {
		var nodeProvisioningProfile storage.ManagedClusterNodeProvisioningProfile
		err := cluster.NodeProvisioningProfile.AssignProperties_To_ManagedClusterNodeProvisioningProfile(&nodeProvisioningProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterNodeProvisioningProfile() to populate field NodeProvisioningProfile")
		}
		destination.NodeProvisioningProfile = &nodeProvisioningProfile
	} else {
		destination.NodeProvisioningProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// NodeResourceGroupProfile
	if cluster.NodeResourceGroupProfile != nil {
		var nodeResourceGroupProfile storage.ManagedClusterNodeResourceGroupProfile
		err := cluster.NodeResourceGroupProfile.AssignProperties_To_ManagedClusterNodeResourceGroupProfile(&nodeResourceGroupProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterNodeResourceGroupProfile() to populate field NodeResourceGroupProfile")
		}
		destination.NodeResourceGroupProfile = &nodeResourceGroupProfile
	} else {
		destination.NodeResourceGroupProfile = nil
	}

	// OidcIssuerProfile
	if cluster.OidcIssuerProfile != nil {
		var oidcIssuerProfile storage.ManagedClusterOIDCIssuerProfile
		err := cluster.OidcIssuerProfile.AssignProperties_To_ManagedClusterOIDCIssuerProfile(&oidcIssuerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterOIDCIssuerProfile() to populate field OidcIssuerProfile")
		}
		destination.OidcIssuerProfile = &oidcIssuerProfile
	} else {
		destination.OidcIssuerProfile = nil
	}

	// OperatorSpec
	if cluster.OperatorSpec != nil {
		var operatorSpec storage.ManagedClusterOperatorSpec
		err := cluster.OperatorSpec.AssignProperties_To_ManagedClusterOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = cluster.OriginalVersion()

	// Owner
	if cluster.Owner != nil {
		owner := cluster.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile storage.ManagedClusterPodIdentityProfile
		err := cluster.PodIdentityProfile.AssignProperties_To_ManagedClusterPodIdentityProfile(&podIdentityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]storage.PrivateLinkResource, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			var privateLinkResource storage.PrivateLinkResource
			err := privateLinkResourceItem.AssignProperties_To_PrivateLinkResource(&privateLinkResource)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// PublicNetworkAccess
	if cluster.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*cluster.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// SchedulerProfile
	if cluster.SchedulerProfile != nil {
		var schedulerProfile storage.SchedulerProfile
		err := cluster.SchedulerProfile.AssignProperties_To_SchedulerProfile(&schedulerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SchedulerProfile() to populate field SchedulerProfile")
		}
		destination.SchedulerProfile = &schedulerProfile
	} else {
		destination.SchedulerProfile = nil
	}

	// SecurityProfile
	if cluster.SecurityProfile != nil {
		var securityProfile storage.ManagedClusterSecurityProfile
		err := cluster.SecurityProfile.AssignProperties_To_ManagedClusterSecurityProfile(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// ServiceMeshProfile
	if cluster.ServiceMeshProfile != nil {
		var serviceMeshProfile storage.ServiceMeshProfile
		err := cluster.ServiceMeshProfile.AssignProperties_To_ServiceMeshProfile(&serviceMeshProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ServiceMeshProfile() to populate field ServiceMeshProfile")
		}
		destination.ServiceMeshProfile = &serviceMeshProfile
	} else {
		destination.ServiceMeshProfile = nil
	}

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile storage.ManagedClusterServicePrincipalProfile
		err := cluster.ServicePrincipalProfile.AssignProperties_To_ManagedClusterServicePrincipalProfile(&servicePrincipalProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku storage.ManagedClusterSKU
		err := cluster.Sku.AssignProperties_To_ManagedClusterSKU(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSKU() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// StorageProfile
	if cluster.StorageProfile != nil {
		var storageProfile storage.ManagedClusterStorageProfile
		err := cluster.StorageProfile.AssignProperties_To_ManagedClusterStorageProfile(&storageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// SupportPlan
	if cluster.SupportPlan != nil {
		supportPlan := string(*cluster.SupportPlan)
		destination.SupportPlan = &supportPlan
	} else {
		destination.SupportPlan = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// UpgradeSettings
	if cluster.UpgradeSettings != nil {
		var upgradeSetting storage.ClusterUpgradeSettings
		err := cluster.UpgradeSettings.AssignProperties_To_ClusterUpgradeSettings(&upgradeSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterUpgradeSettings() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile storage.ManagedClusterWindowsProfile
		err := cluster.WindowsProfile.AssignProperties_To_ManagedClusterWindowsProfile(&windowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// WorkloadAutoScalerProfile
	if cluster.WorkloadAutoScalerProfile != nil {
		var workloadAutoScalerProfile storage.ManagedClusterWorkloadAutoScalerProfile
		err := cluster.WorkloadAutoScalerProfile.AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile(&workloadAutoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile() to populate field WorkloadAutoScalerProfile")
		}
		destination.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
	} else {
		destination.WorkloadAutoScalerProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (cluster *ManagedCluster_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (cluster *ManagedCluster_Spec) SetAzureName(azureName string) { cluster.AzureName = azureName }

// Managed cluster.
type ManagedCluster_STATUS struct {
	// AadProfile: The Azure Active Directory configuration.
	AadProfile *ManagedClusterAADProfile_STATUS `json:"aadProfile,omitempty"`

	// AddonProfiles: The profile of managed cluster add-on.
	AddonProfiles map[string]ManagedClusterAddonProfile_STATUS `json:"addonProfiles,omitempty"`

	// AgentPoolProfiles: The agent pool properties.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile_STATUS `json:"agentPoolProfiles,omitempty"`

	// AiToolchainOperatorProfile: AI toolchain operator settings that apply to the whole cluster.
	AiToolchainOperatorProfile *ManagedClusterAIToolchainOperatorProfile_STATUS `json:"aiToolchainOperatorProfile,omitempty"`

	// ApiServerAccessProfile: The access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile_STATUS `json:"apiServerAccessProfile,omitempty"`

	// AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when enabled
	AutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile_STATUS `json:"autoScalerProfile,omitempty"`

	// AutoUpgradeProfile: The auto upgrade configuration.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile_STATUS `json:"autoUpgradeProfile,omitempty"`

	// AzureMonitorProfile: Azure Monitor addon profiles for monitoring the managed cluster.
	AzureMonitorProfile *ManagedClusterAzureMonitorProfile_STATUS `json:"azureMonitorProfile,omitempty"`

	// AzurePortalFQDN: The special FQDN used by the Azure Portal to access the Managed Cluster. This FQDN is for use only by
	// the Azure Portal and should not be used by other clients. The Azure Portal requires certain Cross-Origin Resource
	// Sharing (CORS) headers to be sent in some responses, which Kubernetes APIServer doesn't handle by default. This special
	// FQDN supports CORS, allowing the Azure Portal to function properly.
	AzurePortalFQDN *string `json:"azurePortalFQDN,omitempty"`

	// BootstrapProfile: Profile of the cluster bootstrap configuration.
	BootstrapProfile *ManagedClusterBootstrapProfile_STATUS `json:"bootstrapProfile,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the cluster will be created/upgraded using a
	// snapshot.
	CreationData *CreationData_STATUS `json:"creationData,omitempty"`

	// CurrentKubernetesVersion: The version of Kubernetes the Managed Cluster is running. If kubernetesVersion was a fully
	// specified version <major.minor.patch>, this field will be exactly equal to it. If kubernetesVersion was <major.minor>,
	// this field will contain the full <major.minor.patch> version being used.
	CurrentKubernetesVersion *string `json:"currentKubernetesVersion,omitempty"`

	// DisableLocalAccounts: If local accounts should be disabled on the Managed Cluster. If set to true, getting static
	// credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more
	// details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	// DiskEncryptionSetID: The Resource ID of the disk encryption set to use for enabling encryption at rest. This is of the
	// form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
	DiskEncryptionSetID *string `json:"diskEncryptionSetID,omitempty"`

	// DnsPrefix: The DNS prefix of the Managed Cluster. This cannot be updated once the Managed Cluster has been created.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	// ETag: If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.
	// Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in
	// the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header
	// fields.
	ETag *string `json:"eTag,omitempty"`

	// EnableNamespaceResources: Enable namespace as Azure resource. The default value is false. It can be enabled/disabled on
	// creation and updating of the managed cluster. See
	// [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource) for more details on Namespace as a ARM
	// Resource.
	EnableNamespaceResources *bool `json:"enableNamespaceResources,omitempty"`

	// EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// Fqdn: The FQDN of the master pool.
	Fqdn *string `json:"fqdn,omitempty"`

	// FqdnSubdomain: The FQDN subdomain of the private cluster with custom private dns zone. This cannot be updated once the
	// Managed Cluster has been created.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	// HostedSystemProfile: Settings for hosted system addons. For more information, see
	// https://aka.ms/aks/automatic/systemcomponents.
	HostedSystemProfile *ManagedClusterHostedSystemProfile_STATUS `json:"hostedSystemProfile,omitempty"`

	// HttpProxyConfig: Configurations for provisioning the cluster with HTTP proxy servers.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig_STATUS `json:"httpProxyConfig,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the managed cluster, if configured.
	Identity *ManagedClusterIdentity_STATUS `json:"identity,omitempty"`

	// IdentityProfile: The user identity associated with the managed cluster. This identity will be used by the kubelet. Only
	// one user assigned identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId":
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
	IdentityProfile map[string]UserAssignedIdentity_STATUS `json:"identityProfile,omitempty"`

	// IngressProfile: Ingress profile for the managed cluster.
	IngressProfile *ManagedClusterIngressProfile_STATUS `json:"ingressProfile,omitempty"`

	// Kind: This is primarily used to expose different UI experiences in the portal for different kinds
	Kind *string `json:"kind,omitempty"`

	// KubernetesVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS
	// cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version
	// number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not
	// allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	// LinuxProfile: The profile for Linux VMs in the Managed Cluster.
	LinuxProfile *ContainerServiceLinuxProfile_STATUS `json:"linuxProfile,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxAgentPools: The max number of agent pools for the managed cluster.
	MaxAgentPools *int `json:"maxAgentPools,omitempty"`

	// MetricsProfile: Optional cluster metrics configuration.
	MetricsProfile *ManagedClusterMetricsProfile_STATUS `json:"metricsProfile,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// NetworkProfile: The network configuration profile.
	NetworkProfile *ContainerServiceNetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// NodeProvisioningProfile: Node provisioning settings that apply to the whole cluster.
	NodeProvisioningProfile *ManagedClusterNodeProvisioningProfile_STATUS `json:"nodeProvisioningProfile,omitempty"`

	// NodeResourceGroup: The name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	// NodeResourceGroupProfile: Profile of the node resource group configuration.
	NodeResourceGroupProfile *ManagedClusterNodeResourceGroupProfile_STATUS `json:"nodeResourceGroupProfile,omitempty"`

	// OidcIssuerProfile: The OIDC issuer profile of the Managed Cluster.
	OidcIssuerProfile *ManagedClusterOIDCIssuerProfile_STATUS `json:"oidcIssuerProfile,omitempty"`

	// PodIdentityProfile: The pod identity profile of the Managed Cluster. See [use AAD pod
	// identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on AAD pod identity
	// integration.
	PodIdentityProfile *ManagedClusterPodIdentityProfile_STATUS `json:"podIdentityProfile,omitempty"`

	// PowerState: The Power State of the cluster.
	PowerState *PowerState_STATUS `json:"powerState,omitempty"`

	// PrivateFQDN: The FQDN of private cluster.
	PrivateFQDN *string `json:"privateFQDN,omitempty"`

	// PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource_STATUS `json:"privateLinkResources,omitempty"`

	// ProvisioningState: The current provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
	PublicNetworkAccess *PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ResourceUID: The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create, delete, create
	// sequence)
	ResourceUID *string `json:"resourceUID,omitempty"`

	// SchedulerProfile: Profile of the pod scheduler configuration.
	SchedulerProfile *SchedulerProfile_STATUS `json:"schedulerProfile,omitempty"`

	// SecurityProfile: Security profile for the managed cluster.
	SecurityProfile *ManagedClusterSecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// ServiceMeshProfile: Service mesh profile for a managed cluster.
	ServiceMeshProfile *ServiceMeshProfile_STATUS `json:"serviceMeshProfile,omitempty"`

	// ServicePrincipalProfile: Information about a service principal identity for the cluster to use for manipulating Azure
	// APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_STATUS `json:"servicePrincipalProfile,omitempty"`

	// Sku: The managed cluster SKU.
	Sku *ManagedClusterSKU_STATUS `json:"sku,omitempty"`

	// Status: Contains read-only information about the Managed Cluster.
	Status *ManagedClusterStatus_STATUS `json:"status,omitempty"`

	// StorageProfile: Storage profile for the managed cluster.
	StorageProfile *ManagedClusterStorageProfile_STATUS `json:"storageProfile,omitempty"`

	// SupportPlan: The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
	SupportPlan *KubernetesSupportPlan_STATUS `json:"supportPlan,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// UpgradeSettings: Settings for upgrading a cluster.
	UpgradeSettings *ClusterUpgradeSettings_STATUS `json:"upgradeSettings,omitempty"`

	// WindowsProfile: The profile for Windows VMs in the Managed Cluster.
	WindowsProfile *ManagedClusterWindowsProfile_STATUS `json:"windowsProfile,omitempty"`

	// WorkloadAutoScalerProfile: Workload Auto-scaler profile for the managed cluster.
	WorkloadAutoScalerProfile *ManagedClusterWorkloadAutoScalerProfile_STATUS `json:"workloadAutoScalerProfile,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedCluster_STATUS{}

// ConvertStatusFrom populates our ManagedCluster_STATUS from the provided source
func (cluster *ManagedCluster_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ManagedCluster_STATUS)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_ManagedCluster_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ManagedCluster_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_ManagedCluster_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ManagedCluster_STATUS)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_ManagedCluster_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ManagedCluster_STATUS{}
	err := cluster.AssignProperties_To_ManagedCluster_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ManagedCluster_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *ManagedCluster_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedCluster_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *ManagedCluster_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedCluster_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedCluster_STATUS, got %T", armInput)
	}

	// Set property "AadProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile_STATUS
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			cluster.AadProfile = &aadProfile
		}
	}

	// Set property "AddonProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			cluster.AddonProfiles = make(map[string]ManagedClusterAddonProfile_STATUS, len(typedInput.Properties.AddonProfiles))
			for key, value := range typedInput.Properties.AddonProfiles {
				var value1 ManagedClusterAddonProfile_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.AddonProfiles[key] = value1
			}
		}
	}

	// Set property "AgentPoolProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AgentPoolProfiles = append(cluster.AgentPoolProfiles, item1)
		}
	}

	// Set property "AiToolchainOperatorProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AiToolchainOperatorProfile != nil {
			var aiToolchainOperatorProfile1 ManagedClusterAIToolchainOperatorProfile_STATUS
			err := aiToolchainOperatorProfile1.PopulateFromARM(owner, *typedInput.Properties.AiToolchainOperatorProfile)
			if err != nil {
				return err
			}
			aiToolchainOperatorProfile := aiToolchainOperatorProfile1
			cluster.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
		}
	}

	// Set property "ApiServerAccessProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile_STATUS
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			cluster.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property "AutoScalerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterPropertiesAutoScalerProfile_STATUS
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			cluster.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property "AutoUpgradeProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile_STATUS
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			cluster.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property "AzureMonitorProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzureMonitorProfile != nil {
			var azureMonitorProfile1 ManagedClusterAzureMonitorProfile_STATUS
			err := azureMonitorProfile1.PopulateFromARM(owner, *typedInput.Properties.AzureMonitorProfile)
			if err != nil {
				return err
			}
			azureMonitorProfile := azureMonitorProfile1
			cluster.AzureMonitorProfile = &azureMonitorProfile
		}
	}

	// Set property "AzurePortalFQDN":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzurePortalFQDN != nil {
			azurePortalFQDN := *typedInput.Properties.AzurePortalFQDN
			cluster.AzurePortalFQDN = &azurePortalFQDN
		}
	}

	// Set property "BootstrapProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BootstrapProfile != nil {
			var bootstrapProfile1 ManagedClusterBootstrapProfile_STATUS
			err := bootstrapProfile1.PopulateFromARM(owner, *typedInput.Properties.BootstrapProfile)
			if err != nil {
				return err
			}
			bootstrapProfile := bootstrapProfile1
			cluster.BootstrapProfile = &bootstrapProfile
		}
	}

	// no assignment for property "Conditions"

	// Set property "CreationData":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreationData != nil {
			var creationData1 CreationData_STATUS
			err := creationData1.PopulateFromARM(owner, *typedInput.Properties.CreationData)
			if err != nil {
				return err
			}
			creationData := creationData1
			cluster.CreationData = &creationData
		}
	}

	// Set property "CurrentKubernetesVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurrentKubernetesVersion != nil {
			currentKubernetesVersion := *typedInput.Properties.CurrentKubernetesVersion
			cluster.CurrentKubernetesVersion = &currentKubernetesVersion
		}
	}

	// Set property "DisableLocalAccounts":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			cluster.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// Set property "DiskEncryptionSetID":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskEncryptionSetID != nil {
			diskEncryptionSetID := *typedInput.Properties.DiskEncryptionSetID
			cluster.DiskEncryptionSetID = &diskEncryptionSetID
		}
	}

	// Set property "DnsPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			cluster.DnsPrefix = &dnsPrefix
		}
	}

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		cluster.ETag = &eTag
	}

	// Set property "EnableNamespaceResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableNamespaceResources != nil {
			enableNamespaceResources := *typedInput.Properties.EnableNamespaceResources
			cluster.EnableNamespaceResources = &enableNamespaceResources
		}
	}

	// Set property "EnableRBAC":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			cluster.EnableRBAC = &enableRBAC
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		cluster.ExtendedLocation = &extendedLocation
	}

	// Set property "Fqdn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Fqdn != nil {
			fqdn := *typedInput.Properties.Fqdn
			cluster.Fqdn = &fqdn
		}
	}

	// Set property "FqdnSubdomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			cluster.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property "HostedSystemProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostedSystemProfile != nil {
			var hostedSystemProfile1 ManagedClusterHostedSystemProfile_STATUS
			err := hostedSystemProfile1.PopulateFromARM(owner, *typedInput.Properties.HostedSystemProfile)
			if err != nil {
				return err
			}
			hostedSystemProfile := hostedSystemProfile1
			cluster.HostedSystemProfile = &hostedSystemProfile
		}
	}

	// Set property "HttpProxyConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig_STATUS
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			cluster.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		cluster.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "IdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			cluster.IdentityProfile = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.Properties.IdentityProfile))
			for key, value := range typedInput.Properties.IdentityProfile {
				var value1 UserAssignedIdentity_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				cluster.IdentityProfile[key] = value1
			}
		}
	}

	// Set property "IngressProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IngressProfile != nil {
			var ingressProfile1 ManagedClusterIngressProfile_STATUS
			err := ingressProfile1.PopulateFromARM(owner, *typedInput.Properties.IngressProfile)
			if err != nil {
				return err
			}
			ingressProfile := ingressProfile1
			cluster.IngressProfile = &ingressProfile
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		cluster.Kind = &kind
	}

	// Set property "KubernetesVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			cluster.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property "LinuxProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile_STATUS
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			cluster.LinuxProfile = &linuxProfile
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property "MaxAgentPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxAgentPools != nil {
			maxAgentPools := *typedInput.Properties.MaxAgentPools
			cluster.MaxAgentPools = &maxAgentPools
		}
	}

	// Set property "MetricsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MetricsProfile != nil {
			var metricsProfile1 ManagedClusterMetricsProfile_STATUS
			err := metricsProfile1.PopulateFromARM(owner, *typedInput.Properties.MetricsProfile)
			if err != nil {
				return err
			}
			metricsProfile := metricsProfile1
			cluster.MetricsProfile = &metricsProfile
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		cluster.Name = &name
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile_STATUS
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			cluster.NetworkProfile = &networkProfile
		}
	}

	// Set property "NodeProvisioningProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeProvisioningProfile != nil {
			var nodeProvisioningProfile1 ManagedClusterNodeProvisioningProfile_STATUS
			err := nodeProvisioningProfile1.PopulateFromARM(owner, *typedInput.Properties.NodeProvisioningProfile)
			if err != nil {
				return err
			}
			nodeProvisioningProfile := nodeProvisioningProfile1
			cluster.NodeProvisioningProfile = &nodeProvisioningProfile
		}
	}

	// Set property "NodeResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			cluster.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// Set property "NodeResourceGroupProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroupProfile != nil {
			var nodeResourceGroupProfile1 ManagedClusterNodeResourceGroupProfile_STATUS
			err := nodeResourceGroupProfile1.PopulateFromARM(owner, *typedInput.Properties.NodeResourceGroupProfile)
			if err != nil {
				return err
			}
			nodeResourceGroupProfile := nodeResourceGroupProfile1
			cluster.NodeResourceGroupProfile = &nodeResourceGroupProfile
		}
	}

	// Set property "OidcIssuerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OidcIssuerProfile != nil {
			var oidcIssuerProfile1 ManagedClusterOIDCIssuerProfile_STATUS
			err := oidcIssuerProfile1.PopulateFromARM(owner, *typedInput.Properties.OidcIssuerProfile)
			if err != nil {
				return err
			}
			oidcIssuerProfile := oidcIssuerProfile1
			cluster.OidcIssuerProfile = &oidcIssuerProfile
		}
	}

	// Set property "PodIdentityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile_STATUS
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			cluster.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property "PowerState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PowerState != nil {
			var powerState1 PowerState_STATUS
			err := powerState1.PopulateFromARM(owner, *typedInput.Properties.PowerState)
			if err != nil {
				return err
			}
			powerState := powerState1
			cluster.PowerState = &powerState
		}
	}

	// Set property "PrivateFQDN":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateFQDN != nil {
			privateFQDN := *typedInput.Properties.PrivateFQDN
			cluster.PrivateFQDN = &privateFQDN
		}
	}

	// Set property "PrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.PrivateLinkResources = append(cluster.PrivateLinkResources, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			cluster.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := PublicNetworkAccess_STATUS(temp)
			cluster.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "ResourceUID":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceUID != nil {
			resourceUID := *typedInput.Properties.ResourceUID
			cluster.ResourceUID = &resourceUID
		}
	}

	// Set property "SchedulerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SchedulerProfile != nil {
			var schedulerProfile1 SchedulerProfile_STATUS
			err := schedulerProfile1.PopulateFromARM(owner, *typedInput.Properties.SchedulerProfile)
			if err != nil {
				return err
			}
			schedulerProfile := schedulerProfile1
			cluster.SchedulerProfile = &schedulerProfile
		}
	}

	// Set property "SecurityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 ManagedClusterSecurityProfile_STATUS
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			cluster.SecurityProfile = &securityProfile
		}
	}

	// Set property "ServiceMeshProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceMeshProfile != nil {
			var serviceMeshProfile1 ServiceMeshProfile_STATUS
			err := serviceMeshProfile1.PopulateFromARM(owner, *typedInput.Properties.ServiceMeshProfile)
			if err != nil {
				return err
			}
			serviceMeshProfile := serviceMeshProfile1
			cluster.ServiceMeshProfile = &serviceMeshProfile
		}
	}

	// Set property "ServicePrincipalProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile_STATUS
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			cluster.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property "Status":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Status != nil {
			var status1 ManagedClusterStatus_STATUS
			err := status1.PopulateFromARM(owner, *typedInput.Properties.Status)
			if err != nil {
				return err
			}
			status := status1
			cluster.Status = &status
		}
	}

	// Set property "StorageProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 ManagedClusterStorageProfile_STATUS
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			cluster.StorageProfile = &storageProfile
		}
	}

	// Set property "SupportPlan":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SupportPlan != nil {
			var temp string
			temp = string(*typedInput.Properties.SupportPlan)
			supportPlan := KubernetesSupportPlan_STATUS(temp)
			cluster.SupportPlan = &supportPlan
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		cluster.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		cluster.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradeSettings != nil {
			var upgradeSettings1 ClusterUpgradeSettings_STATUS
			err := upgradeSettings1.PopulateFromARM(owner, *typedInput.Properties.UpgradeSettings)
			if err != nil {
				return err
			}
			upgradeSettings := upgradeSettings1
			cluster.UpgradeSettings = &upgradeSettings
		}
	}

	// Set property "WindowsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile_STATUS
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			cluster.WindowsProfile = &windowsProfile
		}
	}

	// Set property "WorkloadAutoScalerProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkloadAutoScalerProfile != nil {
			var workloadAutoScalerProfile1 ManagedClusterWorkloadAutoScalerProfile_STATUS
			err := workloadAutoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.WorkloadAutoScalerProfile)
			if err != nil {
				return err
			}
			workloadAutoScalerProfile := workloadAutoScalerProfile1
			cluster.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedCluster_STATUS populates our ManagedCluster_STATUS from the provided source ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignProperties_From_ManagedCluster_STATUS(source *storage.ManagedCluster_STATUS) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile_STATUS
		err := aadProfile.AssignProperties_From_ManagedClusterAADProfile_STATUS(source.AadProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAADProfile_STATUS() to populate field AadProfile")
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfileMap := make(map[string]ManagedClusterAddonProfile_STATUS, len(source.AddonProfiles))
		for addonProfileKey, addonProfileValue := range source.AddonProfiles {
			var addonProfile ManagedClusterAddonProfile_STATUS
			err := addonProfile.AssignProperties_From_ManagedClusterAddonProfile_STATUS(&addonProfileValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAddonProfile_STATUS() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		cluster.AddonProfiles = addonProfileMap
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile_STATUS, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			var agentPoolProfile ManagedClusterAgentPoolProfile_STATUS
			err := agentPoolProfile.AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS(&agentPoolProfileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// AiToolchainOperatorProfile
	if source.AiToolchainOperatorProfile != nil {
		var aiToolchainOperatorProfile ManagedClusterAIToolchainOperatorProfile_STATUS
		err := aiToolchainOperatorProfile.AssignProperties_From_ManagedClusterAIToolchainOperatorProfile_STATUS(source.AiToolchainOperatorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAIToolchainOperatorProfile_STATUS() to populate field AiToolchainOperatorProfile")
		}
		cluster.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
	} else {
		cluster.AiToolchainOperatorProfile = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile_STATUS
		err := apiServerAccessProfile.AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS(source.ApiServerAccessProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterPropertiesAutoScalerProfile_STATUS
		err := autoScalerProfile.AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile_STATUS(source.AutoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile_STATUS() to populate field AutoScalerProfile")
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile_STATUS
		err := autoUpgradeProfile.AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS(source.AutoUpgradeProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzureMonitorProfile
	if source.AzureMonitorProfile != nil {
		var azureMonitorProfile ManagedClusterAzureMonitorProfile_STATUS
		err := azureMonitorProfile.AssignProperties_From_ManagedClusterAzureMonitorProfile_STATUS(source.AzureMonitorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfile_STATUS() to populate field AzureMonitorProfile")
		}
		cluster.AzureMonitorProfile = &azureMonitorProfile
	} else {
		cluster.AzureMonitorProfile = nil
	}

	// AzurePortalFQDN
	cluster.AzurePortalFQDN = genruntime.ClonePointerToString(source.AzurePortalFQDN)

	// BootstrapProfile
	if source.BootstrapProfile != nil {
		var bootstrapProfile ManagedClusterBootstrapProfile_STATUS
		err := bootstrapProfile.AssignProperties_From_ManagedClusterBootstrapProfile_STATUS(source.BootstrapProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterBootstrapProfile_STATUS() to populate field BootstrapProfile")
		}
		cluster.BootstrapProfile = &bootstrapProfile
	} else {
		cluster.BootstrapProfile = nil
	}

	// Conditions
	cluster.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CreationData
	if source.CreationData != nil {
		var creationDatum CreationData_STATUS
		err := creationDatum.AssignProperties_From_CreationData_STATUS(source.CreationData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CreationData_STATUS() to populate field CreationData")
		}
		cluster.CreationData = &creationDatum
	} else {
		cluster.CreationData = nil
	}

	// CurrentKubernetesVersion
	cluster.CurrentKubernetesVersion = genruntime.ClonePointerToString(source.CurrentKubernetesVersion)

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	cluster.DiskEncryptionSetID = genruntime.ClonePointerToString(source.DiskEncryptionSetID)

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// ETag
	cluster.ETag = genruntime.ClonePointerToString(source.ETag)

	// EnableNamespaceResources
	if source.EnableNamespaceResources != nil {
		enableNamespaceResource := *source.EnableNamespaceResources
		cluster.EnableNamespaceResources = &enableNamespaceResource
	} else {
		cluster.EnableNamespaceResources = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// Fqdn
	cluster.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HostedSystemProfile
	if source.HostedSystemProfile != nil {
		var hostedSystemProfile ManagedClusterHostedSystemProfile_STATUS
		err := hostedSystemProfile.AssignProperties_From_ManagedClusterHostedSystemProfile_STATUS(source.HostedSystemProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterHostedSystemProfile_STATUS() to populate field HostedSystemProfile")
		}
		cluster.HostedSystemProfile = &hostedSystemProfile
	} else {
		cluster.HostedSystemProfile = nil
	}

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig_STATUS
		err := httpProxyConfig.AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS(source.HttpProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Id
	cluster.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity_STATUS
		err := identity.AssignProperties_From_ManagedClusterIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity_STATUS() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfileMap := make(map[string]UserAssignedIdentity_STATUS, len(source.IdentityProfile))
		for identityProfileKey, identityProfileValue := range source.IdentityProfile {
			var identityProfile UserAssignedIdentity_STATUS
			err := identityProfile.AssignProperties_From_UserAssignedIdentity_STATUS(&identityProfileValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		cluster.IdentityProfile = identityProfileMap
	} else {
		cluster.IdentityProfile = nil
	}

	// IngressProfile
	if source.IngressProfile != nil {
		var ingressProfile ManagedClusterIngressProfile_STATUS
		err := ingressProfile.AssignProperties_From_ManagedClusterIngressProfile_STATUS(source.IngressProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfile_STATUS() to populate field IngressProfile")
		}
		cluster.IngressProfile = &ingressProfile
	} else {
		cluster.IngressProfile = nil
	}

	// Kind
	cluster.Kind = genruntime.ClonePointerToString(source.Kind)

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile_STATUS
		err := linuxProfile.AssignProperties_From_ContainerServiceLinuxProfile_STATUS(source.LinuxProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// MaxAgentPools
	cluster.MaxAgentPools = genruntime.ClonePointerToInt(source.MaxAgentPools)

	// MetricsProfile
	if source.MetricsProfile != nil {
		var metricsProfile ManagedClusterMetricsProfile_STATUS
		err := metricsProfile.AssignProperties_From_ManagedClusterMetricsProfile_STATUS(source.MetricsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterMetricsProfile_STATUS() to populate field MetricsProfile")
		}
		cluster.MetricsProfile = &metricsProfile
	} else {
		cluster.MetricsProfile = nil
	}

	// Name
	cluster.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_ContainerServiceNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeProvisioningProfile
	if source.NodeProvisioningProfile != nil {
		var nodeProvisioningProfile ManagedClusterNodeProvisioningProfile_STATUS
		err := nodeProvisioningProfile.AssignProperties_From_ManagedClusterNodeProvisioningProfile_STATUS(source.NodeProvisioningProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterNodeProvisioningProfile_STATUS() to populate field NodeProvisioningProfile")
		}
		cluster.NodeProvisioningProfile = &nodeProvisioningProfile
	} else {
		cluster.NodeProvisioningProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// NodeResourceGroupProfile
	if source.NodeResourceGroupProfile != nil {
		var nodeResourceGroupProfile ManagedClusterNodeResourceGroupProfile_STATUS
		err := nodeResourceGroupProfile.AssignProperties_From_ManagedClusterNodeResourceGroupProfile_STATUS(source.NodeResourceGroupProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterNodeResourceGroupProfile_STATUS() to populate field NodeResourceGroupProfile")
		}
		cluster.NodeResourceGroupProfile = &nodeResourceGroupProfile
	} else {
		cluster.NodeResourceGroupProfile = nil
	}

	// OidcIssuerProfile
	if source.OidcIssuerProfile != nil {
		var oidcIssuerProfile ManagedClusterOIDCIssuerProfile_STATUS
		err := oidcIssuerProfile.AssignProperties_From_ManagedClusterOIDCIssuerProfile_STATUS(source.OidcIssuerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterOIDCIssuerProfile_STATUS() to populate field OidcIssuerProfile")
		}
		cluster.OidcIssuerProfile = &oidcIssuerProfile
	} else {
		cluster.OidcIssuerProfile = nil
	}

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile_STATUS
		err := podIdentityProfile.AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS(source.PodIdentityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_STATUS
		err := powerState.AssignProperties_From_PowerState_STATUS(source.PowerState)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PowerState_STATUS() to populate field PowerState")
		}
		cluster.PowerState = &powerState
	} else {
		cluster.PowerState = nil
	}

	// PrivateFQDN
	cluster.PrivateFQDN = genruntime.ClonePointerToString(source.PrivateFQDN)

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource_STATUS, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			var privateLinkResource PrivateLinkResource_STATUS
			err := privateLinkResource.AssignProperties_From_PrivateLinkResource_STATUS(&privateLinkResourceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateLinkResource_STATUS() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// ProvisioningState
	cluster.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, publicNetworkAccess_STATUS_Values)
		cluster.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		cluster.PublicNetworkAccess = nil
	}

	// ResourceUID
	cluster.ResourceUID = genruntime.ClonePointerToString(source.ResourceUID)

	// SchedulerProfile
	if source.SchedulerProfile != nil {
		var schedulerProfile SchedulerProfile_STATUS
		err := schedulerProfile.AssignProperties_From_SchedulerProfile_STATUS(source.SchedulerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SchedulerProfile_STATUS() to populate field SchedulerProfile")
		}
		cluster.SchedulerProfile = &schedulerProfile
	} else {
		cluster.SchedulerProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile ManagedClusterSecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_ManagedClusterSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		cluster.SecurityProfile = &securityProfile
	} else {
		cluster.SecurityProfile = nil
	}

	// ServiceMeshProfile
	if source.ServiceMeshProfile != nil {
		var serviceMeshProfile ServiceMeshProfile_STATUS
		err := serviceMeshProfile.AssignProperties_From_ServiceMeshProfile_STATUS(source.ServiceMeshProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ServiceMeshProfile_STATUS() to populate field ServiceMeshProfile")
		}
		cluster.ServiceMeshProfile = &serviceMeshProfile
	} else {
		cluster.ServiceMeshProfile = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile_STATUS
		err := servicePrincipalProfile.AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS(source.ServicePrincipalProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU_STATUS
		err := sku.AssignProperties_From_ManagedClusterSKU_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSKU_STATUS() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Status
	if source.Status != nil {
		var status ManagedClusterStatus_STATUS
		err := status.AssignProperties_From_ManagedClusterStatus_STATUS(source.Status)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStatus_STATUS() to populate field Status")
		}
		cluster.Status = &status
	} else {
		cluster.Status = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile ManagedClusterStorageProfile_STATUS
		err := storageProfile.AssignProperties_From_ManagedClusterStorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfile_STATUS() to populate field StorageProfile")
		}
		cluster.StorageProfile = &storageProfile
	} else {
		cluster.StorageProfile = nil
	}

	// SupportPlan
	if source.SupportPlan != nil {
		supportPlan := *source.SupportPlan
		supportPlanTemp := genruntime.ToEnum(supportPlan, kubernetesSupportPlan_STATUS_Values)
		cluster.SupportPlan = &supportPlanTemp
	} else {
		cluster.SupportPlan = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		cluster.SystemData = &systemDatum
	} else {
		cluster.SystemData = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	cluster.Type = genruntime.ClonePointerToString(source.Type)

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting ClusterUpgradeSettings_STATUS
		err := upgradeSetting.AssignProperties_From_ClusterUpgradeSettings_STATUS(source.UpgradeSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterUpgradeSettings_STATUS() to populate field UpgradeSettings")
		}
		cluster.UpgradeSettings = &upgradeSetting
	} else {
		cluster.UpgradeSettings = nil
	}

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile_STATUS
		err := windowsProfile.AssignProperties_From_ManagedClusterWindowsProfile_STATUS(source.WindowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// WorkloadAutoScalerProfile
	if source.WorkloadAutoScalerProfile != nil {
		var workloadAutoScalerProfile ManagedClusterWorkloadAutoScalerProfile_STATUS
		err := workloadAutoScalerProfile.AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile_STATUS(source.WorkloadAutoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile_STATUS() to populate field WorkloadAutoScalerProfile")
		}
		cluster.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
	} else {
		cluster.WorkloadAutoScalerProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster_STATUS populates the provided destination ManagedCluster_STATUS from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignProperties_To_ManagedCluster_STATUS(destination *storage.ManagedCluster_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile storage.ManagedClusterAADProfile_STATUS
		err := cluster.AadProfile.AssignProperties_To_ManagedClusterAADProfile_STATUS(&aadProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAADProfile_STATUS() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfileMap := make(map[string]storage.ManagedClusterAddonProfile_STATUS, len(cluster.AddonProfiles))
		for addonProfileKey, addonProfileValue := range cluster.AddonProfiles {
			var addonProfile storage.ManagedClusterAddonProfile_STATUS
			err := addonProfileValue.AssignProperties_To_ManagedClusterAddonProfile_STATUS(&addonProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAddonProfile_STATUS() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		destination.AddonProfiles = addonProfileMap
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]storage.ManagedClusterAgentPoolProfile_STATUS, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			var agentPoolProfile storage.ManagedClusterAgentPoolProfile_STATUS
			err := agentPoolProfileItem.AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS(&agentPoolProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// AiToolchainOperatorProfile
	if cluster.AiToolchainOperatorProfile != nil {
		var aiToolchainOperatorProfile storage.ManagedClusterAIToolchainOperatorProfile_STATUS
		err := cluster.AiToolchainOperatorProfile.AssignProperties_To_ManagedClusterAIToolchainOperatorProfile_STATUS(&aiToolchainOperatorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAIToolchainOperatorProfile_STATUS() to populate field AiToolchainOperatorProfile")
		}
		destination.AiToolchainOperatorProfile = &aiToolchainOperatorProfile
	} else {
		destination.AiToolchainOperatorProfile = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile storage.ManagedClusterAPIServerAccessProfile_STATUS
		err := cluster.ApiServerAccessProfile.AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS(&apiServerAccessProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
		var autoScalerProfile storage.ManagedClusterPropertiesAutoScalerProfile_STATUS
		err := cluster.AutoScalerProfile.AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile_STATUS(&autoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile_STATUS() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile storage.ManagedClusterAutoUpgradeProfile_STATUS
		err := cluster.AutoUpgradeProfile.AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS(&autoUpgradeProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureMonitorProfile
	if cluster.AzureMonitorProfile != nil {
		var azureMonitorProfile storage.ManagedClusterAzureMonitorProfile_STATUS
		err := cluster.AzureMonitorProfile.AssignProperties_To_ManagedClusterAzureMonitorProfile_STATUS(&azureMonitorProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfile_STATUS() to populate field AzureMonitorProfile")
		}
		destination.AzureMonitorProfile = &azureMonitorProfile
	} else {
		destination.AzureMonitorProfile = nil
	}

	// AzurePortalFQDN
	destination.AzurePortalFQDN = genruntime.ClonePointerToString(cluster.AzurePortalFQDN)

	// BootstrapProfile
	if cluster.BootstrapProfile != nil {
		var bootstrapProfile storage.ManagedClusterBootstrapProfile_STATUS
		err := cluster.BootstrapProfile.AssignProperties_To_ManagedClusterBootstrapProfile_STATUS(&bootstrapProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterBootstrapProfile_STATUS() to populate field BootstrapProfile")
		}
		destination.BootstrapProfile = &bootstrapProfile
	} else {
		destination.BootstrapProfile = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(cluster.Conditions)

	// CreationData
	if cluster.CreationData != nil {
		var creationDatum storage.CreationData_STATUS
		err := cluster.CreationData.AssignProperties_To_CreationData_STATUS(&creationDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CreationData_STATUS() to populate field CreationData")
		}
		destination.CreationData = &creationDatum
	} else {
		destination.CreationData = nil
	}

	// CurrentKubernetesVersion
	destination.CurrentKubernetesVersion = genruntime.ClonePointerToString(cluster.CurrentKubernetesVersion)

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	destination.DiskEncryptionSetID = genruntime.ClonePointerToString(cluster.DiskEncryptionSetID)

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// ETag
	destination.ETag = genruntime.ClonePointerToString(cluster.ETag)

	// EnableNamespaceResources
	if cluster.EnableNamespaceResources != nil {
		enableNamespaceResource := *cluster.EnableNamespaceResources
		destination.EnableNamespaceResources = &enableNamespaceResource
	} else {
		destination.EnableNamespaceResources = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation_STATUS
		err := cluster.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(cluster.Fqdn)

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HostedSystemProfile
	if cluster.HostedSystemProfile != nil {
		var hostedSystemProfile storage.ManagedClusterHostedSystemProfile_STATUS
		err := cluster.HostedSystemProfile.AssignProperties_To_ManagedClusterHostedSystemProfile_STATUS(&hostedSystemProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterHostedSystemProfile_STATUS() to populate field HostedSystemProfile")
		}
		destination.HostedSystemProfile = &hostedSystemProfile
	} else {
		destination.HostedSystemProfile = nil
	}

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig storage.ManagedClusterHTTPProxyConfig_STATUS
		err := cluster.HttpProxyConfig.AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS(&httpProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(cluster.Id)

	// Identity
	if cluster.Identity != nil {
		var identity storage.ManagedClusterIdentity_STATUS
		err := cluster.Identity.AssignProperties_To_ManagedClusterIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfileMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(cluster.IdentityProfile))
		for identityProfileKey, identityProfileValue := range cluster.IdentityProfile {
			var identityProfile storage.UserAssignedIdentity_STATUS
			err := identityProfileValue.AssignProperties_To_UserAssignedIdentity_STATUS(&identityProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		destination.IdentityProfile = identityProfileMap
	} else {
		destination.IdentityProfile = nil
	}

	// IngressProfile
	if cluster.IngressProfile != nil {
		var ingressProfile storage.ManagedClusterIngressProfile_STATUS
		err := cluster.IngressProfile.AssignProperties_To_ManagedClusterIngressProfile_STATUS(&ingressProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfile_STATUS() to populate field IngressProfile")
		}
		destination.IngressProfile = &ingressProfile
	} else {
		destination.IngressProfile = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(cluster.Kind)

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile storage.ContainerServiceLinuxProfile_STATUS
		err := cluster.LinuxProfile.AssignProperties_To_ContainerServiceLinuxProfile_STATUS(&linuxProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// MaxAgentPools
	destination.MaxAgentPools = genruntime.ClonePointerToInt(cluster.MaxAgentPools)

	// MetricsProfile
	if cluster.MetricsProfile != nil {
		var metricsProfile storage.ManagedClusterMetricsProfile_STATUS
		err := cluster.MetricsProfile.AssignProperties_To_ManagedClusterMetricsProfile_STATUS(&metricsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterMetricsProfile_STATUS() to populate field MetricsProfile")
		}
		destination.MetricsProfile = &metricsProfile
	} else {
		destination.MetricsProfile = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(cluster.Name)

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile storage.ContainerServiceNetworkProfile_STATUS
		err := cluster.NetworkProfile.AssignProperties_To_ContainerServiceNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeProvisioningProfile
	if cluster.NodeProvisioningProfile != nil {
		var nodeProvisioningProfile storage.ManagedClusterNodeProvisioningProfile_STATUS
		err := cluster.NodeProvisioningProfile.AssignProperties_To_ManagedClusterNodeProvisioningProfile_STATUS(&nodeProvisioningProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterNodeProvisioningProfile_STATUS() to populate field NodeProvisioningProfile")
		}
		destination.NodeProvisioningProfile = &nodeProvisioningProfile
	} else {
		destination.NodeProvisioningProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// NodeResourceGroupProfile
	if cluster.NodeResourceGroupProfile != nil {
		var nodeResourceGroupProfile storage.ManagedClusterNodeResourceGroupProfile_STATUS
		err := cluster.NodeResourceGroupProfile.AssignProperties_To_ManagedClusterNodeResourceGroupProfile_STATUS(&nodeResourceGroupProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterNodeResourceGroupProfile_STATUS() to populate field NodeResourceGroupProfile")
		}
		destination.NodeResourceGroupProfile = &nodeResourceGroupProfile
	} else {
		destination.NodeResourceGroupProfile = nil
	}

	// OidcIssuerProfile
	if cluster.OidcIssuerProfile != nil {
		var oidcIssuerProfile storage.ManagedClusterOIDCIssuerProfile_STATUS
		err := cluster.OidcIssuerProfile.AssignProperties_To_ManagedClusterOIDCIssuerProfile_STATUS(&oidcIssuerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterOIDCIssuerProfile_STATUS() to populate field OidcIssuerProfile")
		}
		destination.OidcIssuerProfile = &oidcIssuerProfile
	} else {
		destination.OidcIssuerProfile = nil
	}

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile storage.ManagedClusterPodIdentityProfile_STATUS
		err := cluster.PodIdentityProfile.AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS(&podIdentityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PowerState
	if cluster.PowerState != nil {
		var powerState storage.PowerState_STATUS
		err := cluster.PowerState.AssignProperties_To_PowerState_STATUS(&powerState)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PowerState_STATUS() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// PrivateFQDN
	destination.PrivateFQDN = genruntime.ClonePointerToString(cluster.PrivateFQDN)

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]storage.PrivateLinkResource_STATUS, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			var privateLinkResource storage.PrivateLinkResource_STATUS
			err := privateLinkResourceItem.AssignProperties_To_PrivateLinkResource_STATUS(&privateLinkResource)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateLinkResource_STATUS() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(cluster.ProvisioningState)

	// PublicNetworkAccess
	if cluster.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*cluster.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ResourceUID
	destination.ResourceUID = genruntime.ClonePointerToString(cluster.ResourceUID)

	// SchedulerProfile
	if cluster.SchedulerProfile != nil {
		var schedulerProfile storage.SchedulerProfile_STATUS
		err := cluster.SchedulerProfile.AssignProperties_To_SchedulerProfile_STATUS(&schedulerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SchedulerProfile_STATUS() to populate field SchedulerProfile")
		}
		destination.SchedulerProfile = &schedulerProfile
	} else {
		destination.SchedulerProfile = nil
	}

	// SecurityProfile
	if cluster.SecurityProfile != nil {
		var securityProfile storage.ManagedClusterSecurityProfile_STATUS
		err := cluster.SecurityProfile.AssignProperties_To_ManagedClusterSecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// ServiceMeshProfile
	if cluster.ServiceMeshProfile != nil {
		var serviceMeshProfile storage.ServiceMeshProfile_STATUS
		err := cluster.ServiceMeshProfile.AssignProperties_To_ServiceMeshProfile_STATUS(&serviceMeshProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ServiceMeshProfile_STATUS() to populate field ServiceMeshProfile")
		}
		destination.ServiceMeshProfile = &serviceMeshProfile
	} else {
		destination.ServiceMeshProfile = nil
	}

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile storage.ManagedClusterServicePrincipalProfile_STATUS
		err := cluster.ServicePrincipalProfile.AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS(&servicePrincipalProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku storage.ManagedClusterSKU_STATUS
		err := cluster.Sku.AssignProperties_To_ManagedClusterSKU_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSKU_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Status
	if cluster.Status != nil {
		var status storage.ManagedClusterStatus_STATUS
		err := cluster.Status.AssignProperties_To_ManagedClusterStatus_STATUS(&status)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// StorageProfile
	if cluster.StorageProfile != nil {
		var storageProfile storage.ManagedClusterStorageProfile_STATUS
		err := cluster.StorageProfile.AssignProperties_To_ManagedClusterStorageProfile_STATUS(&storageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// SupportPlan
	if cluster.SupportPlan != nil {
		supportPlan := string(*cluster.SupportPlan)
		destination.SupportPlan = &supportPlan
	} else {
		destination.SupportPlan = nil
	}

	// SystemData
	if cluster.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := cluster.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(cluster.Type)

	// UpgradeSettings
	if cluster.UpgradeSettings != nil {
		var upgradeSetting storage.ClusterUpgradeSettings_STATUS
		err := cluster.UpgradeSettings.AssignProperties_To_ClusterUpgradeSettings_STATUS(&upgradeSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterUpgradeSettings_STATUS() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile storage.ManagedClusterWindowsProfile_STATUS
		err := cluster.WindowsProfile.AssignProperties_To_ManagedClusterWindowsProfile_STATUS(&windowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// WorkloadAutoScalerProfile
	if cluster.WorkloadAutoScalerProfile != nil {
		var workloadAutoScalerProfile storage.ManagedClusterWorkloadAutoScalerProfile_STATUS
		err := cluster.WorkloadAutoScalerProfile.AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile_STATUS(&workloadAutoScalerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile_STATUS() to populate field WorkloadAutoScalerProfile")
		}
		destination.WorkloadAutoScalerProfile = &workloadAutoScalerProfile
	} else {
		destination.WorkloadAutoScalerProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for upgrading a cluster.
type ClusterUpgradeSettings struct {
	// OverrideSettings: Settings for overrides.
	OverrideSettings *UpgradeOverrideSettings `json:"overrideSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterUpgradeSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ClusterUpgradeSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ClusterUpgradeSettings{}

	// Set property "OverrideSettings":
	if settings.OverrideSettings != nil {
		overrideSettings_ARM, err := settings.OverrideSettings.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		overrideSettings := *overrideSettings_ARM.(*arm.UpgradeOverrideSettings)
		result.OverrideSettings = &overrideSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ClusterUpgradeSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterUpgradeSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ClusterUpgradeSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterUpgradeSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterUpgradeSettings, got %T", armInput)
	}

	// Set property "OverrideSettings":
	if typedInput.OverrideSettings != nil {
		var overrideSettings1 UpgradeOverrideSettings
		err := overrideSettings1.PopulateFromARM(owner, *typedInput.OverrideSettings)
		if err != nil {
			return err
		}
		overrideSettings := overrideSettings1
		settings.OverrideSettings = &overrideSettings
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterUpgradeSettings populates our ClusterUpgradeSettings from the provided source ClusterUpgradeSettings
func (settings *ClusterUpgradeSettings) AssignProperties_From_ClusterUpgradeSettings(source *storage.ClusterUpgradeSettings) error {

	// OverrideSettings
	if source.OverrideSettings != nil {
		var overrideSetting UpgradeOverrideSettings
		err := overrideSetting.AssignProperties_From_UpgradeOverrideSettings(source.OverrideSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UpgradeOverrideSettings() to populate field OverrideSettings")
		}
		settings.OverrideSettings = &overrideSetting
	} else {
		settings.OverrideSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterUpgradeSettings populates the provided destination ClusterUpgradeSettings from our ClusterUpgradeSettings
func (settings *ClusterUpgradeSettings) AssignProperties_To_ClusterUpgradeSettings(destination *storage.ClusterUpgradeSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OverrideSettings
	if settings.OverrideSettings != nil {
		var overrideSetting storage.UpgradeOverrideSettings
		err := settings.OverrideSettings.AssignProperties_To_UpgradeOverrideSettings(&overrideSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UpgradeOverrideSettings() to populate field OverrideSettings")
		}
		destination.OverrideSettings = &overrideSetting
	} else {
		destination.OverrideSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for upgrading a cluster.
type ClusterUpgradeSettings_STATUS struct {
	// OverrideSettings: Settings for overrides.
	OverrideSettings *UpgradeOverrideSettings_STATUS `json:"overrideSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &ClusterUpgradeSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ClusterUpgradeSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterUpgradeSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ClusterUpgradeSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterUpgradeSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterUpgradeSettings_STATUS, got %T", armInput)
	}

	// Set property "OverrideSettings":
	if typedInput.OverrideSettings != nil {
		var overrideSettings1 UpgradeOverrideSettings_STATUS
		err := overrideSettings1.PopulateFromARM(owner, *typedInput.OverrideSettings)
		if err != nil {
			return err
		}
		overrideSettings := overrideSettings1
		settings.OverrideSettings = &overrideSettings
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterUpgradeSettings_STATUS populates our ClusterUpgradeSettings_STATUS from the provided source ClusterUpgradeSettings_STATUS
func (settings *ClusterUpgradeSettings_STATUS) AssignProperties_From_ClusterUpgradeSettings_STATUS(source *storage.ClusterUpgradeSettings_STATUS) error {

	// OverrideSettings
	if source.OverrideSettings != nil {
		var overrideSetting UpgradeOverrideSettings_STATUS
		err := overrideSetting.AssignProperties_From_UpgradeOverrideSettings_STATUS(source.OverrideSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UpgradeOverrideSettings_STATUS() to populate field OverrideSettings")
		}
		settings.OverrideSettings = &overrideSetting
	} else {
		settings.OverrideSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterUpgradeSettings_STATUS populates the provided destination ClusterUpgradeSettings_STATUS from our ClusterUpgradeSettings_STATUS
func (settings *ClusterUpgradeSettings_STATUS) AssignProperties_To_ClusterUpgradeSettings_STATUS(destination *storage.ClusterUpgradeSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OverrideSettings
	if settings.OverrideSettings != nil {
		var overrideSetting storage.UpgradeOverrideSettings_STATUS
		err := settings.OverrideSettings.AssignProperties_To_UpgradeOverrideSettings_STATUS(&overrideSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UpgradeOverrideSettings_STATUS() to populate field OverrideSettings")
		}
		destination.OverrideSettings = &overrideSetting
	} else {
		destination.OverrideSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile for Linux VMs in the container service cluster.
type ContainerServiceLinuxProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z][-A-Za-z0-9_]*$"
	// AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// +kubebuilder:validation:Required
	// Ssh: The SSH configuration for Linux-based VMs running on Azure.
	Ssh *ContainerServiceSshConfiguration `json:"ssh,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceLinuxProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ContainerServiceLinuxProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceLinuxProfile{}

	// Set property "AdminUsername":
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property "Ssh":
	if profile.Ssh != nil {
		ssh_ARM, err := profile.Ssh.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ssh := *ssh_ARM.(*arm.ContainerServiceSshConfiguration)
		result.Ssh = &ssh
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceLinuxProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceLinuxProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceLinuxProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceLinuxProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceLinuxProfile, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "Ssh":
	if typedInput.Ssh != nil {
		var ssh1 ContainerServiceSshConfiguration
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		profile.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceLinuxProfile populates our ContainerServiceLinuxProfile from the provided source ContainerServiceLinuxProfile
func (profile *ContainerServiceLinuxProfile) AssignProperties_From_ContainerServiceLinuxProfile(source *storage.ContainerServiceLinuxProfile) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration
		err := ssh.AssignProperties_From_ContainerServiceSshConfiguration(source.Ssh)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceSshConfiguration() to populate field Ssh")
		}
		profile.Ssh = &ssh
	} else {
		profile.Ssh = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceLinuxProfile populates the provided destination ContainerServiceLinuxProfile from our ContainerServiceLinuxProfile
func (profile *ContainerServiceLinuxProfile) AssignProperties_To_ContainerServiceLinuxProfile(destination *storage.ContainerServiceLinuxProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// Ssh
	if profile.Ssh != nil {
		var ssh storage.ContainerServiceSshConfiguration
		err := profile.Ssh.AssignProperties_To_ContainerServiceSshConfiguration(&ssh)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceSshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile for Linux VMs in the container service cluster.
type ContainerServiceLinuxProfile_STATUS struct {
	// AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// Ssh: The SSH configuration for Linux-based VMs running on Azure.
	Ssh *ContainerServiceSshConfiguration_STATUS `json:"ssh,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceLinuxProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceLinuxProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceLinuxProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceLinuxProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceLinuxProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceLinuxProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "Ssh":
	if typedInput.Ssh != nil {
		var ssh1 ContainerServiceSshConfiguration_STATUS
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		profile.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceLinuxProfile_STATUS populates our ContainerServiceLinuxProfile_STATUS from the provided source ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignProperties_From_ContainerServiceLinuxProfile_STATUS(source *storage.ContainerServiceLinuxProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration_STATUS
		err := ssh.AssignProperties_From_ContainerServiceSshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceSshConfiguration_STATUS() to populate field Ssh")
		}
		profile.Ssh = &ssh
	} else {
		profile.Ssh = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceLinuxProfile_STATUS populates the provided destination ContainerServiceLinuxProfile_STATUS from our ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignProperties_To_ContainerServiceLinuxProfile_STATUS(destination *storage.ContainerServiceLinuxProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// Ssh
	if profile.Ssh != nil {
		var ssh storage.ContainerServiceSshConfiguration_STATUS
		err := profile.Ssh.AssignProperties_To_ContainerServiceSshConfiguration_STATUS(&ssh)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceSshConfiguration_STATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of network configuration.
type ContainerServiceNetworkProfile struct {
	// AdvancedNetworking: Advanced Networking profile for enabling observability and security feature suite on a cluster. For
	// more information see aka.ms/aksadvancednetworking.
	AdvancedNetworking *AdvancedNetworking `json:"advancedNetworking,omitempty"`

	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// IpFamilies: The IP families used to specify IP versions available to the cluster. IP families are used to determine
	// single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values
	// are IPv4 and IPv6.
	IpFamilies []IPFamily `json:"ipFamilies,omitempty"`

	// KubeProxyConfig: Holds configuration customizations for kube-proxy. Any values not defined will use the kube-proxy
	// defaulting behavior. See https://v<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
	// where <version> is represented by a <major version>-<minor version> string. Kubernetes version 1.23 would be '1-23'.
	KubeProxyConfig *ContainerServiceNetworkProfileKubeProxyConfig `json:"kubeProxyConfig,omitempty"`

	// LoadBalancerProfile: Profile of the cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile `json:"loadBalancerProfile,omitempty"`

	// LoadBalancerSku: The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer
	// SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load
	// balancer SKUs.
	LoadBalancerSku *LoadBalancerSku `json:"loadBalancerSku,omitempty"`

	// NatGatewayProfile: Profile of the cluster NAT gateway.
	NatGatewayProfile *ManagedClusterNATGatewayProfile `json:"natGatewayProfile,omitempty"`

	// NetworkDataplane: Network dataplane used in the Kubernetes cluster.
	NetworkDataplane *NetworkDataplane `json:"networkDataplane,omitempty"`

	// NetworkMode: The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other
	// than 'azure'.
	NetworkMode *NetworkMode `json:"networkMode,omitempty"`

	// NetworkPlugin: Network plugin used for building the Kubernetes network.
	NetworkPlugin *NetworkPlugin `json:"networkPlugin,omitempty"`

	// NetworkPluginMode: The mode the network plugin should use.
	NetworkPluginMode *NetworkPluginMode `json:"networkPluginMode,omitempty"`

	// NetworkPolicy: Network policy used for building the Kubernetes network.
	NetworkPolicy *NetworkPolicy `json:"networkPolicy,omitempty"`

	// OutboundType: The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed
	// later. For more information see [egress outbound type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
	OutboundType *ContainerServiceNetworkProfile_OutboundType `json:"outboundType,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is used.
	PodCidr *string `json:"podCidr,omitempty"`

	// PodCidrs: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack
	// networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
	PodCidrs []string `json:"podCidrs,omitempty"`

	// PodLinkLocalAccess: Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods
	// with hostNetwork=false. if not specified, the default is 'IMDS'.
	PodLinkLocalAccess *PodLinkLocalAccess `json:"podLinkLocalAccess,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// ServiceCidrs: The CIDR notation IP ranges from which to assign service cluster IPs. One IPv4 CIDR is expected for
	// single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must
	// not overlap with any Subnet IP ranges.
	ServiceCidrs []string `json:"serviceCidrs,omitempty"`

	// StaticEgressGatewayProfile: The profile for Static Egress Gateway addon. For more details about Static Egress Gateway,
	// see https://aka.ms/aks/static-egress-gateway.
	StaticEgressGatewayProfile *ManagedClusterStaticEgressGatewayProfile `json:"staticEgressGatewayProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceNetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ContainerServiceNetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceNetworkProfile{}

	// Set property "AdvancedNetworking":
	if profile.AdvancedNetworking != nil {
		advancedNetworking_ARM, err := profile.AdvancedNetworking.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		advancedNetworking := *advancedNetworking_ARM.(*arm.AdvancedNetworking)
		result.AdvancedNetworking = &advancedNetworking
	}

	// Set property "DnsServiceIP":
	if profile.DnsServiceIP != nil {
		dnsServiceIP := *profile.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property "IpFamilies":
	for _, item := range profile.IpFamilies {
		var temp string
		temp = string(item)
		result.IpFamilies = append(result.IpFamilies, arm.IPFamily(temp))
	}

	// Set property "KubeProxyConfig":
	if profile.KubeProxyConfig != nil {
		kubeProxyConfig_ARM, err := profile.KubeProxyConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubeProxyConfig := *kubeProxyConfig_ARM.(*arm.ContainerServiceNetworkProfileKubeProxyConfig)
		result.KubeProxyConfig = &kubeProxyConfig
	}

	// Set property "LoadBalancerProfile":
	if profile.LoadBalancerProfile != nil {
		loadBalancerProfile_ARM, err := profile.LoadBalancerProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerProfile := *loadBalancerProfile_ARM.(*arm.ManagedClusterLoadBalancerProfile)
		result.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property "LoadBalancerSku":
	if profile.LoadBalancerSku != nil {
		var temp string
		temp = string(*profile.LoadBalancerSku)
		loadBalancerSku := arm.LoadBalancerSku(temp)
		result.LoadBalancerSku = &loadBalancerSku
	}

	// Set property "NatGatewayProfile":
	if profile.NatGatewayProfile != nil {
		natGatewayProfile_ARM, err := profile.NatGatewayProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		natGatewayProfile := *natGatewayProfile_ARM.(*arm.ManagedClusterNATGatewayProfile)
		result.NatGatewayProfile = &natGatewayProfile
	}

	// Set property "NetworkDataplane":
	if profile.NetworkDataplane != nil {
		var temp string
		temp = string(*profile.NetworkDataplane)
		networkDataplane := arm.NetworkDataplane(temp)
		result.NetworkDataplane = &networkDataplane
	}

	// Set property "NetworkMode":
	if profile.NetworkMode != nil {
		var temp string
		temp = string(*profile.NetworkMode)
		networkMode := arm.NetworkMode(temp)
		result.NetworkMode = &networkMode
	}

	// Set property "NetworkPlugin":
	if profile.NetworkPlugin != nil {
		var temp string
		temp = string(*profile.NetworkPlugin)
		networkPlugin := arm.NetworkPlugin(temp)
		result.NetworkPlugin = &networkPlugin
	}

	// Set property "NetworkPluginMode":
	if profile.NetworkPluginMode != nil {
		var temp string
		temp = string(*profile.NetworkPluginMode)
		networkPluginMode := arm.NetworkPluginMode(temp)
		result.NetworkPluginMode = &networkPluginMode
	}

	// Set property "NetworkPolicy":
	if profile.NetworkPolicy != nil {
		var temp string
		temp = string(*profile.NetworkPolicy)
		networkPolicy := arm.NetworkPolicy(temp)
		result.NetworkPolicy = &networkPolicy
	}

	// Set property "OutboundType":
	if profile.OutboundType != nil {
		var temp string
		temp = string(*profile.OutboundType)
		outboundType := arm.ContainerServiceNetworkProfile_OutboundType(temp)
		result.OutboundType = &outboundType
	}

	// Set property "PodCidr":
	if profile.PodCidr != nil {
		podCidr := *profile.PodCidr
		result.PodCidr = &podCidr
	}

	// Set property "PodCidrs":
	for _, item := range profile.PodCidrs {
		result.PodCidrs = append(result.PodCidrs, item)
	}

	// Set property "PodLinkLocalAccess":
	if profile.PodLinkLocalAccess != nil {
		var temp string
		temp = string(*profile.PodLinkLocalAccess)
		podLinkLocalAccess := arm.PodLinkLocalAccess(temp)
		result.PodLinkLocalAccess = &podLinkLocalAccess
	}

	// Set property "ServiceCidr":
	if profile.ServiceCidr != nil {
		serviceCidr := *profile.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}

	// Set property "ServiceCidrs":
	for _, item := range profile.ServiceCidrs {
		result.ServiceCidrs = append(result.ServiceCidrs, item)
	}

	// Set property "StaticEgressGatewayProfile":
	if profile.StaticEgressGatewayProfile != nil {
		staticEgressGatewayProfile_ARM, err := profile.StaticEgressGatewayProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		staticEgressGatewayProfile := *staticEgressGatewayProfile_ARM.(*arm.ManagedClusterStaticEgressGatewayProfile)
		result.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceNetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceNetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfile, got %T", armInput)
	}

	// Set property "AdvancedNetworking":
	if typedInput.AdvancedNetworking != nil {
		var advancedNetworking1 AdvancedNetworking
		err := advancedNetworking1.PopulateFromARM(owner, *typedInput.AdvancedNetworking)
		if err != nil {
			return err
		}
		advancedNetworking := advancedNetworking1
		profile.AdvancedNetworking = &advancedNetworking
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	}

	// Set property "IpFamilies":
	for _, item := range typedInput.IpFamilies {
		var temp string
		temp = string(item)
		profile.IpFamilies = append(profile.IpFamilies, IPFamily(temp))
	}

	// Set property "KubeProxyConfig":
	if typedInput.KubeProxyConfig != nil {
		var kubeProxyConfig1 ContainerServiceNetworkProfileKubeProxyConfig
		err := kubeProxyConfig1.PopulateFromARM(owner, *typedInput.KubeProxyConfig)
		if err != nil {
			return err
		}
		kubeProxyConfig := kubeProxyConfig1
		profile.KubeProxyConfig = &kubeProxyConfig
	}

	// Set property "LoadBalancerProfile":
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		profile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property "LoadBalancerSku":
	if typedInput.LoadBalancerSku != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerSku)
		loadBalancerSku := LoadBalancerSku(temp)
		profile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property "NatGatewayProfile":
	if typedInput.NatGatewayProfile != nil {
		var natGatewayProfile1 ManagedClusterNATGatewayProfile
		err := natGatewayProfile1.PopulateFromARM(owner, *typedInput.NatGatewayProfile)
		if err != nil {
			return err
		}
		natGatewayProfile := natGatewayProfile1
		profile.NatGatewayProfile = &natGatewayProfile
	}

	// Set property "NetworkDataplane":
	if typedInput.NetworkDataplane != nil {
		var temp string
		temp = string(*typedInput.NetworkDataplane)
		networkDataplane := NetworkDataplane(temp)
		profile.NetworkDataplane = &networkDataplane
	}

	// Set property "NetworkMode":
	if typedInput.NetworkMode != nil {
		var temp string
		temp = string(*typedInput.NetworkMode)
		networkMode := NetworkMode(temp)
		profile.NetworkMode = &networkMode
	}

	// Set property "NetworkPlugin":
	if typedInput.NetworkPlugin != nil {
		var temp string
		temp = string(*typedInput.NetworkPlugin)
		networkPlugin := NetworkPlugin(temp)
		profile.NetworkPlugin = &networkPlugin
	}

	// Set property "NetworkPluginMode":
	if typedInput.NetworkPluginMode != nil {
		var temp string
		temp = string(*typedInput.NetworkPluginMode)
		networkPluginMode := NetworkPluginMode(temp)
		profile.NetworkPluginMode = &networkPluginMode
	}

	// Set property "NetworkPolicy":
	if typedInput.NetworkPolicy != nil {
		var temp string
		temp = string(*typedInput.NetworkPolicy)
		networkPolicy := NetworkPolicy(temp)
		profile.NetworkPolicy = &networkPolicy
	}

	// Set property "OutboundType":
	if typedInput.OutboundType != nil {
		var temp string
		temp = string(*typedInput.OutboundType)
		outboundType := ContainerServiceNetworkProfile_OutboundType(temp)
		profile.OutboundType = &outboundType
	}

	// Set property "PodCidr":
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property "PodCidrs":
	for _, item := range typedInput.PodCidrs {
		profile.PodCidrs = append(profile.PodCidrs, item)
	}

	// Set property "PodLinkLocalAccess":
	if typedInput.PodLinkLocalAccess != nil {
		var temp string
		temp = string(*typedInput.PodLinkLocalAccess)
		podLinkLocalAccess := PodLinkLocalAccess(temp)
		profile.PodLinkLocalAccess = &podLinkLocalAccess
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// Set property "ServiceCidrs":
	for _, item := range typedInput.ServiceCidrs {
		profile.ServiceCidrs = append(profile.ServiceCidrs, item)
	}

	// Set property "StaticEgressGatewayProfile":
	if typedInput.StaticEgressGatewayProfile != nil {
		var staticEgressGatewayProfile1 ManagedClusterStaticEgressGatewayProfile
		err := staticEgressGatewayProfile1.PopulateFromARM(owner, *typedInput.StaticEgressGatewayProfile)
		if err != nil {
			return err
		}
		staticEgressGatewayProfile := staticEgressGatewayProfile1
		profile.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfile populates our ContainerServiceNetworkProfile from the provided source ContainerServiceNetworkProfile
func (profile *ContainerServiceNetworkProfile) AssignProperties_From_ContainerServiceNetworkProfile(source *storage.ContainerServiceNetworkProfile) error {

	// AdvancedNetworking
	if source.AdvancedNetworking != nil {
		var advancedNetworking AdvancedNetworking
		err := advancedNetworking.AssignProperties_From_AdvancedNetworking(source.AdvancedNetworking)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworking() to populate field AdvancedNetworking")
		}
		profile.AdvancedNetworking = &advancedNetworking
	} else {
		profile.AdvancedNetworking = nil
	}

	// DnsServiceIP
	profile.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// IpFamilies
	if source.IpFamilies != nil {
		ipFamilyList := make([]IPFamily, len(source.IpFamilies))
		for ipFamilyIndex, ipFamilyItem := range source.IpFamilies {
			ipFamilyList[ipFamilyIndex] = genruntime.ToEnum(ipFamilyItem, iPFamily_Values)
		}
		profile.IpFamilies = ipFamilyList
	} else {
		profile.IpFamilies = nil
	}

	// KubeProxyConfig
	if source.KubeProxyConfig != nil {
		var kubeProxyConfig ContainerServiceNetworkProfileKubeProxyConfig
		err := kubeProxyConfig.AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig(source.KubeProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig() to populate field KubeProxyConfig")
		}
		profile.KubeProxyConfig = &kubeProxyConfig
	} else {
		profile.KubeProxyConfig = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile.AssignProperties_From_ManagedClusterLoadBalancerProfile(source.LoadBalancerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := *source.LoadBalancerSku
		loadBalancerSkuTemp := genruntime.ToEnum(loadBalancerSku, loadBalancerSku_Values)
		profile.LoadBalancerSku = &loadBalancerSkuTemp
	} else {
		profile.LoadBalancerSku = nil
	}

	// NatGatewayProfile
	if source.NatGatewayProfile != nil {
		var natGatewayProfile ManagedClusterNATGatewayProfile
		err := natGatewayProfile.AssignProperties_From_ManagedClusterNATGatewayProfile(source.NatGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterNATGatewayProfile() to populate field NatGatewayProfile")
		}
		profile.NatGatewayProfile = &natGatewayProfile
	} else {
		profile.NatGatewayProfile = nil
	}

	// NetworkDataplane
	if source.NetworkDataplane != nil {
		networkDataplane := *source.NetworkDataplane
		networkDataplaneTemp := genruntime.ToEnum(networkDataplane, networkDataplane_Values)
		profile.NetworkDataplane = &networkDataplaneTemp
	} else {
		profile.NetworkDataplane = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := *source.NetworkMode
		networkModeTemp := genruntime.ToEnum(networkMode, networkMode_Values)
		profile.NetworkMode = &networkModeTemp
	} else {
		profile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := *source.NetworkPlugin
		networkPluginTemp := genruntime.ToEnum(networkPlugin, networkPlugin_Values)
		profile.NetworkPlugin = &networkPluginTemp
	} else {
		profile.NetworkPlugin = nil
	}

	// NetworkPluginMode
	if source.NetworkPluginMode != nil {
		networkPluginMode := *source.NetworkPluginMode
		networkPluginModeTemp := genruntime.ToEnum(networkPluginMode, networkPluginMode_Values)
		profile.NetworkPluginMode = &networkPluginModeTemp
	} else {
		profile.NetworkPluginMode = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := *source.NetworkPolicy
		networkPolicyTemp := genruntime.ToEnum(networkPolicy, networkPolicy_Values)
		profile.NetworkPolicy = &networkPolicyTemp
	} else {
		profile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := *source.OutboundType
		outboundTypeTemp := genruntime.ToEnum(outboundType, containerServiceNetworkProfile_OutboundType_Values)
		profile.OutboundType = &outboundTypeTemp
	} else {
		profile.OutboundType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// PodCidrs
	profile.PodCidrs = genruntime.CloneSliceOfString(source.PodCidrs)

	// PodLinkLocalAccess
	if source.PodLinkLocalAccess != nil {
		podLinkLocalAccess := *source.PodLinkLocalAccess
		podLinkLocalAccessTemp := genruntime.ToEnum(podLinkLocalAccess, podLinkLocalAccess_Values)
		profile.PodLinkLocalAccess = &podLinkLocalAccessTemp
	} else {
		profile.PodLinkLocalAccess = nil
	}

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// ServiceCidrs
	profile.ServiceCidrs = genruntime.CloneSliceOfString(source.ServiceCidrs)

	// StaticEgressGatewayProfile
	if source.StaticEgressGatewayProfile != nil {
		var staticEgressGatewayProfile ManagedClusterStaticEgressGatewayProfile
		err := staticEgressGatewayProfile.AssignProperties_From_ManagedClusterStaticEgressGatewayProfile(source.StaticEgressGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStaticEgressGatewayProfile() to populate field StaticEgressGatewayProfile")
		}
		profile.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	} else {
		profile.StaticEgressGatewayProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfile populates the provided destination ContainerServiceNetworkProfile from our ContainerServiceNetworkProfile
func (profile *ContainerServiceNetworkProfile) AssignProperties_To_ContainerServiceNetworkProfile(destination *storage.ContainerServiceNetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdvancedNetworking
	if profile.AdvancedNetworking != nil {
		var advancedNetworking storage.AdvancedNetworking
		err := profile.AdvancedNetworking.AssignProperties_To_AdvancedNetworking(&advancedNetworking)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworking() to populate field AdvancedNetworking")
		}
		destination.AdvancedNetworking = &advancedNetworking
	} else {
		destination.AdvancedNetworking = nil
	}

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(profile.DnsServiceIP)

	// IpFamilies
	if profile.IpFamilies != nil {
		ipFamilyList := make([]string, len(profile.IpFamilies))
		for ipFamilyIndex, ipFamilyItem := range profile.IpFamilies {
			ipFamilyList[ipFamilyIndex] = string(ipFamilyItem)
		}
		destination.IpFamilies = ipFamilyList
	} else {
		destination.IpFamilies = nil
	}

	// KubeProxyConfig
	if profile.KubeProxyConfig != nil {
		var kubeProxyConfig storage.ContainerServiceNetworkProfileKubeProxyConfig
		err := profile.KubeProxyConfig.AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig(&kubeProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig() to populate field KubeProxyConfig")
		}
		destination.KubeProxyConfig = &kubeProxyConfig
	} else {
		destination.KubeProxyConfig = nil
	}

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile storage.ManagedClusterLoadBalancerProfile
		err := profile.LoadBalancerProfile.AssignProperties_To_ManagedClusterLoadBalancerProfile(&loadBalancerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := string(*profile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NatGatewayProfile
	if profile.NatGatewayProfile != nil {
		var natGatewayProfile storage.ManagedClusterNATGatewayProfile
		err := profile.NatGatewayProfile.AssignProperties_To_ManagedClusterNATGatewayProfile(&natGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterNATGatewayProfile() to populate field NatGatewayProfile")
		}
		destination.NatGatewayProfile = &natGatewayProfile
	} else {
		destination.NatGatewayProfile = nil
	}

	// NetworkDataplane
	if profile.NetworkDataplane != nil {
		networkDataplane := string(*profile.NetworkDataplane)
		destination.NetworkDataplane = &networkDataplane
	} else {
		destination.NetworkDataplane = nil
	}

	// NetworkMode
	if profile.NetworkMode != nil {
		networkMode := string(*profile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if profile.NetworkPlugin != nil {
		networkPlugin := string(*profile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPluginMode
	if profile.NetworkPluginMode != nil {
		networkPluginMode := string(*profile.NetworkPluginMode)
		destination.NetworkPluginMode = &networkPluginMode
	} else {
		destination.NetworkPluginMode = nil
	}

	// NetworkPolicy
	if profile.NetworkPolicy != nil {
		networkPolicy := string(*profile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// PodCidrs
	destination.PodCidrs = genruntime.CloneSliceOfString(profile.PodCidrs)

	// PodLinkLocalAccess
	if profile.PodLinkLocalAccess != nil {
		podLinkLocalAccess := string(*profile.PodLinkLocalAccess)
		destination.PodLinkLocalAccess = &podLinkLocalAccess
	} else {
		destination.PodLinkLocalAccess = nil
	}

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// ServiceCidrs
	destination.ServiceCidrs = genruntime.CloneSliceOfString(profile.ServiceCidrs)

	// StaticEgressGatewayProfile
	if profile.StaticEgressGatewayProfile != nil {
		var staticEgressGatewayProfile storage.ManagedClusterStaticEgressGatewayProfile
		err := profile.StaticEgressGatewayProfile.AssignProperties_To_ManagedClusterStaticEgressGatewayProfile(&staticEgressGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStaticEgressGatewayProfile() to populate field StaticEgressGatewayProfile")
		}
		destination.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	} else {
		destination.StaticEgressGatewayProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of network configuration.
type ContainerServiceNetworkProfile_STATUS struct {
	// AdvancedNetworking: Advanced Networking profile for enabling observability and security feature suite on a cluster. For
	// more information see aka.ms/aksadvancednetworking.
	AdvancedNetworking *AdvancedNetworking_STATUS `json:"advancedNetworking,omitempty"`

	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// IpFamilies: The IP families used to specify IP versions available to the cluster. IP families are used to determine
	// single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values
	// are IPv4 and IPv6.
	IpFamilies []IPFamily_STATUS `json:"ipFamilies,omitempty"`

	// KubeProxyConfig: Holds configuration customizations for kube-proxy. Any values not defined will use the kube-proxy
	// defaulting behavior. See https://v<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
	// where <version> is represented by a <major version>-<minor version> string. Kubernetes version 1.23 would be '1-23'.
	KubeProxyConfig *ContainerServiceNetworkProfileKubeProxyConfig_STATUS `json:"kubeProxyConfig,omitempty"`

	// LoadBalancerProfile: Profile of the cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_STATUS `json:"loadBalancerProfile,omitempty"`

	// LoadBalancerSku: The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer
	// SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load
	// balancer SKUs.
	LoadBalancerSku *LoadBalancerSku_STATUS `json:"loadBalancerSku,omitempty"`

	// NatGatewayProfile: Profile of the cluster NAT gateway.
	NatGatewayProfile *ManagedClusterNATGatewayProfile_STATUS `json:"natGatewayProfile,omitempty"`

	// NetworkDataplane: Network dataplane used in the Kubernetes cluster.
	NetworkDataplane *NetworkDataplane_STATUS `json:"networkDataplane,omitempty"`

	// NetworkMode: The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other
	// than 'azure'.
	NetworkMode *NetworkMode_STATUS `json:"networkMode,omitempty"`

	// NetworkPlugin: Network plugin used for building the Kubernetes network.
	NetworkPlugin *NetworkPlugin_STATUS `json:"networkPlugin,omitempty"`

	// NetworkPluginMode: The mode the network plugin should use.
	NetworkPluginMode *NetworkPluginMode_STATUS `json:"networkPluginMode,omitempty"`

	// NetworkPolicy: Network policy used for building the Kubernetes network.
	NetworkPolicy *NetworkPolicy_STATUS `json:"networkPolicy,omitempty"`

	// OutboundType: The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed
	// later. For more information see [egress outbound type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
	OutboundType *ContainerServiceNetworkProfile_OutboundType_STATUS `json:"outboundType,omitempty"`

	// PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is used.
	PodCidr *string `json:"podCidr,omitempty"`

	// PodCidrs: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack
	// networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
	PodCidrs []string `json:"podCidrs,omitempty"`

	// PodLinkLocalAccess: Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods
	// with hostNetwork=false. if not specified, the default is 'IMDS'.
	PodLinkLocalAccess *PodLinkLocalAccess_STATUS `json:"podLinkLocalAccess,omitempty"`

	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// ServiceCidrs: The CIDR notation IP ranges from which to assign service cluster IPs. One IPv4 CIDR is expected for
	// single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must
	// not overlap with any Subnet IP ranges.
	ServiceCidrs []string `json:"serviceCidrs,omitempty"`

	// StaticEgressGatewayProfile: The profile for Static Egress Gateway addon. For more details about Static Egress Gateway,
	// see https://aka.ms/aks/static-egress-gateway.
	StaticEgressGatewayProfile *ManagedClusterStaticEgressGatewayProfile_STATUS `json:"staticEgressGatewayProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceNetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ContainerServiceNetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ContainerServiceNetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfile_STATUS, got %T", armInput)
	}

	// Set property "AdvancedNetworking":
	if typedInput.AdvancedNetworking != nil {
		var advancedNetworking1 AdvancedNetworking_STATUS
		err := advancedNetworking1.PopulateFromARM(owner, *typedInput.AdvancedNetworking)
		if err != nil {
			return err
		}
		advancedNetworking := advancedNetworking1
		profile.AdvancedNetworking = &advancedNetworking
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		profile.DnsServiceIP = &dnsServiceIP
	}

	// Set property "IpFamilies":
	for _, item := range typedInput.IpFamilies {
		var temp string
		temp = string(item)
		profile.IpFamilies = append(profile.IpFamilies, IPFamily_STATUS(temp))
	}

	// Set property "KubeProxyConfig":
	if typedInput.KubeProxyConfig != nil {
		var kubeProxyConfig1 ContainerServiceNetworkProfileKubeProxyConfig_STATUS
		err := kubeProxyConfig1.PopulateFromARM(owner, *typedInput.KubeProxyConfig)
		if err != nil {
			return err
		}
		kubeProxyConfig := kubeProxyConfig1
		profile.KubeProxyConfig = &kubeProxyConfig
	}

	// Set property "LoadBalancerProfile":
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile_STATUS
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		profile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property "LoadBalancerSku":
	if typedInput.LoadBalancerSku != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerSku)
		loadBalancerSku := LoadBalancerSku_STATUS(temp)
		profile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property "NatGatewayProfile":
	if typedInput.NatGatewayProfile != nil {
		var natGatewayProfile1 ManagedClusterNATGatewayProfile_STATUS
		err := natGatewayProfile1.PopulateFromARM(owner, *typedInput.NatGatewayProfile)
		if err != nil {
			return err
		}
		natGatewayProfile := natGatewayProfile1
		profile.NatGatewayProfile = &natGatewayProfile
	}

	// Set property "NetworkDataplane":
	if typedInput.NetworkDataplane != nil {
		var temp string
		temp = string(*typedInput.NetworkDataplane)
		networkDataplane := NetworkDataplane_STATUS(temp)
		profile.NetworkDataplane = &networkDataplane
	}

	// Set property "NetworkMode":
	if typedInput.NetworkMode != nil {
		var temp string
		temp = string(*typedInput.NetworkMode)
		networkMode := NetworkMode_STATUS(temp)
		profile.NetworkMode = &networkMode
	}

	// Set property "NetworkPlugin":
	if typedInput.NetworkPlugin != nil {
		var temp string
		temp = string(*typedInput.NetworkPlugin)
		networkPlugin := NetworkPlugin_STATUS(temp)
		profile.NetworkPlugin = &networkPlugin
	}

	// Set property "NetworkPluginMode":
	if typedInput.NetworkPluginMode != nil {
		var temp string
		temp = string(*typedInput.NetworkPluginMode)
		networkPluginMode := NetworkPluginMode_STATUS(temp)
		profile.NetworkPluginMode = &networkPluginMode
	}

	// Set property "NetworkPolicy":
	if typedInput.NetworkPolicy != nil {
		var temp string
		temp = string(*typedInput.NetworkPolicy)
		networkPolicy := NetworkPolicy_STATUS(temp)
		profile.NetworkPolicy = &networkPolicy
	}

	// Set property "OutboundType":
	if typedInput.OutboundType != nil {
		var temp string
		temp = string(*typedInput.OutboundType)
		outboundType := ContainerServiceNetworkProfile_OutboundType_STATUS(temp)
		profile.OutboundType = &outboundType
	}

	// Set property "PodCidr":
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property "PodCidrs":
	for _, item := range typedInput.PodCidrs {
		profile.PodCidrs = append(profile.PodCidrs, item)
	}

	// Set property "PodLinkLocalAccess":
	if typedInput.PodLinkLocalAccess != nil {
		var temp string
		temp = string(*typedInput.PodLinkLocalAccess)
		podLinkLocalAccess := PodLinkLocalAccess_STATUS(temp)
		profile.PodLinkLocalAccess = &podLinkLocalAccess
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// Set property "ServiceCidrs":
	for _, item := range typedInput.ServiceCidrs {
		profile.ServiceCidrs = append(profile.ServiceCidrs, item)
	}

	// Set property "StaticEgressGatewayProfile":
	if typedInput.StaticEgressGatewayProfile != nil {
		var staticEgressGatewayProfile1 ManagedClusterStaticEgressGatewayProfile_STATUS
		err := staticEgressGatewayProfile1.PopulateFromARM(owner, *typedInput.StaticEgressGatewayProfile)
		if err != nil {
			return err
		}
		staticEgressGatewayProfile := staticEgressGatewayProfile1
		profile.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfile_STATUS populates our ContainerServiceNetworkProfile_STATUS from the provided source ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignProperties_From_ContainerServiceNetworkProfile_STATUS(source *storage.ContainerServiceNetworkProfile_STATUS) error {

	// AdvancedNetworking
	if source.AdvancedNetworking != nil {
		var advancedNetworking AdvancedNetworking_STATUS
		err := advancedNetworking.AssignProperties_From_AdvancedNetworking_STATUS(source.AdvancedNetworking)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworking_STATUS() to populate field AdvancedNetworking")
		}
		profile.AdvancedNetworking = &advancedNetworking
	} else {
		profile.AdvancedNetworking = nil
	}

	// DnsServiceIP
	profile.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// IpFamilies
	if source.IpFamilies != nil {
		ipFamilyList := make([]IPFamily_STATUS, len(source.IpFamilies))
		for ipFamilyIndex, ipFamilyItem := range source.IpFamilies {
			ipFamilyList[ipFamilyIndex] = genruntime.ToEnum(ipFamilyItem, iPFamily_STATUS_Values)
		}
		profile.IpFamilies = ipFamilyList
	} else {
		profile.IpFamilies = nil
	}

	// KubeProxyConfig
	if source.KubeProxyConfig != nil {
		var kubeProxyConfig ContainerServiceNetworkProfileKubeProxyConfig_STATUS
		err := kubeProxyConfig.AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig_STATUS(source.KubeProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig_STATUS() to populate field KubeProxyConfig")
		}
		profile.KubeProxyConfig = &kubeProxyConfig
	} else {
		profile.KubeProxyConfig = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile_STATUS
		err := loadBalancerProfile.AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS(source.LoadBalancerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := *source.LoadBalancerSku
		loadBalancerSkuTemp := genruntime.ToEnum(loadBalancerSku, loadBalancerSku_STATUS_Values)
		profile.LoadBalancerSku = &loadBalancerSkuTemp
	} else {
		profile.LoadBalancerSku = nil
	}

	// NatGatewayProfile
	if source.NatGatewayProfile != nil {
		var natGatewayProfile ManagedClusterNATGatewayProfile_STATUS
		err := natGatewayProfile.AssignProperties_From_ManagedClusterNATGatewayProfile_STATUS(source.NatGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterNATGatewayProfile_STATUS() to populate field NatGatewayProfile")
		}
		profile.NatGatewayProfile = &natGatewayProfile
	} else {
		profile.NatGatewayProfile = nil
	}

	// NetworkDataplane
	if source.NetworkDataplane != nil {
		networkDataplane := *source.NetworkDataplane
		networkDataplaneTemp := genruntime.ToEnum(networkDataplane, networkDataplane_STATUS_Values)
		profile.NetworkDataplane = &networkDataplaneTemp
	} else {
		profile.NetworkDataplane = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := *source.NetworkMode
		networkModeTemp := genruntime.ToEnum(networkMode, networkMode_STATUS_Values)
		profile.NetworkMode = &networkModeTemp
	} else {
		profile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := *source.NetworkPlugin
		networkPluginTemp := genruntime.ToEnum(networkPlugin, networkPlugin_STATUS_Values)
		profile.NetworkPlugin = &networkPluginTemp
	} else {
		profile.NetworkPlugin = nil
	}

	// NetworkPluginMode
	if source.NetworkPluginMode != nil {
		networkPluginMode := *source.NetworkPluginMode
		networkPluginModeTemp := genruntime.ToEnum(networkPluginMode, networkPluginMode_STATUS_Values)
		profile.NetworkPluginMode = &networkPluginModeTemp
	} else {
		profile.NetworkPluginMode = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := *source.NetworkPolicy
		networkPolicyTemp := genruntime.ToEnum(networkPolicy, networkPolicy_STATUS_Values)
		profile.NetworkPolicy = &networkPolicyTemp
	} else {
		profile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := *source.OutboundType
		outboundTypeTemp := genruntime.ToEnum(outboundType, containerServiceNetworkProfile_OutboundType_STATUS_Values)
		profile.OutboundType = &outboundTypeTemp
	} else {
		profile.OutboundType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// PodCidrs
	profile.PodCidrs = genruntime.CloneSliceOfString(source.PodCidrs)

	// PodLinkLocalAccess
	if source.PodLinkLocalAccess != nil {
		podLinkLocalAccess := *source.PodLinkLocalAccess
		podLinkLocalAccessTemp := genruntime.ToEnum(podLinkLocalAccess, podLinkLocalAccess_STATUS_Values)
		profile.PodLinkLocalAccess = &podLinkLocalAccessTemp
	} else {
		profile.PodLinkLocalAccess = nil
	}

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// ServiceCidrs
	profile.ServiceCidrs = genruntime.CloneSliceOfString(source.ServiceCidrs)

	// StaticEgressGatewayProfile
	if source.StaticEgressGatewayProfile != nil {
		var staticEgressGatewayProfile ManagedClusterStaticEgressGatewayProfile_STATUS
		err := staticEgressGatewayProfile.AssignProperties_From_ManagedClusterStaticEgressGatewayProfile_STATUS(source.StaticEgressGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStaticEgressGatewayProfile_STATUS() to populate field StaticEgressGatewayProfile")
		}
		profile.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	} else {
		profile.StaticEgressGatewayProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfile_STATUS populates the provided destination ContainerServiceNetworkProfile_STATUS from our ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignProperties_To_ContainerServiceNetworkProfile_STATUS(destination *storage.ContainerServiceNetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdvancedNetworking
	if profile.AdvancedNetworking != nil {
		var advancedNetworking storage.AdvancedNetworking_STATUS
		err := profile.AdvancedNetworking.AssignProperties_To_AdvancedNetworking_STATUS(&advancedNetworking)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworking_STATUS() to populate field AdvancedNetworking")
		}
		destination.AdvancedNetworking = &advancedNetworking
	} else {
		destination.AdvancedNetworking = nil
	}

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(profile.DnsServiceIP)

	// IpFamilies
	if profile.IpFamilies != nil {
		ipFamilyList := make([]string, len(profile.IpFamilies))
		for ipFamilyIndex, ipFamilyItem := range profile.IpFamilies {
			ipFamilyList[ipFamilyIndex] = string(ipFamilyItem)
		}
		destination.IpFamilies = ipFamilyList
	} else {
		destination.IpFamilies = nil
	}

	// KubeProxyConfig
	if profile.KubeProxyConfig != nil {
		var kubeProxyConfig storage.ContainerServiceNetworkProfileKubeProxyConfig_STATUS
		err := profile.KubeProxyConfig.AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig_STATUS(&kubeProxyConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig_STATUS() to populate field KubeProxyConfig")
		}
		destination.KubeProxyConfig = &kubeProxyConfig
	} else {
		destination.KubeProxyConfig = nil
	}

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile storage.ManagedClusterLoadBalancerProfile_STATUS
		err := profile.LoadBalancerProfile.AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS(&loadBalancerProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if profile.LoadBalancerSku != nil {
		loadBalancerSku := string(*profile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NatGatewayProfile
	if profile.NatGatewayProfile != nil {
		var natGatewayProfile storage.ManagedClusterNATGatewayProfile_STATUS
		err := profile.NatGatewayProfile.AssignProperties_To_ManagedClusterNATGatewayProfile_STATUS(&natGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterNATGatewayProfile_STATUS() to populate field NatGatewayProfile")
		}
		destination.NatGatewayProfile = &natGatewayProfile
	} else {
		destination.NatGatewayProfile = nil
	}

	// NetworkDataplane
	if profile.NetworkDataplane != nil {
		networkDataplane := string(*profile.NetworkDataplane)
		destination.NetworkDataplane = &networkDataplane
	} else {
		destination.NetworkDataplane = nil
	}

	// NetworkMode
	if profile.NetworkMode != nil {
		networkMode := string(*profile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if profile.NetworkPlugin != nil {
		networkPlugin := string(*profile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPluginMode
	if profile.NetworkPluginMode != nil {
		networkPluginMode := string(*profile.NetworkPluginMode)
		destination.NetworkPluginMode = &networkPluginMode
	} else {
		destination.NetworkPluginMode = nil
	}

	// NetworkPolicy
	if profile.NetworkPolicy != nil {
		networkPolicy := string(*profile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// PodCidrs
	destination.PodCidrs = genruntime.CloneSliceOfString(profile.PodCidrs)

	// PodLinkLocalAccess
	if profile.PodLinkLocalAccess != nil {
		podLinkLocalAccess := string(*profile.PodLinkLocalAccess)
		destination.PodLinkLocalAccess = &podLinkLocalAccess
	} else {
		destination.PodLinkLocalAccess = nil
	}

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// ServiceCidrs
	destination.ServiceCidrs = genruntime.CloneSliceOfString(profile.ServiceCidrs)

	// StaticEgressGatewayProfile
	if profile.StaticEgressGatewayProfile != nil {
		var staticEgressGatewayProfile storage.ManagedClusterStaticEgressGatewayProfile_STATUS
		err := profile.StaticEgressGatewayProfile.AssignProperties_To_ManagedClusterStaticEgressGatewayProfile_STATUS(&staticEgressGatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStaticEgressGatewayProfile_STATUS() to populate field StaticEgressGatewayProfile")
		}
		destination.StaticEgressGatewayProfile = &staticEgressGatewayProfile
	} else {
		destination.StaticEgressGatewayProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Data used when creating a target resource from a source resource.
type CreationData struct {
	// SourceResourceReference: This is the ARM ID of the source object to be used to create the target object.
	SourceResourceReference *genruntime.ResourceReference `armReference:"SourceResourceId" json:"sourceResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &CreationData{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (data *CreationData) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if data == nil {
		return nil, nil
	}
	result := &arm.CreationData{}

	// Set property "SourceResourceId":
	if data.SourceResourceReference != nil {
		sourceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*data.SourceResourceReference)
		if err != nil {
			return nil, err
		}
		sourceResourceReference := sourceResourceReferenceARMID
		result.SourceResourceId = &sourceResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *CreationData) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CreationData{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *CreationData) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.CreationData)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CreationData, got %T", armInput)
	}

	// no assignment for property "SourceResourceReference"

	// No error
	return nil
}

// AssignProperties_From_CreationData populates our CreationData from the provided source CreationData
func (data *CreationData) AssignProperties_From_CreationData(source *storage.CreationData) error {

	// SourceResourceReference
	if source.SourceResourceReference != nil {
		sourceResourceReference := source.SourceResourceReference.Copy()
		data.SourceResourceReference = &sourceResourceReference
	} else {
		data.SourceResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CreationData populates the provided destination CreationData from our CreationData
func (data *CreationData) AssignProperties_To_CreationData(destination *storage.CreationData) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceResourceReference
	if data.SourceResourceReference != nil {
		sourceResourceReference := data.SourceResourceReference.Copy()
		destination.SourceResourceReference = &sourceResourceReference
	} else {
		destination.SourceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Data used when creating a target resource from a source resource.
type CreationData_STATUS struct {
	// SourceResourceId: This is the ARM ID of the source object to be used to create the target object.
	SourceResourceId *string `json:"sourceResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &CreationData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *CreationData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CreationData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *CreationData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CreationData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CreationData_STATUS, got %T", armInput)
	}

	// Set property "SourceResourceId":
	if typedInput.SourceResourceId != nil {
		sourceResourceId := *typedInput.SourceResourceId
		data.SourceResourceId = &sourceResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_CreationData_STATUS populates our CreationData_STATUS from the provided source CreationData_STATUS
func (data *CreationData_STATUS) AssignProperties_From_CreationData_STATUS(source *storage.CreationData_STATUS) error {

	// SourceResourceId
	data.SourceResourceId = genruntime.ClonePointerToString(source.SourceResourceId)

	// No error
	return nil
}

// AssignProperties_To_CreationData_STATUS populates the provided destination CreationData_STATUS from our CreationData_STATUS
func (data *CreationData_STATUS) AssignProperties_To_CreationData_STATUS(destination *storage.CreationData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceResourceId
	destination.SourceResourceId = genruntime.ClonePointerToString(data.SourceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The complex type of the extended location.
type ExtendedLocation struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationTypes `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (location *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if location == nil {
		return nil, nil
	}
	result := &arm.ExtendedLocation{}

	// Set property "Name":
	if location.Name != nil {
		name := *location.Name
		result.Name = &name
	}

	// Set property "Type":
	if location.Type != nil {
		var temp string
		temp = string(*location.Type)
		typeVar := arm.ExtendedLocationTypes(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtendedLocation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtendedLocation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtendedLocation, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExtendedLocationTypes(temp)
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *storage.ExtendedLocation) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, extendedLocationTypes_Values)
		location.Type = &typeTemp
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The complex type of the extended location.
type ExtendedLocation_STATUS struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationTypes_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (location *ExtendedLocation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtendedLocation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (location *ExtendedLocation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtendedLocation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtendedLocation_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		location.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExtendedLocationTypes_STATUS(temp)
		location.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *storage.ExtendedLocation_STATUS) error {

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, extendedLocationTypes_STATUS_Values)
		location.Type = &typeTemp
	} else {
		location.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *storage.ExtendedLocation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	if location.Type != nil {
		typeVar := string(*location.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Different support tiers for AKS managed clusters
// +kubebuilder:validation:Enum={"AKSLongTermSupport","KubernetesOfficial"}
type KubernetesSupportPlan string

const (
	KubernetesSupportPlan_AKSLongTermSupport = KubernetesSupportPlan("AKSLongTermSupport")
	KubernetesSupportPlan_KubernetesOfficial = KubernetesSupportPlan("KubernetesOfficial")
)

// Mapping from string to KubernetesSupportPlan
var kubernetesSupportPlan_Values = map[string]KubernetesSupportPlan{
	"akslongtermsupport": KubernetesSupportPlan_AKSLongTermSupport,
	"kubernetesofficial": KubernetesSupportPlan_KubernetesOfficial,
}

// Different support tiers for AKS managed clusters
type KubernetesSupportPlan_STATUS string

const (
	KubernetesSupportPlan_STATUS_AKSLongTermSupport = KubernetesSupportPlan_STATUS("AKSLongTermSupport")
	KubernetesSupportPlan_STATUS_KubernetesOfficial = KubernetesSupportPlan_STATUS("KubernetesOfficial")
)

// Mapping from string to KubernetesSupportPlan_STATUS
var kubernetesSupportPlan_STATUS_Values = map[string]KubernetesSupportPlan_STATUS{
	"akslongtermsupport": KubernetesSupportPlan_STATUS_AKSLongTermSupport,
	"kubernetesofficial": KubernetesSupportPlan_STATUS_KubernetesOfficial,
}

// AADProfile specifies attributes for Azure Active Directory integration. For more details see [managed AAD on
// AKS](https://docs.microsoft.com/azure/aks/managed-aad).
type ManagedClusterAADProfile struct {
	// AdminGroupObjectIDs: The list of AAD group object IDs that will have admin role of the cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`

	// ClientAppID: (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
	ClientAppID *string `json:"clientAppID,omitempty"`

	// EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	// Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	// ServerAppID: (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
	ServerAppID *string `json:"serverAppID,omitempty"`

	// ServerAppSecret: (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	// TenantID: The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment
	// subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAADProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAADProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAADProfile{}

	// Set property "AdminGroupObjectIDs":
	for _, item := range profile.AdminGroupObjectIDs {
		result.AdminGroupObjectIDs = append(result.AdminGroupObjectIDs, item)
	}

	// Set property "ClientAppID":
	if profile.ClientAppID != nil {
		clientAppID := *profile.ClientAppID
		result.ClientAppID = &clientAppID
	}

	// Set property "EnableAzureRBAC":
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		result.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property "Managed":
	if profile.Managed != nil {
		managed := *profile.Managed
		result.Managed = &managed
	}

	// Set property "ServerAppID":
	if profile.ServerAppID != nil {
		serverAppID := *profile.ServerAppID
		result.ServerAppID = &serverAppID
	}

	// Set property "ServerAppSecret":
	if profile.ServerAppSecret != nil {
		serverAppSecret := *profile.ServerAppSecret
		result.ServerAppSecret = &serverAppSecret
	}

	// Set property "TenantID":
	if profile.TenantID != nil {
		tenantID := *profile.TenantID
		result.TenantID = &tenantID
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAADProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAADProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAADProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAADProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAADProfile, got %T", armInput)
	}

	// Set property "AdminGroupObjectIDs":
	for _, item := range typedInput.AdminGroupObjectIDs {
		profile.AdminGroupObjectIDs = append(profile.AdminGroupObjectIDs, item)
	}

	// Set property "ClientAppID":
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		profile.ClientAppID = &clientAppID
	}

	// Set property "EnableAzureRBAC":
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property "Managed":
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		profile.Managed = &managed
	}

	// Set property "ServerAppID":
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		profile.ServerAppID = &serverAppID
	}

	// Set property "ServerAppSecret":
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		profile.ServerAppSecret = &serverAppSecret
	}

	// Set property "TenantID":
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		profile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAADProfile populates our ManagedClusterAADProfile from the provided source ManagedClusterAADProfile
func (profile *ManagedClusterAADProfile) AssignProperties_From_ManagedClusterAADProfile(source *storage.ManagedClusterAADProfile) error {

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAADProfile populates the provided destination ManagedClusterAADProfile from our ManagedClusterAADProfile
func (profile *ManagedClusterAADProfile) AssignProperties_To_ManagedClusterAADProfile(destination *storage.ManagedClusterAADProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AADProfile specifies attributes for Azure Active Directory integration. For more details see [managed AAD on
// AKS](https://docs.microsoft.com/azure/aks/managed-aad).
type ManagedClusterAADProfile_STATUS struct {
	// AdminGroupObjectIDs: The list of AAD group object IDs that will have admin role of the cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`

	// ClientAppID: (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
	ClientAppID *string `json:"clientAppID,omitempty"`

	// EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	// Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	// ServerAppID: (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
	ServerAppID *string `json:"serverAppID,omitempty"`

	// ServerAppSecret: (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	// TenantID: The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment
	// subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAADProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAADProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAADProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAADProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAADProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAADProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminGroupObjectIDs":
	for _, item := range typedInput.AdminGroupObjectIDs {
		profile.AdminGroupObjectIDs = append(profile.AdminGroupObjectIDs, item)
	}

	// Set property "ClientAppID":
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		profile.ClientAppID = &clientAppID
	}

	// Set property "EnableAzureRBAC":
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property "Managed":
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		profile.Managed = &managed
	}

	// Set property "ServerAppID":
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		profile.ServerAppID = &serverAppID
	}

	// Set property "ServerAppSecret":
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		profile.ServerAppSecret = &serverAppSecret
	}

	// Set property "TenantID":
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		profile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAADProfile_STATUS populates our ManagedClusterAADProfile_STATUS from the provided source ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignProperties_From_ManagedClusterAADProfile_STATUS(source *storage.ManagedClusterAADProfile_STATUS) error {

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAADProfile_STATUS populates the provided destination ManagedClusterAADProfile_STATUS from our ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignProperties_To_ManagedClusterAADProfile_STATUS(destination *storage.ManagedClusterAADProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A Kubernetes add-on profile for a managed cluster.
type ManagedClusterAddonProfile struct {
	// Config: Key-value pairs for configuring an add-on.
	Config map[string]string `json:"config,omitempty"`

	// +kubebuilder:validation:Required
	// Enabled: Whether the add-on is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAddonProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAddonProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAddonProfile{}

	// Set property "Config":
	if profile.Config != nil {
		result.Config = make(map[string]string, len(profile.Config))
		for key, value := range profile.Config {
			result.Config[key] = value
		}
	}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAddonProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAddonProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAddonProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAddonProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAddonProfile, got %T", armInput)
	}

	// Set property "Config":
	if typedInput.Config != nil {
		profile.Config = make(map[string]string, len(typedInput.Config))
		for key, value := range typedInput.Config {
			profile.Config[key] = value
		}
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAddonProfile populates our ManagedClusterAddonProfile from the provided source ManagedClusterAddonProfile
func (profile *ManagedClusterAddonProfile) AssignProperties_From_ManagedClusterAddonProfile(source *storage.ManagedClusterAddonProfile) error {

	// Config
	profile.Config = genruntime.CloneMapOfStringToString(source.Config)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAddonProfile populates the provided destination ManagedClusterAddonProfile from our ManagedClusterAddonProfile
func (profile *ManagedClusterAddonProfile) AssignProperties_To_ManagedClusterAddonProfile(destination *storage.ManagedClusterAddonProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Config
	destination.Config = genruntime.CloneMapOfStringToString(profile.Config)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A Kubernetes add-on profile for a managed cluster.
type ManagedClusterAddonProfile_STATUS struct {
	// Config: Key-value pairs for configuring an add-on.
	Config map[string]string `json:"config,omitempty"`

	// Enabled: Whether the add-on is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Identity: Information of user assigned identity used by this add-on.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAddonProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAddonProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAddonProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAddonProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAddonProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAddonProfile_STATUS, got %T", armInput)
	}

	// Set property "Config":
	if typedInput.Config != nil {
		profile.Config = make(map[string]string, len(typedInput.Config))
		for key, value := range typedInput.Config {
			profile.Config[key] = value
		}
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 UserAssignedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		profile.Identity = &identity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAddonProfile_STATUS populates our ManagedClusterAddonProfile_STATUS from the provided source ManagedClusterAddonProfile_STATUS
func (profile *ManagedClusterAddonProfile_STATUS) AssignProperties_From_ManagedClusterAddonProfile_STATUS(source *storage.ManagedClusterAddonProfile_STATUS) error {

	// Config
	profile.Config = genruntime.CloneMapOfStringToString(source.Config)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity_STATUS
		err := identity.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		profile.Identity = &identity
	} else {
		profile.Identity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAddonProfile_STATUS populates the provided destination ManagedClusterAddonProfile_STATUS from our ManagedClusterAddonProfile_STATUS
func (profile *ManagedClusterAddonProfile_STATUS) AssignProperties_To_ManagedClusterAddonProfile_STATUS(destination *storage.ManagedClusterAddonProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Config
	destination.Config = genruntime.CloneMapOfStringToString(profile.Config)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Identity
	if profile.Identity != nil {
		var identity storage.UserAssignedIdentity_STATUS
		err := profile.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile for the container service agent pool.
type ManagedClusterAgentPoolProfile struct {
	// ArtifactStreamingProfile: Configuration for using artifact streaming on AKS.
	ArtifactStreamingProfile *AgentPoolArtifactStreamingProfile `json:"artifactStreamingProfile,omitempty"`

	// AvailabilityZones: The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType
	// property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`

	// CapacityReservationGroupReference: The fully qualified resource ID of the Capacity Reservation Group to provide virtual
	// machines from a reserved group of Virtual Machines. This is of the form:
	// '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
	// Customers use it to create an agentpool with a specified CRG. For more information see [Capacity
	// Reservation](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview)
	CapacityReservationGroupReference *genruntime.ResourceReference `armReference:"CapacityReservationGroupID" json:"capacityReservationGroupReference,omitempty"`

	// Count: Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive)
	// for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using
	// a snapshot.
	CreationData *CreationData `json:"creationData,omitempty"`

	// EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption. This is only supported on certain VM
	// sizes and in certain Azure regions. For more information, see:
	// https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// EnableFIPS: Whether to use a FIPS-enabled OS. See [Add a FIPS-enabled node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more
	// details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	// EnableNodePublicIP: Whether each node is allocated its own public IP. Some scenarios may require nodes in a node pool to
	// receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to
	// make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP
	// per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	// The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	// EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	// GatewayProfile: Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent pool mode is
	// not Gateway.
	GatewayProfile *AgentPoolGatewayProfile `json:"gatewayProfile,omitempty"`

	// GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile `json:"gpuInstanceProfile,omitempty"`

	// GpuProfile: GPU settings for the Agent Pool.
	GpuProfile *GPUProfile `json:"gpuProfile,omitempty"`

	// HostGroupReference: The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from, used
	// only in creation scenario and not allowed to changed once set. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
	// For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
	HostGroupReference *genruntime.ResourceReference `armReference:"HostGroupID" json:"hostGroupReference,omitempty"`

	// KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig *KubeletConfig `json:"kubeletConfig,omitempty"`

	// KubeletDiskType: Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral
	// storage.
	KubeletDiskType *KubeletDiskType `json:"kubeletDiskType,omitempty"`

	// LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig `json:"linuxOSConfig,omitempty"`

	// LocalDNSProfile: Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve
	// performance and reliability of DNS resolution in an AKS cluster. For more details see aka.ms/aks/localdns.
	LocalDNSProfile *LocalDNSProfile `json:"localDNSProfile,omitempty"`

	// MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	// MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	// MessageOfTheDay: Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be written to
	// /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It must not be specified
	// for Windows nodes. It must be a static string (i.e., will be printed raw and not be executed as a script).
	MessageOfTheDay *string `json:"messageOfTheDay,omitempty"`

	// MinCount: The minimum number of nodes for auto-scaling
	MinCount *int `json:"minCount,omitempty"`

	// Mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional
	// information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
	Mode *AgentPoolMode `json:"mode,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[a-z][a-z0-9]{0,11}$"
	// Name: Unique name of the agent pool profile in the context of the subscription and resource group. Windows agent pool
	// names must be 6 characters or less.
	Name *string `json:"name,omitempty"`

	// NetworkProfile: Network-related settings of an agent pool.
	NetworkProfile *AgentPoolNetworkProfile `json:"networkProfile,omitempty"`

	// NodeCustomizationProfile: Settings to determine the node customization used to provision nodes in a pool.
	NodeCustomizationProfile *NodeCustomizationProfile `json:"nodeCustomizationProfile,omitempty"`

	// NodeInitializationTaints: Taints added on the nodes during creation that will not be reconciled by AKS. These taints
	// will not be reconciled by AKS and can be removed with a kubectl call. This field can be modified after node pool is
	// created, but nodes will not be recreated with new taints until another operation that requires recreation (e.g. node
	// image upgrade) happens. These taints allow for required configuration to run before the node is ready to accept
	// workloads, for example 'key1=value1:NoSchedule' that then can be removed with `kubectl taint nodes node1
	// key1=value1:NoSchedule-`
	NodeInitializationTaints []string `json:"nodeInitializationTaints,omitempty"`

	// NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels,omitempty" serializationType:"explicitEmptyCollection"`

	// NodePublicIPPrefixReference: The public IP prefix ID which VM nodes should use IPs from. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixReference *genruntime.ResourceReference `armReference:"NodePublicIPPrefixID" json:"nodePublicIPPrefixReference,omitempty"`

	// NodeTaints: The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints,omitempty" serializationType:"explicitEmptyCollection"`

	// OrchestratorVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade
	// all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version
	// as the control plane. The node pool minor version must be within two minor versions of the control plane version. The
	// node pool version cannot be greater than the control plane version. For more information see [upgrading a node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`

	// +kubebuilder:validation:Maximum=2048
	// +kubebuilder:validation:Minimum=0
	// OsDiskSizeGB: OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you
	// specify 0, it will apply the default osDisk size according to the vmSize specified.
	OsDiskSizeGB *int `json:"osDiskSizeGB,omitempty"`

	// OsDiskType: The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it
	// and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after
	// creation. For more information see [Ephemeral
	// OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
	OsDiskType *OSDiskType `json:"osDiskType,omitempty"`

	// OsSKU: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019
	// when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
	OsSKU *OSSKU `json:"osSKU,omitempty"`

	// OsType: The operating system type. The default is Linux.
	OsType *ManagedClusterAgentPoolProfile_OsType `json:"osType,omitempty"`

	// PodIPAllocationMode: Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with
	// podSubnetId. The default is 'DynamicIndividual'.
	PodIPAllocationMode *PodIPAllocationMode `json:"podIPAllocationMode,omitempty"`

	// PodSubnetReference: The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically assigned
	// on the node subnet (see vnetSubnetID for more details). This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetReference *genruntime.ResourceReference `armReference:"PodSubnetID" json:"podSubnetReference,omitempty"`

	// PowerState: Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is initially Running.
	// The Agent Pool can be stopped by setting this field to Stopped. A stopped Agent Pool stops all of its VMs and does not
	// accrue billing charges. An Agent Pool can only be stopped if it is Running and provisioning state is Succeeded
	PowerState *PowerState `json:"powerState,omitempty"`

	// ProximityPlacementGroupReference: The ID for Proximity Placement Group.
	ProximityPlacementGroupReference *genruntime.ResourceReference `armReference:"ProximityPlacementGroupID" json:"proximityPlacementGroupReference,omitempty"`

	// ScaleDownMode: The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler
	// behavior. If not specified, it defaults to Delete.
	ScaleDownMode *ScaleDownMode `json:"scaleDownMode,omitempty"`

	// ScaleSetEvictionPolicy: The Virtual Machine Scale Set eviction policy. The eviction policy specifies what to do with the
	// VM when it is evicted. The default is Delete. For more information about eviction see [spot
	// VMs](https://docs.microsoft.com/azure/virtual-machines/spot-vms)
	ScaleSetEvictionPolicy *ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy `json:"scaleSetEvictionPolicy,omitempty"`

	// ScaleSetPriority: The Virtual Machine Scale Set priority.
	ScaleSetPriority *ManagedClusterAgentPoolProfile_ScaleSetPriority `json:"scaleSetPriority,omitempty"`

	// SecurityProfile: The security settings of an agent pool.
	SecurityProfile *AgentPoolSecurityProfile `json:"securityProfile,omitempty"`

	// SpotMaxPrice: The max price (in US Dollars) you are willing to pay for spot instances. Possible values are any decimal
	// value greater than zero or -1 which indicates default price to be up-to on-demand. Possible values are any decimal value
	// greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing,
	// see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	// Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string `json:"tags,omitempty" serializationType:"explicitEmptyCollection"`

	// Type: The type of Agent Pool.
	Type *AgentPoolType `json:"type,omitempty"`

	// UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings `json:"upgradeSettings,omitempty"`

	// UpgradeSettingsBlueGreen: Settings for Blue-Green upgrade on the agentpool. Applies when upgrade strategy is set to
	// BlueGreen.
	UpgradeSettingsBlueGreen *AgentPoolBlueGreenUpgradeSettings `json:"upgradeSettingsBlueGreen,omitempty"`

	// UpgradeStrategy: Defines the upgrade strategy for the agent pool. The default is Rolling.
	UpgradeStrategy *UpgradeStrategy `json:"upgradeStrategy,omitempty"`

	// VirtualMachineNodesStatus: The status of nodes in a VirtualMachines agent pool.
	VirtualMachineNodesStatus []VirtualMachineNodes `json:"virtualMachineNodesStatus,omitempty"`

	// VirtualMachinesProfile: Specifications on VirtualMachines agent pool.
	VirtualMachinesProfile *VirtualMachinesProfile `json:"virtualMachinesProfile,omitempty"`

	// VmSize: The size of the agent pool VMs. VM size availability varies by region. If a node contains insufficient compute
	// resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see:
	// https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	// VnetSubnetReference: The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this is
	// not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and
	// pods, otherwise it applies to just nodes. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetReference *genruntime.ResourceReference `armReference:"VnetSubnetID" json:"vnetSubnetReference,omitempty"`

	// WindowsProfile: The Windows agent pool's specific profile.
	WindowsProfile *AgentPoolWindowsProfile `json:"windowsProfile,omitempty"`

	// WorkloadRuntime: Determines the type of workload a node can run.
	WorkloadRuntime *WorkloadRuntime `json:"workloadRuntime,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAgentPoolProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAgentPoolProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAgentPoolProfile{}

	// Set property "ArtifactStreamingProfile":
	if profile.ArtifactStreamingProfile != nil {
		artifactStreamingProfile_ARM, err := profile.ArtifactStreamingProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		artifactStreamingProfile := *artifactStreamingProfile_ARM.(*arm.AgentPoolArtifactStreamingProfile)
		result.ArtifactStreamingProfile = &artifactStreamingProfile
	}

	// Set property "AvailabilityZones":
	for _, item := range profile.AvailabilityZones {
		result.AvailabilityZones = append(result.AvailabilityZones, item)
	}

	// Set property "CapacityReservationGroupID":
	if profile.CapacityReservationGroupReference != nil {
		capacityReservationGroupReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.CapacityReservationGroupReference)
		if err != nil {
			return nil, err
		}
		capacityReservationGroupReference := capacityReservationGroupReferenceARMID
		result.CapacityReservationGroupID = &capacityReservationGroupReference
	}

	// Set property "Count":
	if profile.Count != nil {
		count := *profile.Count
		result.Count = &count
	}

	// Set property "CreationData":
	if profile.CreationData != nil {
		creationData_ARM, err := profile.CreationData.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		creationData := *creationData_ARM.(*arm.CreationData)
		result.CreationData = &creationData
	}

	// Set property "EnableAutoScaling":
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		result.EnableAutoScaling = &enableAutoScaling
	}

	// Set property "EnableEncryptionAtHost":
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		result.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "EnableFIPS":
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		result.EnableFIPS = &enableFIPS
	}

	// Set property "EnableNodePublicIP":
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		result.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property "EnableUltraSSD":
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		result.EnableUltraSSD = &enableUltraSSD
	}

	// Set property "GatewayProfile":
	if profile.GatewayProfile != nil {
		gatewayProfile_ARM, err := profile.GatewayProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gatewayProfile := *gatewayProfile_ARM.(*arm.AgentPoolGatewayProfile)
		result.GatewayProfile = &gatewayProfile
	}

	// Set property "GpuInstanceProfile":
	if profile.GpuInstanceProfile != nil {
		var temp string
		temp = string(*profile.GpuInstanceProfile)
		gpuInstanceProfile := arm.GPUInstanceProfile(temp)
		result.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property "GpuProfile":
	if profile.GpuProfile != nil {
		gpuProfile_ARM, err := profile.GpuProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gpuProfile := *gpuProfile_ARM.(*arm.GPUProfile)
		result.GpuProfile = &gpuProfile
	}

	// Set property "HostGroupID":
	if profile.HostGroupReference != nil {
		hostGroupReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.HostGroupReference)
		if err != nil {
			return nil, err
		}
		hostGroupReference := hostGroupReferenceARMID
		result.HostGroupID = &hostGroupReference
	}

	// Set property "KubeletConfig":
	if profile.KubeletConfig != nil {
		kubeletConfig_ARM, err := profile.KubeletConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubeletConfig := *kubeletConfig_ARM.(*arm.KubeletConfig)
		result.KubeletConfig = &kubeletConfig
	}

	// Set property "KubeletDiskType":
	if profile.KubeletDiskType != nil {
		var temp string
		temp = string(*profile.KubeletDiskType)
		kubeletDiskType := arm.KubeletDiskType(temp)
		result.KubeletDiskType = &kubeletDiskType
	}

	// Set property "LinuxOSConfig":
	if profile.LinuxOSConfig != nil {
		linuxOSConfig_ARM, err := profile.LinuxOSConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxOSConfig := *linuxOSConfig_ARM.(*arm.LinuxOSConfig)
		result.LinuxOSConfig = &linuxOSConfig
	}

	// Set property "LocalDNSProfile":
	if profile.LocalDNSProfile != nil {
		localDNSProfile_ARM, err := profile.LocalDNSProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		localDNSProfile := *localDNSProfile_ARM.(*arm.LocalDNSProfile)
		result.LocalDNSProfile = &localDNSProfile
	}

	// Set property "MaxCount":
	if profile.MaxCount != nil {
		maxCount := *profile.MaxCount
		result.MaxCount = &maxCount
	}

	// Set property "MaxPods":
	if profile.MaxPods != nil {
		maxPods := *profile.MaxPods
		result.MaxPods = &maxPods
	}

	// Set property "MessageOfTheDay":
	if profile.MessageOfTheDay != nil {
		messageOfTheDay := *profile.MessageOfTheDay
		result.MessageOfTheDay = &messageOfTheDay
	}

	// Set property "MinCount":
	if profile.MinCount != nil {
		minCount := *profile.MinCount
		result.MinCount = &minCount
	}

	// Set property "Mode":
	if profile.Mode != nil {
		var temp string
		temp = string(*profile.Mode)
		mode := arm.AgentPoolMode(temp)
		result.Mode = &mode
	}

	// Set property "Name":
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}

	// Set property "NetworkProfile":
	if profile.NetworkProfile != nil {
		networkProfile_ARM, err := profile.NetworkProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfile_ARM.(*arm.AgentPoolNetworkProfile)
		result.NetworkProfile = &networkProfile
	}

	// Set property "NodeCustomizationProfile":
	if profile.NodeCustomizationProfile != nil {
		nodeCustomizationProfile_ARM, err := profile.NodeCustomizationProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nodeCustomizationProfile := *nodeCustomizationProfile_ARM.(*arm.NodeCustomizationProfile)
		result.NodeCustomizationProfile = &nodeCustomizationProfile
	}

	// Set property "NodeInitializationTaints":
	for _, item := range profile.NodeInitializationTaints {
		result.NodeInitializationTaints = append(result.NodeInitializationTaints, item)
	}

	// Set property "NodeLabels":
	if profile.NodeLabels != nil {
		result.NodeLabels = make(map[string]string, len(profile.NodeLabels))
		for key, value := range profile.NodeLabels {
			result.NodeLabels[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.NodeLabels = make(map[string]string)
	}

	// Set property "NodePublicIPPrefixID":
	if profile.NodePublicIPPrefixReference != nil {
		nodePublicIPPrefixReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.NodePublicIPPrefixReference)
		if err != nil {
			return nil, err
		}
		nodePublicIPPrefixReference := nodePublicIPPrefixReferenceARMID
		result.NodePublicIPPrefixID = &nodePublicIPPrefixReference
	}

	// Set property "NodeTaints":
	for _, item := range profile.NodeTaints {
		result.NodeTaints = append(result.NodeTaints, item)
	}
	if result.NodeTaints == nil {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.NodeTaints = []string{}
	}

	// Set property "OrchestratorVersion":
	if profile.OrchestratorVersion != nil {
		orchestratorVersion := *profile.OrchestratorVersion
		result.OrchestratorVersion = &orchestratorVersion
	}

	// Set property "OsDiskSizeGB":
	if profile.OsDiskSizeGB != nil {
		osDiskSizeGB := *profile.OsDiskSizeGB
		result.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property "OsDiskType":
	if profile.OsDiskType != nil {
		var temp string
		temp = string(*profile.OsDiskType)
		osDiskType := arm.OSDiskType(temp)
		result.OsDiskType = &osDiskType
	}

	// Set property "OsSKU":
	if profile.OsSKU != nil {
		var temp string
		temp = string(*profile.OsSKU)
		osSKU := arm.OSSKU(temp)
		result.OsSKU = &osSKU
	}

	// Set property "OsType":
	if profile.OsType != nil {
		var temp string
		temp = string(*profile.OsType)
		osType := arm.ManagedClusterAgentPoolProfile_OsType(temp)
		result.OsType = &osType
	}

	// Set property "PodIPAllocationMode":
	if profile.PodIPAllocationMode != nil {
		var temp string
		temp = string(*profile.PodIPAllocationMode)
		podIPAllocationMode := arm.PodIPAllocationMode(temp)
		result.PodIPAllocationMode = &podIPAllocationMode
	}

	// Set property "PodSubnetID":
	if profile.PodSubnetReference != nil {
		podSubnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.PodSubnetReference)
		if err != nil {
			return nil, err
		}
		podSubnetReference := podSubnetReferenceARMID
		result.PodSubnetID = &podSubnetReference
	}

	// Set property "PowerState":
	if profile.PowerState != nil {
		powerState_ARM, err := profile.PowerState.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		powerState := *powerState_ARM.(*arm.PowerState)
		result.PowerState = &powerState
	}

	// Set property "ProximityPlacementGroupID":
	if profile.ProximityPlacementGroupReference != nil {
		proximityPlacementGroupReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.ProximityPlacementGroupReference)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroupReference := proximityPlacementGroupReferenceARMID
		result.ProximityPlacementGroupID = &proximityPlacementGroupReference
	}

	// Set property "ScaleDownMode":
	if profile.ScaleDownMode != nil {
		var temp string
		temp = string(*profile.ScaleDownMode)
		scaleDownMode := arm.ScaleDownMode(temp)
		result.ScaleDownMode = &scaleDownMode
	}

	// Set property "ScaleSetEvictionPolicy":
	if profile.ScaleSetEvictionPolicy != nil {
		var temp string
		temp = string(*profile.ScaleSetEvictionPolicy)
		scaleSetEvictionPolicy := arm.ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy(temp)
		result.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property "ScaleSetPriority":
	if profile.ScaleSetPriority != nil {
		var temp string
		temp = string(*profile.ScaleSetPriority)
		scaleSetPriority := arm.ManagedClusterAgentPoolProfile_ScaleSetPriority(temp)
		result.ScaleSetPriority = &scaleSetPriority
	}

	// Set property "SecurityProfile":
	if profile.SecurityProfile != nil {
		securityProfile_ARM, err := profile.SecurityProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfile_ARM.(*arm.AgentPoolSecurityProfile)
		result.SecurityProfile = &securityProfile
	}

	// Set property "SpotMaxPrice":
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		result.SpotMaxPrice = &spotMaxPrice
	}

	// Set property "Tags":
	if profile.Tags != nil {
		result.Tags = make(map[string]string, len(profile.Tags))
		for key, value := range profile.Tags {
			result.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		result.Tags = make(map[string]string)
	}

	// Set property "Type":
	if profile.Type != nil {
		var temp string
		temp = string(*profile.Type)
		typeVar := arm.AgentPoolType(temp)
		result.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	if profile.UpgradeSettings != nil {
		upgradeSettings_ARM, err := profile.UpgradeSettings.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradeSettings := *upgradeSettings_ARM.(*arm.AgentPoolUpgradeSettings)
		result.UpgradeSettings = &upgradeSettings
	}

	// Set property "UpgradeSettingsBlueGreen":
	if profile.UpgradeSettingsBlueGreen != nil {
		upgradeSettingsBlueGreen_ARM, err := profile.UpgradeSettingsBlueGreen.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradeSettingsBlueGreen := *upgradeSettingsBlueGreen_ARM.(*arm.AgentPoolBlueGreenUpgradeSettings)
		result.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	}

	// Set property "UpgradeStrategy":
	if profile.UpgradeStrategy != nil {
		var temp string
		temp = string(*profile.UpgradeStrategy)
		upgradeStrategy := arm.UpgradeStrategy(temp)
		result.UpgradeStrategy = &upgradeStrategy
	}

	// Set property "VirtualMachineNodesStatus":
	for _, item := range profile.VirtualMachineNodesStatus {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualMachineNodesStatus = append(result.VirtualMachineNodesStatus, *item_ARM.(*arm.VirtualMachineNodes))
	}

	// Set property "VirtualMachinesProfile":
	if profile.VirtualMachinesProfile != nil {
		virtualMachinesProfile_ARM, err := profile.VirtualMachinesProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachinesProfile := *virtualMachinesProfile_ARM.(*arm.VirtualMachinesProfile)
		result.VirtualMachinesProfile = &virtualMachinesProfile
	}

	// Set property "VmSize":
	if profile.VmSize != nil {
		vmSize := *profile.VmSize
		result.VmSize = &vmSize
	}

	// Set property "VnetSubnetID":
	if profile.VnetSubnetReference != nil {
		vnetSubnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.VnetSubnetReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetReference := vnetSubnetReferenceARMID
		result.VnetSubnetID = &vnetSubnetReference
	}

	// Set property "WindowsProfile":
	if profile.WindowsProfile != nil {
		windowsProfile_ARM, err := profile.WindowsProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsProfile := *windowsProfile_ARM.(*arm.AgentPoolWindowsProfile)
		result.WindowsProfile = &windowsProfile
	}

	// Set property "WorkloadRuntime":
	if profile.WorkloadRuntime != nil {
		var temp string
		temp = string(*profile.WorkloadRuntime)
		workloadRuntime := arm.WorkloadRuntime(temp)
		result.WorkloadRuntime = &workloadRuntime
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAgentPoolProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAgentPoolProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAgentPoolProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAgentPoolProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAgentPoolProfile, got %T", armInput)
	}

	// Set property "ArtifactStreamingProfile":
	if typedInput.ArtifactStreamingProfile != nil {
		var artifactStreamingProfile1 AgentPoolArtifactStreamingProfile
		err := artifactStreamingProfile1.PopulateFromARM(owner, *typedInput.ArtifactStreamingProfile)
		if err != nil {
			return err
		}
		artifactStreamingProfile := artifactStreamingProfile1
		profile.ArtifactStreamingProfile = &artifactStreamingProfile
	}

	// Set property "AvailabilityZones":
	for _, item := range typedInput.AvailabilityZones {
		profile.AvailabilityZones = append(profile.AvailabilityZones, item)
	}

	// no assignment for property "CapacityReservationGroupReference"

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// Set property "CreationData":
	if typedInput.CreationData != nil {
		var creationData1 CreationData
		err := creationData1.PopulateFromARM(owner, *typedInput.CreationData)
		if err != nil {
			return err
		}
		creationData := creationData1
		profile.CreationData = &creationData
	}

	// Set property "EnableAutoScaling":
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property "EnableEncryptionAtHost":
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "EnableFIPS":
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	}

	// Set property "EnableNodePublicIP":
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property "EnableUltraSSD":
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property "GatewayProfile":
	if typedInput.GatewayProfile != nil {
		var gatewayProfile1 AgentPoolGatewayProfile
		err := gatewayProfile1.PopulateFromARM(owner, *typedInput.GatewayProfile)
		if err != nil {
			return err
		}
		gatewayProfile := gatewayProfile1
		profile.GatewayProfile = &gatewayProfile
	}

	// Set property "GpuInstanceProfile":
	if typedInput.GpuInstanceProfile != nil {
		var temp string
		temp = string(*typedInput.GpuInstanceProfile)
		gpuInstanceProfile := GPUInstanceProfile(temp)
		profile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property "GpuProfile":
	if typedInput.GpuProfile != nil {
		var gpuProfile1 GPUProfile
		err := gpuProfile1.PopulateFromARM(owner, *typedInput.GpuProfile)
		if err != nil {
			return err
		}
		gpuProfile := gpuProfile1
		profile.GpuProfile = &gpuProfile
	}

	// no assignment for property "HostGroupReference"

	// Set property "KubeletConfig":
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		profile.KubeletConfig = &kubeletConfig
	}

	// Set property "KubeletDiskType":
	if typedInput.KubeletDiskType != nil {
		var temp string
		temp = string(*typedInput.KubeletDiskType)
		kubeletDiskType := KubeletDiskType(temp)
		profile.KubeletDiskType = &kubeletDiskType
	}

	// Set property "LinuxOSConfig":
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		profile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property "LocalDNSProfile":
	if typedInput.LocalDNSProfile != nil {
		var localDNSProfile1 LocalDNSProfile
		err := localDNSProfile1.PopulateFromARM(owner, *typedInput.LocalDNSProfile)
		if err != nil {
			return err
		}
		localDNSProfile := localDNSProfile1
		profile.LocalDNSProfile = &localDNSProfile
	}

	// Set property "MaxCount":
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		profile.MaxCount = &maxCount
	}

	// Set property "MaxPods":
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		profile.MaxPods = &maxPods
	}

	// Set property "MessageOfTheDay":
	if typedInput.MessageOfTheDay != nil {
		messageOfTheDay := *typedInput.MessageOfTheDay
		profile.MessageOfTheDay = &messageOfTheDay
	}

	// Set property "MinCount":
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		profile.MinCount = &minCount
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := AgentPoolMode(temp)
		profile.Mode = &mode
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "NetworkProfile":
	if typedInput.NetworkProfile != nil {
		var networkProfile1 AgentPoolNetworkProfile
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property "NodeCustomizationProfile":
	if typedInput.NodeCustomizationProfile != nil {
		var nodeCustomizationProfile1 NodeCustomizationProfile
		err := nodeCustomizationProfile1.PopulateFromARM(owner, *typedInput.NodeCustomizationProfile)
		if err != nil {
			return err
		}
		nodeCustomizationProfile := nodeCustomizationProfile1
		profile.NodeCustomizationProfile = &nodeCustomizationProfile
	}

	// Set property "NodeInitializationTaints":
	for _, item := range typedInput.NodeInitializationTaints {
		profile.NodeInitializationTaints = append(profile.NodeInitializationTaints, item)
	}

	// Set property "NodeLabels":
	if typedInput.NodeLabels != nil {
		profile.NodeLabels = make(map[string]string, len(typedInput.NodeLabels))
		for key, value := range typedInput.NodeLabels {
			profile.NodeLabels[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		profile.NodeLabels = make(map[string]string)
	}

	// no assignment for property "NodePublicIPPrefixReference"

	// Set property "NodeTaints":
	for _, item := range typedInput.NodeTaints {
		profile.NodeTaints = append(profile.NodeTaints, item)
	}
	if profile.NodeTaints == nil {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		profile.NodeTaints = []string{}
	}

	// Set property "OrchestratorVersion":
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		profile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property "OsDiskSizeGB":
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		profile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property "OsDiskType":
	if typedInput.OsDiskType != nil {
		var temp string
		temp = string(*typedInput.OsDiskType)
		osDiskType := OSDiskType(temp)
		profile.OsDiskType = &osDiskType
	}

	// Set property "OsSKU":
	if typedInput.OsSKU != nil {
		var temp string
		temp = string(*typedInput.OsSKU)
		osSKU := OSSKU(temp)
		profile.OsSKU = &osSKU
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := ManagedClusterAgentPoolProfile_OsType(temp)
		profile.OsType = &osType
	}

	// Set property "PodIPAllocationMode":
	if typedInput.PodIPAllocationMode != nil {
		var temp string
		temp = string(*typedInput.PodIPAllocationMode)
		podIPAllocationMode := PodIPAllocationMode(temp)
		profile.PodIPAllocationMode = &podIPAllocationMode
	}

	// no assignment for property "PodSubnetReference"

	// Set property "PowerState":
	if typedInput.PowerState != nil {
		var powerState1 PowerState
		err := powerState1.PopulateFromARM(owner, *typedInput.PowerState)
		if err != nil {
			return err
		}
		powerState := powerState1
		profile.PowerState = &powerState
	}

	// no assignment for property "ProximityPlacementGroupReference"

	// Set property "ScaleDownMode":
	if typedInput.ScaleDownMode != nil {
		var temp string
		temp = string(*typedInput.ScaleDownMode)
		scaleDownMode := ScaleDownMode(temp)
		profile.ScaleDownMode = &scaleDownMode
	}

	// Set property "ScaleSetEvictionPolicy":
	if typedInput.ScaleSetEvictionPolicy != nil {
		var temp string
		temp = string(*typedInput.ScaleSetEvictionPolicy)
		scaleSetEvictionPolicy := ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy(temp)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property "ScaleSetPriority":
	if typedInput.ScaleSetPriority != nil {
		var temp string
		temp = string(*typedInput.ScaleSetPriority)
		scaleSetPriority := ManagedClusterAgentPoolProfile_ScaleSetPriority(temp)
		profile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 AgentPoolSecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property "SpotMaxPrice":
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	} else {
		// Set property to empty map, as this resource is set to serialize all collections explicitly
		profile.Tags = make(map[string]string)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := AgentPoolType(temp)
		profile.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		profile.UpgradeSettings = &upgradeSettings
	}

	// Set property "UpgradeSettingsBlueGreen":
	if typedInput.UpgradeSettingsBlueGreen != nil {
		var upgradeSettingsBlueGreen1 AgentPoolBlueGreenUpgradeSettings
		err := upgradeSettingsBlueGreen1.PopulateFromARM(owner, *typedInput.UpgradeSettingsBlueGreen)
		if err != nil {
			return err
		}
		upgradeSettingsBlueGreen := upgradeSettingsBlueGreen1
		profile.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	}

	// Set property "UpgradeStrategy":
	if typedInput.UpgradeStrategy != nil {
		var temp string
		temp = string(*typedInput.UpgradeStrategy)
		upgradeStrategy := UpgradeStrategy(temp)
		profile.UpgradeStrategy = &upgradeStrategy
	}

	// Set property "VirtualMachineNodesStatus":
	for _, item := range typedInput.VirtualMachineNodesStatus {
		var item1 VirtualMachineNodes
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.VirtualMachineNodesStatus = append(profile.VirtualMachineNodesStatus, item1)
	}

	// Set property "VirtualMachinesProfile":
	if typedInput.VirtualMachinesProfile != nil {
		var virtualMachinesProfile1 VirtualMachinesProfile
		err := virtualMachinesProfile1.PopulateFromARM(owner, *typedInput.VirtualMachinesProfile)
		if err != nil {
			return err
		}
		virtualMachinesProfile := virtualMachinesProfile1
		profile.VirtualMachinesProfile = &virtualMachinesProfile
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// no assignment for property "VnetSubnetReference"

	// Set property "WindowsProfile":
	if typedInput.WindowsProfile != nil {
		var windowsProfile1 AgentPoolWindowsProfile
		err := windowsProfile1.PopulateFromARM(owner, *typedInput.WindowsProfile)
		if err != nil {
			return err
		}
		windowsProfile := windowsProfile1
		profile.WindowsProfile = &windowsProfile
	}

	// Set property "WorkloadRuntime":
	if typedInput.WorkloadRuntime != nil {
		var temp string
		temp = string(*typedInput.WorkloadRuntime)
		workloadRuntime := WorkloadRuntime(temp)
		profile.WorkloadRuntime = &workloadRuntime
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAgentPoolProfile populates our ManagedClusterAgentPoolProfile from the provided source ManagedClusterAgentPoolProfile
func (profile *ManagedClusterAgentPoolProfile) AssignProperties_From_ManagedClusterAgentPoolProfile(source *storage.ManagedClusterAgentPoolProfile) error {

	// ArtifactStreamingProfile
	if source.ArtifactStreamingProfile != nil {
		var artifactStreamingProfile AgentPoolArtifactStreamingProfile
		err := artifactStreamingProfile.AssignProperties_From_AgentPoolArtifactStreamingProfile(source.ArtifactStreamingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolArtifactStreamingProfile() to populate field ArtifactStreamingProfile")
		}
		profile.ArtifactStreamingProfile = &artifactStreamingProfile
	} else {
		profile.ArtifactStreamingProfile = nil
	}

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// CapacityReservationGroupReference
	if source.CapacityReservationGroupReference != nil {
		capacityReservationGroupReference := source.CapacityReservationGroupReference.Copy()
		profile.CapacityReservationGroupReference = &capacityReservationGroupReference
	} else {
		profile.CapacityReservationGroupReference = nil
	}

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// CreationData
	if source.CreationData != nil {
		var creationDatum CreationData
		err := creationDatum.AssignProperties_From_CreationData(source.CreationData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CreationData() to populate field CreationData")
		}
		profile.CreationData = &creationDatum
	} else {
		profile.CreationData = nil
	}

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GatewayProfile
	if source.GatewayProfile != nil {
		var gatewayProfile AgentPoolGatewayProfile
		err := gatewayProfile.AssignProperties_From_AgentPoolGatewayProfile(source.GatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolGatewayProfile() to populate field GatewayProfile")
		}
		profile.GatewayProfile = &gatewayProfile
	} else {
		profile.GatewayProfile = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := *source.GpuInstanceProfile
		gpuInstanceProfileTemp := genruntime.ToEnum(gpuInstanceProfile, gPUInstanceProfile_Values)
		profile.GpuInstanceProfile = &gpuInstanceProfileTemp
	} else {
		profile.GpuInstanceProfile = nil
	}

	// GpuProfile
	if source.GpuProfile != nil {
		var gpuProfile GPUProfile
		err := gpuProfile.AssignProperties_From_GPUProfile(source.GpuProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GPUProfile() to populate field GpuProfile")
		}
		profile.GpuProfile = &gpuProfile
	} else {
		profile.GpuProfile = nil
	}

	// HostGroupReference
	if source.HostGroupReference != nil {
		hostGroupReference := source.HostGroupReference.Copy()
		profile.HostGroupReference = &hostGroupReference
	} else {
		profile.HostGroupReference = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig
		err := kubeletConfig.AssignProperties_From_KubeletConfig(source.KubeletConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KubeletConfig() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := *source.KubeletDiskType
		kubeletDiskTypeTemp := genruntime.ToEnum(kubeletDiskType, kubeletDiskType_Values)
		profile.KubeletDiskType = &kubeletDiskTypeTemp
	} else {
		profile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig
		err := linuxOSConfig.AssignProperties_From_LinuxOSConfig(source.LinuxOSConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LinuxOSConfig() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// LocalDNSProfile
	if source.LocalDNSProfile != nil {
		var localDNSProfile LocalDNSProfile
		err := localDNSProfile.AssignProperties_From_LocalDNSProfile(source.LocalDNSProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LocalDNSProfile() to populate field LocalDNSProfile")
		}
		profile.LocalDNSProfile = &localDNSProfile
	} else {
		profile.LocalDNSProfile = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MessageOfTheDay
	profile.MessageOfTheDay = genruntime.ClonePointerToString(source.MessageOfTheDay)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, agentPoolMode_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile AgentPoolNetworkProfile
		err := networkProfile.AssignProperties_From_AgentPoolNetworkProfile(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolNetworkProfile() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// NodeCustomizationProfile
	if source.NodeCustomizationProfile != nil {
		var nodeCustomizationProfile NodeCustomizationProfile
		err := nodeCustomizationProfile.AssignProperties_From_NodeCustomizationProfile(source.NodeCustomizationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodeCustomizationProfile() to populate field NodeCustomizationProfile")
		}
		profile.NodeCustomizationProfile = &nodeCustomizationProfile
	} else {
		profile.NodeCustomizationProfile = nil
	}

	// NodeInitializationTaints
	profile.NodeInitializationTaints = genruntime.CloneSliceOfString(source.NodeInitializationTaints)

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixReference
	if source.NodePublicIPPrefixReference != nil {
		nodePublicIPPrefixReference := source.NodePublicIPPrefixReference.Copy()
		profile.NodePublicIPPrefixReference = &nodePublicIPPrefixReference
	} else {
		profile.NodePublicIPPrefixReference = nil
	}

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	profile.OsDiskSizeGB = genruntime.ClonePointerToInt(source.OsDiskSizeGB)

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := *source.OsDiskType
		osDiskTypeTemp := genruntime.ToEnum(osDiskType, oSDiskType_Values)
		profile.OsDiskType = &osDiskTypeTemp
	} else {
		profile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := *source.OsSKU
		osSKUTemp := genruntime.ToEnum(osSKU, oSSKU_Values)
		profile.OsSKU = &osSKUTemp
	} else {
		profile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, managedClusterAgentPoolProfile_OsType_Values)
		profile.OsType = &osTypeTemp
	} else {
		profile.OsType = nil
	}

	// PodIPAllocationMode
	if source.PodIPAllocationMode != nil {
		podIPAllocationMode := *source.PodIPAllocationMode
		podIPAllocationModeTemp := genruntime.ToEnum(podIPAllocationMode, podIPAllocationMode_Values)
		profile.PodIPAllocationMode = &podIPAllocationModeTemp
	} else {
		profile.PodIPAllocationMode = nil
	}

	// PodSubnetReference
	if source.PodSubnetReference != nil {
		podSubnetReference := source.PodSubnetReference.Copy()
		profile.PodSubnetReference = &podSubnetReference
	} else {
		profile.PodSubnetReference = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState
		err := powerState.AssignProperties_From_PowerState(source.PowerState)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PowerState() to populate field PowerState")
		}
		profile.PowerState = &powerState
	} else {
		profile.PowerState = nil
	}

	// ProximityPlacementGroupReference
	if source.ProximityPlacementGroupReference != nil {
		proximityPlacementGroupReference := source.ProximityPlacementGroupReference.Copy()
		profile.ProximityPlacementGroupReference = &proximityPlacementGroupReference
	} else {
		profile.ProximityPlacementGroupReference = nil
	}

	// ScaleDownMode
	if source.ScaleDownMode != nil {
		scaleDownMode := *source.ScaleDownMode
		scaleDownModeTemp := genruntime.ToEnum(scaleDownMode, scaleDownMode_Values)
		profile.ScaleDownMode = &scaleDownModeTemp
	} else {
		profile.ScaleDownMode = nil
	}

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *source.ScaleSetEvictionPolicy
		scaleSetEvictionPolicyTemp := genruntime.ToEnum(scaleSetEvictionPolicy, managedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Values)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicyTemp
	} else {
		profile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := *source.ScaleSetPriority
		scaleSetPriorityTemp := genruntime.ToEnum(scaleSetPriority, managedClusterAgentPoolProfile_ScaleSetPriority_Values)
		profile.ScaleSetPriority = &scaleSetPriorityTemp
	} else {
		profile.ScaleSetPriority = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile AgentPoolSecurityProfile
		err := securityProfile.AssignProperties_From_AgentPoolSecurityProfile(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolSecurityProfile() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, agentPoolType_Values)
		profile.Type = &typeTemp
	} else {
		profile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings
		err := upgradeSetting.AssignProperties_From_AgentPoolUpgradeSettings(source.UpgradeSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolUpgradeSettings() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// UpgradeSettingsBlueGreen
	if source.UpgradeSettingsBlueGreen != nil {
		var upgradeSettingsBlueGreen AgentPoolBlueGreenUpgradeSettings
		err := upgradeSettingsBlueGreen.AssignProperties_From_AgentPoolBlueGreenUpgradeSettings(source.UpgradeSettingsBlueGreen)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolBlueGreenUpgradeSettings() to populate field UpgradeSettingsBlueGreen")
		}
		profile.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	} else {
		profile.UpgradeSettingsBlueGreen = nil
	}

	// UpgradeStrategy
	if source.UpgradeStrategy != nil {
		upgradeStrategy := *source.UpgradeStrategy
		upgradeStrategyTemp := genruntime.ToEnum(upgradeStrategy, upgradeStrategy_Values)
		profile.UpgradeStrategy = &upgradeStrategyTemp
	} else {
		profile.UpgradeStrategy = nil
	}

	// VirtualMachineNodesStatus
	if source.VirtualMachineNodesStatus != nil {
		virtualMachineNodesStatusList := make([]VirtualMachineNodes, len(source.VirtualMachineNodesStatus))
		for virtualMachineNodesStatusIndex, virtualMachineNodesStatusItem := range source.VirtualMachineNodesStatus {
			var virtualMachineNodesStatus VirtualMachineNodes
			err := virtualMachineNodesStatus.AssignProperties_From_VirtualMachineNodes(&virtualMachineNodesStatusItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineNodes() to populate field VirtualMachineNodesStatus")
			}
			virtualMachineNodesStatusList[virtualMachineNodesStatusIndex] = virtualMachineNodesStatus
		}
		profile.VirtualMachineNodesStatus = virtualMachineNodesStatusList
	} else {
		profile.VirtualMachineNodesStatus = nil
	}

	// VirtualMachinesProfile
	if source.VirtualMachinesProfile != nil {
		var virtualMachinesProfile VirtualMachinesProfile
		err := virtualMachinesProfile.AssignProperties_From_VirtualMachinesProfile(source.VirtualMachinesProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachinesProfile() to populate field VirtualMachinesProfile")
		}
		profile.VirtualMachinesProfile = &virtualMachinesProfile
	} else {
		profile.VirtualMachinesProfile = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetReference
	if source.VnetSubnetReference != nil {
		vnetSubnetReference := source.VnetSubnetReference.Copy()
		profile.VnetSubnetReference = &vnetSubnetReference
	} else {
		profile.VnetSubnetReference = nil
	}

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile AgentPoolWindowsProfile
		err := windowsProfile.AssignProperties_From_AgentPoolWindowsProfile(source.WindowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolWindowsProfile() to populate field WindowsProfile")
		}
		profile.WindowsProfile = &windowsProfile
	} else {
		profile.WindowsProfile = nil
	}

	// WorkloadRuntime
	if source.WorkloadRuntime != nil {
		workloadRuntime := *source.WorkloadRuntime
		workloadRuntimeTemp := genruntime.ToEnum(workloadRuntime, workloadRuntime_Values)
		profile.WorkloadRuntime = &workloadRuntimeTemp
	} else {
		profile.WorkloadRuntime = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAgentPoolProfile populates the provided destination ManagedClusterAgentPoolProfile from our ManagedClusterAgentPoolProfile
func (profile *ManagedClusterAgentPoolProfile) AssignProperties_To_ManagedClusterAgentPoolProfile(destination *storage.ManagedClusterAgentPoolProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArtifactStreamingProfile
	if profile.ArtifactStreamingProfile != nil {
		var artifactStreamingProfile storage.AgentPoolArtifactStreamingProfile
		err := profile.ArtifactStreamingProfile.AssignProperties_To_AgentPoolArtifactStreamingProfile(&artifactStreamingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolArtifactStreamingProfile() to populate field ArtifactStreamingProfile")
		}
		destination.ArtifactStreamingProfile = &artifactStreamingProfile
	} else {
		destination.ArtifactStreamingProfile = nil
	}

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// CapacityReservationGroupReference
	if profile.CapacityReservationGroupReference != nil {
		capacityReservationGroupReference := profile.CapacityReservationGroupReference.Copy()
		destination.CapacityReservationGroupReference = &capacityReservationGroupReference
	} else {
		destination.CapacityReservationGroupReference = nil
	}

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// CreationData
	if profile.CreationData != nil {
		var creationDatum storage.CreationData
		err := profile.CreationData.AssignProperties_To_CreationData(&creationDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CreationData() to populate field CreationData")
		}
		destination.CreationData = &creationDatum
	} else {
		destination.CreationData = nil
	}

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GatewayProfile
	if profile.GatewayProfile != nil {
		var gatewayProfile storage.AgentPoolGatewayProfile
		err := profile.GatewayProfile.AssignProperties_To_AgentPoolGatewayProfile(&gatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolGatewayProfile() to populate field GatewayProfile")
		}
		destination.GatewayProfile = &gatewayProfile
	} else {
		destination.GatewayProfile = nil
	}

	// GpuInstanceProfile
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*profile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// GpuProfile
	if profile.GpuProfile != nil {
		var gpuProfile storage.GPUProfile
		err := profile.GpuProfile.AssignProperties_To_GPUProfile(&gpuProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GPUProfile() to populate field GpuProfile")
		}
		destination.GpuProfile = &gpuProfile
	} else {
		destination.GpuProfile = nil
	}

	// HostGroupReference
	if profile.HostGroupReference != nil {
		hostGroupReference := profile.HostGroupReference.Copy()
		destination.HostGroupReference = &hostGroupReference
	} else {
		destination.HostGroupReference = nil
	}

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig storage.KubeletConfig
		err := profile.KubeletConfig.AssignProperties_To_KubeletConfig(&kubeletConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KubeletConfig() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if profile.KubeletDiskType != nil {
		kubeletDiskType := string(*profile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig storage.LinuxOSConfig
		err := profile.LinuxOSConfig.AssignProperties_To_LinuxOSConfig(&linuxOSConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LinuxOSConfig() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// LocalDNSProfile
	if profile.LocalDNSProfile != nil {
		var localDNSProfile storage.LocalDNSProfile
		err := profile.LocalDNSProfile.AssignProperties_To_LocalDNSProfile(&localDNSProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LocalDNSProfile() to populate field LocalDNSProfile")
		}
		destination.LocalDNSProfile = &localDNSProfile
	} else {
		destination.LocalDNSProfile = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MessageOfTheDay
	destination.MessageOfTheDay = genruntime.ClonePointerToString(profile.MessageOfTheDay)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile storage.AgentPoolNetworkProfile
		err := profile.NetworkProfile.AssignProperties_To_AgentPoolNetworkProfile(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeCustomizationProfile
	if profile.NodeCustomizationProfile != nil {
		var nodeCustomizationProfile storage.NodeCustomizationProfile
		err := profile.NodeCustomizationProfile.AssignProperties_To_NodeCustomizationProfile(&nodeCustomizationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodeCustomizationProfile() to populate field NodeCustomizationProfile")
		}
		destination.NodeCustomizationProfile = &nodeCustomizationProfile
	} else {
		destination.NodeCustomizationProfile = nil
	}

	// NodeInitializationTaints
	destination.NodeInitializationTaints = genruntime.CloneSliceOfString(profile.NodeInitializationTaints)

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixReference
	if profile.NodePublicIPPrefixReference != nil {
		nodePublicIPPrefixReference := profile.NodePublicIPPrefixReference.Copy()
		destination.NodePublicIPPrefixReference = &nodePublicIPPrefixReference
	} else {
		destination.NodePublicIPPrefixReference = nil
	}

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	destination.OsDiskSizeGB = genruntime.ClonePointerToInt(profile.OsDiskSizeGB)

	// OsDiskType
	if profile.OsDiskType != nil {
		osDiskType := string(*profile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if profile.OsSKU != nil {
		osSKU := string(*profile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if profile.OsType != nil {
		osType := string(*profile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodIPAllocationMode
	if profile.PodIPAllocationMode != nil {
		podIPAllocationMode := string(*profile.PodIPAllocationMode)
		destination.PodIPAllocationMode = &podIPAllocationMode
	} else {
		destination.PodIPAllocationMode = nil
	}

	// PodSubnetReference
	if profile.PodSubnetReference != nil {
		podSubnetReference := profile.PodSubnetReference.Copy()
		destination.PodSubnetReference = &podSubnetReference
	} else {
		destination.PodSubnetReference = nil
	}

	// PowerState
	if profile.PowerState != nil {
		var powerState storage.PowerState
		err := profile.PowerState.AssignProperties_To_PowerState(&powerState)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PowerState() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// ProximityPlacementGroupReference
	if profile.ProximityPlacementGroupReference != nil {
		proximityPlacementGroupReference := profile.ProximityPlacementGroupReference.Copy()
		destination.ProximityPlacementGroupReference = &proximityPlacementGroupReference
	} else {
		destination.ProximityPlacementGroupReference = nil
	}

	// ScaleDownMode
	if profile.ScaleDownMode != nil {
		scaleDownMode := string(*profile.ScaleDownMode)
		destination.ScaleDownMode = &scaleDownMode
	} else {
		destination.ScaleDownMode = nil
	}

	// ScaleSetEvictionPolicy
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*profile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := string(*profile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile storage.AgentPoolSecurityProfile
		err := profile.SecurityProfile.AssignProperties_To_AgentPoolSecurityProfile(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting storage.AgentPoolUpgradeSettings
		err := profile.UpgradeSettings.AssignProperties_To_AgentPoolUpgradeSettings(&upgradeSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolUpgradeSettings() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// UpgradeSettingsBlueGreen
	if profile.UpgradeSettingsBlueGreen != nil {
		var upgradeSettingsBlueGreen storage.AgentPoolBlueGreenUpgradeSettings
		err := profile.UpgradeSettingsBlueGreen.AssignProperties_To_AgentPoolBlueGreenUpgradeSettings(&upgradeSettingsBlueGreen)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolBlueGreenUpgradeSettings() to populate field UpgradeSettingsBlueGreen")
		}
		destination.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	} else {
		destination.UpgradeSettingsBlueGreen = nil
	}

	// UpgradeStrategy
	if profile.UpgradeStrategy != nil {
		upgradeStrategy := string(*profile.UpgradeStrategy)
		destination.UpgradeStrategy = &upgradeStrategy
	} else {
		destination.UpgradeStrategy = nil
	}

	// VirtualMachineNodesStatus
	if profile.VirtualMachineNodesStatus != nil {
		virtualMachineNodesStatusList := make([]storage.VirtualMachineNodes, len(profile.VirtualMachineNodesStatus))
		for virtualMachineNodesStatusIndex, virtualMachineNodesStatusItem := range profile.VirtualMachineNodesStatus {
			var virtualMachineNodesStatus storage.VirtualMachineNodes
			err := virtualMachineNodesStatusItem.AssignProperties_To_VirtualMachineNodes(&virtualMachineNodesStatus)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineNodes() to populate field VirtualMachineNodesStatus")
			}
			virtualMachineNodesStatusList[virtualMachineNodesStatusIndex] = virtualMachineNodesStatus
		}
		destination.VirtualMachineNodesStatus = virtualMachineNodesStatusList
	} else {
		destination.VirtualMachineNodesStatus = nil
	}

	// VirtualMachinesProfile
	if profile.VirtualMachinesProfile != nil {
		var virtualMachinesProfile storage.VirtualMachinesProfile
		err := profile.VirtualMachinesProfile.AssignProperties_To_VirtualMachinesProfile(&virtualMachinesProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachinesProfile() to populate field VirtualMachinesProfile")
		}
		destination.VirtualMachinesProfile = &virtualMachinesProfile
	} else {
		destination.VirtualMachinesProfile = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetReference
	if profile.VnetSubnetReference != nil {
		vnetSubnetReference := profile.VnetSubnetReference.Copy()
		destination.VnetSubnetReference = &vnetSubnetReference
	} else {
		destination.VnetSubnetReference = nil
	}

	// WindowsProfile
	if profile.WindowsProfile != nil {
		var windowsProfile storage.AgentPoolWindowsProfile
		err := profile.WindowsProfile.AssignProperties_To_AgentPoolWindowsProfile(&windowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolWindowsProfile() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// WorkloadRuntime
	if profile.WorkloadRuntime != nil {
		workloadRuntime := string(*profile.WorkloadRuntime)
		destination.WorkloadRuntime = &workloadRuntime
	} else {
		destination.WorkloadRuntime = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile for the container service agent pool.
type ManagedClusterAgentPoolProfile_STATUS struct {
	// ArtifactStreamingProfile: Configuration for using artifact streaming on AKS.
	ArtifactStreamingProfile *AgentPoolArtifactStreamingProfile_STATUS `json:"artifactStreamingProfile,omitempty"`

	// AvailabilityZones: The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType
	// property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`

	// CapacityReservationGroupID: The fully qualified resource ID of the Capacity Reservation Group to provide virtual
	// machines from a reserved group of Virtual Machines. This is of the form:
	// '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Compute/capacityreservationgroups/{capacityReservationGroupName}'
	// Customers use it to create an agentpool with a specified CRG. For more information see [Capacity
	// Reservation](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-overview)
	CapacityReservationGroupID *string `json:"capacityReservationGroupID,omitempty"`

	// Count: Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive)
	// for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	// CreationData: CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using
	// a snapshot.
	CreationData *CreationData_STATUS `json:"creationData,omitempty"`

	// CurrentOrchestratorVersion: The version of Kubernetes the Agent Pool is running. If orchestratorVersion is a fully
	// specified version <major.minor.patch>, this field will be exactly equal to it. If orchestratorVersion is <major.minor>,
	// this field will contain the full <major.minor.patch> version being used.
	CurrentOrchestratorVersion *string `json:"currentOrchestratorVersion,omitempty"`

	// ETag: Unique read-only string used to implement optimistic concurrency. The eTag value will change when the resource is
	// updated. Specify an if-match or if-none-match header with the eTag value for a subsequent request to enable optimistic
	// concurrency per the normal eTag convention.
	ETag *string `json:"eTag,omitempty"`

	// EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption. This is only supported on certain VM
	// sizes and in certain Azure regions. For more information, see:
	// https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// EnableFIPS: Whether to use a FIPS-enabled OS. See [Add a FIPS-enabled node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more
	// details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	// EnableNodePublicIP: Whether each node is allocated its own public IP. Some scenarios may require nodes in a node pool to
	// receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to
	// make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP
	// per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	// The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	// EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	// GatewayProfile: Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent pool mode is
	// not Gateway.
	GatewayProfile *AgentPoolGatewayProfile_STATUS `json:"gatewayProfile,omitempty"`

	// GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
	GpuInstanceProfile *GPUInstanceProfile_STATUS `json:"gpuInstanceProfile,omitempty"`

	// GpuProfile: GPU settings for the Agent Pool.
	GpuProfile *GPUProfile_STATUS `json:"gpuProfile,omitempty"`

	// HostGroupID: The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from, used only
	// in creation scenario and not allowed to changed once set. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
	// For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
	HostGroupID *string `json:"hostGroupID,omitempty"`

	// KubeletConfig: The Kubelet configuration on the agent pool nodes.
	KubeletConfig *KubeletConfig_STATUS `json:"kubeletConfig,omitempty"`

	// KubeletDiskType: Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral
	// storage.
	KubeletDiskType *KubeletDiskType_STATUS `json:"kubeletDiskType,omitempty"`

	// LinuxOSConfig: The OS configuration of Linux agent nodes.
	LinuxOSConfig *LinuxOSConfig_STATUS `json:"linuxOSConfig,omitempty"`

	// LocalDNSProfile: Configures the per-node local DNS, with VnetDNS and KubeDNS overrides. LocalDNS helps improve
	// performance and reliability of DNS resolution in an AKS cluster. For more details see aka.ms/aks/localdns.
	LocalDNSProfile *LocalDNSProfile_STATUS `json:"localDNSProfile,omitempty"`

	// MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	// MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	// MessageOfTheDay: Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be written to
	// /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It must not be specified
	// for Windows nodes. It must be a static string (i.e., will be printed raw and not be executed as a script).
	MessageOfTheDay *string `json:"messageOfTheDay,omitempty"`

	// MinCount: The minimum number of nodes for auto-scaling
	MinCount *int `json:"minCount,omitempty"`

	// Mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional
	// information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
	Mode *AgentPoolMode_STATUS `json:"mode,omitempty"`

	// Name: Unique name of the agent pool profile in the context of the subscription and resource group. Windows agent pool
	// names must be 6 characters or less.
	Name *string `json:"name,omitempty"`

	// NetworkProfile: Network-related settings of an agent pool.
	NetworkProfile *AgentPoolNetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// NodeCustomizationProfile: Settings to determine the node customization used to provision nodes in a pool.
	NodeCustomizationProfile *NodeCustomizationProfile_STATUS `json:"nodeCustomizationProfile,omitempty"`

	// NodeImageVersion: The version of node image
	NodeImageVersion *string `json:"nodeImageVersion,omitempty"`

	// NodeInitializationTaints: Taints added on the nodes during creation that will not be reconciled by AKS. These taints
	// will not be reconciled by AKS and can be removed with a kubectl call. This field can be modified after node pool is
	// created, but nodes will not be recreated with new taints until another operation that requires recreation (e.g. node
	// image upgrade) happens. These taints allow for required configuration to run before the node is ready to accept
	// workloads, for example 'key1=value1:NoSchedule' that then can be removed with `kubectl taint nodes node1
	// key1=value1:NoSchedule-`
	NodeInitializationTaints []string `json:"nodeInitializationTaints,omitempty"`

	// NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels,omitempty"`

	// NodePublicIPPrefixID: The public IP prefix ID which VM nodes should use IPs from. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixID *string `json:"nodePublicIPPrefixID,omitempty"`

	// NodeTaints: The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints,omitempty"`

	// OrchestratorVersion: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g.
	// 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch
	// version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x
	// -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade
	// all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version
	// as the control plane. The node pool minor version must be within two minor versions of the control plane version. The
	// node pool version cannot be greater than the control plane version. For more information see [upgrading a node
	// pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`

	// OsDiskSizeGB: OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you
	// specify 0, it will apply the default osDisk size according to the vmSize specified.
	OsDiskSizeGB *int `json:"osDiskSizeGB,omitempty"`

	// OsDiskType: The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it
	// and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after
	// creation. For more information see [Ephemeral
	// OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
	OsDiskType *OSDiskType_STATUS `json:"osDiskType,omitempty"`

	// OsSKU: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019
	// when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
	OsSKU *OSSKU_STATUS `json:"osSKU,omitempty"`

	// OsType: The operating system type. The default is Linux.
	OsType *ManagedClusterAgentPoolProfile_OsType_STATUS `json:"osType,omitempty"`

	// PodIPAllocationMode: Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with
	// podSubnetId. The default is 'DynamicIndividual'.
	PodIPAllocationMode *PodIPAllocationMode_STATUS `json:"podIPAllocationMode,omitempty"`

	// PodSubnetID: The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically assigned on the
	// node subnet (see vnetSubnetID for more details). This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetID *string `json:"podSubnetID,omitempty"`

	// PowerState: Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is initially Running.
	// The Agent Pool can be stopped by setting this field to Stopped. A stopped Agent Pool stops all of its VMs and does not
	// accrue billing charges. An Agent Pool can only be stopped if it is Running and provisioning state is Succeeded
	PowerState *PowerState_STATUS `json:"powerState,omitempty"`

	// ProvisioningState: The current deployment or provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	// ScaleDownMode: The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler
	// behavior. If not specified, it defaults to Delete.
	ScaleDownMode *ScaleDownMode_STATUS `json:"scaleDownMode,omitempty"`

	// ScaleSetEvictionPolicy: The Virtual Machine Scale Set eviction policy. The eviction policy specifies what to do with the
	// VM when it is evicted. The default is Delete. For more information about eviction see [spot
	// VMs](https://docs.microsoft.com/azure/virtual-machines/spot-vms)
	ScaleSetEvictionPolicy *ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS `json:"scaleSetEvictionPolicy,omitempty"`

	// ScaleSetPriority: The Virtual Machine Scale Set priority.
	ScaleSetPriority *ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS `json:"scaleSetPriority,omitempty"`

	// SecurityProfile: The security settings of an agent pool.
	SecurityProfile *AgentPoolSecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// SpotMaxPrice: The max price (in US Dollars) you are willing to pay for spot instances. Possible values are any decimal
	// value greater than zero or -1 which indicates default price to be up-to on-demand. Possible values are any decimal value
	// greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing,
	// see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	// Status: Contains read-only information about the Agent Pool.
	Status *AgentPoolStatus_STATUS `json:"status,omitempty"`

	// Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of Agent Pool.
	Type *AgentPoolType_STATUS `json:"type,omitempty"`

	// UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings_STATUS `json:"upgradeSettings,omitempty"`

	// UpgradeSettingsBlueGreen: Settings for Blue-Green upgrade on the agentpool. Applies when upgrade strategy is set to
	// BlueGreen.
	UpgradeSettingsBlueGreen *AgentPoolBlueGreenUpgradeSettings_STATUS `json:"upgradeSettingsBlueGreen,omitempty"`

	// UpgradeStrategy: Defines the upgrade strategy for the agent pool. The default is Rolling.
	UpgradeStrategy *UpgradeStrategy_STATUS `json:"upgradeStrategy,omitempty"`

	// VirtualMachineNodesStatus: The status of nodes in a VirtualMachines agent pool.
	VirtualMachineNodesStatus []VirtualMachineNodes_STATUS `json:"virtualMachineNodesStatus,omitempty"`

	// VirtualMachinesProfile: Specifications on VirtualMachines agent pool.
	VirtualMachinesProfile *VirtualMachinesProfile_STATUS `json:"virtualMachinesProfile,omitempty"`

	// VmSize: The size of the agent pool VMs. VM size availability varies by region. If a node contains insufficient compute
	// resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see:
	// https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	// VnetSubnetID: The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this is not
	// specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods,
	// otherwise it applies to just nodes. This is of the form:
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetID *string `json:"vnetSubnetID,omitempty"`

	// WindowsProfile: The Windows agent pool's specific profile.
	WindowsProfile *AgentPoolWindowsProfile_STATUS `json:"windowsProfile,omitempty"`

	// WorkloadRuntime: Determines the type of workload a node can run.
	WorkloadRuntime *WorkloadRuntime_STATUS `json:"workloadRuntime,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAgentPoolProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAgentPoolProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAgentPoolProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAgentPoolProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAgentPoolProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAgentPoolProfile_STATUS, got %T", armInput)
	}

	// Set property "ArtifactStreamingProfile":
	if typedInput.ArtifactStreamingProfile != nil {
		var artifactStreamingProfile1 AgentPoolArtifactStreamingProfile_STATUS
		err := artifactStreamingProfile1.PopulateFromARM(owner, *typedInput.ArtifactStreamingProfile)
		if err != nil {
			return err
		}
		artifactStreamingProfile := artifactStreamingProfile1
		profile.ArtifactStreamingProfile = &artifactStreamingProfile
	}

	// Set property "AvailabilityZones":
	for _, item := range typedInput.AvailabilityZones {
		profile.AvailabilityZones = append(profile.AvailabilityZones, item)
	}

	// Set property "CapacityReservationGroupID":
	if typedInput.CapacityReservationGroupID != nil {
		capacityReservationGroupID := *typedInput.CapacityReservationGroupID
		profile.CapacityReservationGroupID = &capacityReservationGroupID
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// Set property "CreationData":
	if typedInput.CreationData != nil {
		var creationData1 CreationData_STATUS
		err := creationData1.PopulateFromARM(owner, *typedInput.CreationData)
		if err != nil {
			return err
		}
		creationData := creationData1
		profile.CreationData = &creationData
	}

	// Set property "CurrentOrchestratorVersion":
	if typedInput.CurrentOrchestratorVersion != nil {
		currentOrchestratorVersion := *typedInput.CurrentOrchestratorVersion
		profile.CurrentOrchestratorVersion = &currentOrchestratorVersion
	}

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		profile.ETag = &eTag
	}

	// Set property "EnableAutoScaling":
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property "EnableEncryptionAtHost":
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "EnableFIPS":
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	}

	// Set property "EnableNodePublicIP":
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property "EnableUltraSSD":
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property "GatewayProfile":
	if typedInput.GatewayProfile != nil {
		var gatewayProfile1 AgentPoolGatewayProfile_STATUS
		err := gatewayProfile1.PopulateFromARM(owner, *typedInput.GatewayProfile)
		if err != nil {
			return err
		}
		gatewayProfile := gatewayProfile1
		profile.GatewayProfile = &gatewayProfile
	}

	// Set property "GpuInstanceProfile":
	if typedInput.GpuInstanceProfile != nil {
		var temp string
		temp = string(*typedInput.GpuInstanceProfile)
		gpuInstanceProfile := GPUInstanceProfile_STATUS(temp)
		profile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property "GpuProfile":
	if typedInput.GpuProfile != nil {
		var gpuProfile1 GPUProfile_STATUS
		err := gpuProfile1.PopulateFromARM(owner, *typedInput.GpuProfile)
		if err != nil {
			return err
		}
		gpuProfile := gpuProfile1
		profile.GpuProfile = &gpuProfile
	}

	// Set property "HostGroupID":
	if typedInput.HostGroupID != nil {
		hostGroupID := *typedInput.HostGroupID
		profile.HostGroupID = &hostGroupID
	}

	// Set property "KubeletConfig":
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig_STATUS
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		profile.KubeletConfig = &kubeletConfig
	}

	// Set property "KubeletDiskType":
	if typedInput.KubeletDiskType != nil {
		var temp string
		temp = string(*typedInput.KubeletDiskType)
		kubeletDiskType := KubeletDiskType_STATUS(temp)
		profile.KubeletDiskType = &kubeletDiskType
	}

	// Set property "LinuxOSConfig":
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig_STATUS
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		profile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property "LocalDNSProfile":
	if typedInput.LocalDNSProfile != nil {
		var localDNSProfile1 LocalDNSProfile_STATUS
		err := localDNSProfile1.PopulateFromARM(owner, *typedInput.LocalDNSProfile)
		if err != nil {
			return err
		}
		localDNSProfile := localDNSProfile1
		profile.LocalDNSProfile = &localDNSProfile
	}

	// Set property "MaxCount":
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		profile.MaxCount = &maxCount
	}

	// Set property "MaxPods":
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		profile.MaxPods = &maxPods
	}

	// Set property "MessageOfTheDay":
	if typedInput.MessageOfTheDay != nil {
		messageOfTheDay := *typedInput.MessageOfTheDay
		profile.MessageOfTheDay = &messageOfTheDay
	}

	// Set property "MinCount":
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		profile.MinCount = &minCount
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := AgentPoolMode_STATUS(temp)
		profile.Mode = &mode
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "NetworkProfile":
	if typedInput.NetworkProfile != nil {
		var networkProfile1 AgentPoolNetworkProfile_STATUS
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property "NodeCustomizationProfile":
	if typedInput.NodeCustomizationProfile != nil {
		var nodeCustomizationProfile1 NodeCustomizationProfile_STATUS
		err := nodeCustomizationProfile1.PopulateFromARM(owner, *typedInput.NodeCustomizationProfile)
		if err != nil {
			return err
		}
		nodeCustomizationProfile := nodeCustomizationProfile1
		profile.NodeCustomizationProfile = &nodeCustomizationProfile
	}

	// Set property "NodeImageVersion":
	if typedInput.NodeImageVersion != nil {
		nodeImageVersion := *typedInput.NodeImageVersion
		profile.NodeImageVersion = &nodeImageVersion
	}

	// Set property "NodeInitializationTaints":
	for _, item := range typedInput.NodeInitializationTaints {
		profile.NodeInitializationTaints = append(profile.NodeInitializationTaints, item)
	}

	// Set property "NodeLabels":
	if typedInput.NodeLabels != nil {
		profile.NodeLabels = make(map[string]string, len(typedInput.NodeLabels))
		for key, value := range typedInput.NodeLabels {
			profile.NodeLabels[key] = value
		}
	}

	// Set property "NodePublicIPPrefixID":
	if typedInput.NodePublicIPPrefixID != nil {
		nodePublicIPPrefixID := *typedInput.NodePublicIPPrefixID
		profile.NodePublicIPPrefixID = &nodePublicIPPrefixID
	}

	// Set property "NodeTaints":
	for _, item := range typedInput.NodeTaints {
		profile.NodeTaints = append(profile.NodeTaints, item)
	}

	// Set property "OrchestratorVersion":
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		profile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property "OsDiskSizeGB":
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		profile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property "OsDiskType":
	if typedInput.OsDiskType != nil {
		var temp string
		temp = string(*typedInput.OsDiskType)
		osDiskType := OSDiskType_STATUS(temp)
		profile.OsDiskType = &osDiskType
	}

	// Set property "OsSKU":
	if typedInput.OsSKU != nil {
		var temp string
		temp = string(*typedInput.OsSKU)
		osSKU := OSSKU_STATUS(temp)
		profile.OsSKU = &osSKU
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := ManagedClusterAgentPoolProfile_OsType_STATUS(temp)
		profile.OsType = &osType
	}

	// Set property "PodIPAllocationMode":
	if typedInput.PodIPAllocationMode != nil {
		var temp string
		temp = string(*typedInput.PodIPAllocationMode)
		podIPAllocationMode := PodIPAllocationMode_STATUS(temp)
		profile.PodIPAllocationMode = &podIPAllocationMode
	}

	// Set property "PodSubnetID":
	if typedInput.PodSubnetID != nil {
		podSubnetID := *typedInput.PodSubnetID
		profile.PodSubnetID = &podSubnetID
	}

	// Set property "PowerState":
	if typedInput.PowerState != nil {
		var powerState1 PowerState_STATUS
		err := powerState1.PopulateFromARM(owner, *typedInput.PowerState)
		if err != nil {
			return err
		}
		powerState := powerState1
		profile.PowerState = &powerState
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		profile.ProvisioningState = &provisioningState
	}

	// Set property "ProximityPlacementGroupID":
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		profile.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property "ScaleDownMode":
	if typedInput.ScaleDownMode != nil {
		var temp string
		temp = string(*typedInput.ScaleDownMode)
		scaleDownMode := ScaleDownMode_STATUS(temp)
		profile.ScaleDownMode = &scaleDownMode
	}

	// Set property "ScaleSetEvictionPolicy":
	if typedInput.ScaleSetEvictionPolicy != nil {
		var temp string
		temp = string(*typedInput.ScaleSetEvictionPolicy)
		scaleSetEvictionPolicy := ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS(temp)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property "ScaleSetPriority":
	if typedInput.ScaleSetPriority != nil {
		var temp string
		temp = string(*typedInput.ScaleSetPriority)
		scaleSetPriority := ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS(temp)
		profile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 AgentPoolSecurityProfile_STATUS
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property "SpotMaxPrice":
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var status1 AgentPoolStatus_STATUS
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		profile.Status = &status
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := AgentPoolType_STATUS(temp)
		profile.Type = &typeVar
	}

	// Set property "UpgradeSettings":
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings_STATUS
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		profile.UpgradeSettings = &upgradeSettings
	}

	// Set property "UpgradeSettingsBlueGreen":
	if typedInput.UpgradeSettingsBlueGreen != nil {
		var upgradeSettingsBlueGreen1 AgentPoolBlueGreenUpgradeSettings_STATUS
		err := upgradeSettingsBlueGreen1.PopulateFromARM(owner, *typedInput.UpgradeSettingsBlueGreen)
		if err != nil {
			return err
		}
		upgradeSettingsBlueGreen := upgradeSettingsBlueGreen1
		profile.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	}

	// Set property "UpgradeStrategy":
	if typedInput.UpgradeStrategy != nil {
		var temp string
		temp = string(*typedInput.UpgradeStrategy)
		upgradeStrategy := UpgradeStrategy_STATUS(temp)
		profile.UpgradeStrategy = &upgradeStrategy
	}

	// Set property "VirtualMachineNodesStatus":
	for _, item := range typedInput.VirtualMachineNodesStatus {
		var item1 VirtualMachineNodes_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.VirtualMachineNodesStatus = append(profile.VirtualMachineNodesStatus, item1)
	}

	// Set property "VirtualMachinesProfile":
	if typedInput.VirtualMachinesProfile != nil {
		var virtualMachinesProfile1 VirtualMachinesProfile_STATUS
		err := virtualMachinesProfile1.PopulateFromARM(owner, *typedInput.VirtualMachinesProfile)
		if err != nil {
			return err
		}
		virtualMachinesProfile := virtualMachinesProfile1
		profile.VirtualMachinesProfile = &virtualMachinesProfile
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// Set property "VnetSubnetID":
	if typedInput.VnetSubnetID != nil {
		vnetSubnetID := *typedInput.VnetSubnetID
		profile.VnetSubnetID = &vnetSubnetID
	}

	// Set property "WindowsProfile":
	if typedInput.WindowsProfile != nil {
		var windowsProfile1 AgentPoolWindowsProfile_STATUS
		err := windowsProfile1.PopulateFromARM(owner, *typedInput.WindowsProfile)
		if err != nil {
			return err
		}
		windowsProfile := windowsProfile1
		profile.WindowsProfile = &windowsProfile
	}

	// Set property "WorkloadRuntime":
	if typedInput.WorkloadRuntime != nil {
		var temp string
		temp = string(*typedInput.WorkloadRuntime)
		workloadRuntime := WorkloadRuntime_STATUS(temp)
		profile.WorkloadRuntime = &workloadRuntime
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS populates our ManagedClusterAgentPoolProfile_STATUS from the provided source ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS(source *storage.ManagedClusterAgentPoolProfile_STATUS) error {

	// ArtifactStreamingProfile
	if source.ArtifactStreamingProfile != nil {
		var artifactStreamingProfile AgentPoolArtifactStreamingProfile_STATUS
		err := artifactStreamingProfile.AssignProperties_From_AgentPoolArtifactStreamingProfile_STATUS(source.ArtifactStreamingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolArtifactStreamingProfile_STATUS() to populate field ArtifactStreamingProfile")
		}
		profile.ArtifactStreamingProfile = &artifactStreamingProfile
	} else {
		profile.ArtifactStreamingProfile = nil
	}

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// CapacityReservationGroupID
	profile.CapacityReservationGroupID = genruntime.ClonePointerToString(source.CapacityReservationGroupID)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// CreationData
	if source.CreationData != nil {
		var creationDatum CreationData_STATUS
		err := creationDatum.AssignProperties_From_CreationData_STATUS(source.CreationData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CreationData_STATUS() to populate field CreationData")
		}
		profile.CreationData = &creationDatum
	} else {
		profile.CreationData = nil
	}

	// CurrentOrchestratorVersion
	profile.CurrentOrchestratorVersion = genruntime.ClonePointerToString(source.CurrentOrchestratorVersion)

	// ETag
	profile.ETag = genruntime.ClonePointerToString(source.ETag)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GatewayProfile
	if source.GatewayProfile != nil {
		var gatewayProfile AgentPoolGatewayProfile_STATUS
		err := gatewayProfile.AssignProperties_From_AgentPoolGatewayProfile_STATUS(source.GatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolGatewayProfile_STATUS() to populate field GatewayProfile")
		}
		profile.GatewayProfile = &gatewayProfile
	} else {
		profile.GatewayProfile = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := *source.GpuInstanceProfile
		gpuInstanceProfileTemp := genruntime.ToEnum(gpuInstanceProfile, gPUInstanceProfile_STATUS_Values)
		profile.GpuInstanceProfile = &gpuInstanceProfileTemp
	} else {
		profile.GpuInstanceProfile = nil
	}

	// GpuProfile
	if source.GpuProfile != nil {
		var gpuProfile GPUProfile_STATUS
		err := gpuProfile.AssignProperties_From_GPUProfile_STATUS(source.GpuProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GPUProfile_STATUS() to populate field GpuProfile")
		}
		profile.GpuProfile = &gpuProfile
	} else {
		profile.GpuProfile = nil
	}

	// HostGroupID
	profile.HostGroupID = genruntime.ClonePointerToString(source.HostGroupID)

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig_STATUS
		err := kubeletConfig.AssignProperties_From_KubeletConfig_STATUS(source.KubeletConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KubeletConfig_STATUS() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := *source.KubeletDiskType
		kubeletDiskTypeTemp := genruntime.ToEnum(kubeletDiskType, kubeletDiskType_STATUS_Values)
		profile.KubeletDiskType = &kubeletDiskTypeTemp
	} else {
		profile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig_STATUS
		err := linuxOSConfig.AssignProperties_From_LinuxOSConfig_STATUS(source.LinuxOSConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LinuxOSConfig_STATUS() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// LocalDNSProfile
	if source.LocalDNSProfile != nil {
		var localDNSProfile LocalDNSProfile_STATUS
		err := localDNSProfile.AssignProperties_From_LocalDNSProfile_STATUS(source.LocalDNSProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LocalDNSProfile_STATUS() to populate field LocalDNSProfile")
		}
		profile.LocalDNSProfile = &localDNSProfile
	} else {
		profile.LocalDNSProfile = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MessageOfTheDay
	profile.MessageOfTheDay = genruntime.ClonePointerToString(source.MessageOfTheDay)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, agentPoolMode_STATUS_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile AgentPoolNetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_AgentPoolNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// NodeCustomizationProfile
	if source.NodeCustomizationProfile != nil {
		var nodeCustomizationProfile NodeCustomizationProfile_STATUS
		err := nodeCustomizationProfile.AssignProperties_From_NodeCustomizationProfile_STATUS(source.NodeCustomizationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodeCustomizationProfile_STATUS() to populate field NodeCustomizationProfile")
		}
		profile.NodeCustomizationProfile = &nodeCustomizationProfile
	} else {
		profile.NodeCustomizationProfile = nil
	}

	// NodeImageVersion
	profile.NodeImageVersion = genruntime.ClonePointerToString(source.NodeImageVersion)

	// NodeInitializationTaints
	profile.NodeInitializationTaints = genruntime.CloneSliceOfString(source.NodeInitializationTaints)

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixID
	profile.NodePublicIPPrefixID = genruntime.ClonePointerToString(source.NodePublicIPPrefixID)

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	profile.OsDiskSizeGB = genruntime.ClonePointerToInt(source.OsDiskSizeGB)

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := *source.OsDiskType
		osDiskTypeTemp := genruntime.ToEnum(osDiskType, oSDiskType_STATUS_Values)
		profile.OsDiskType = &osDiskTypeTemp
	} else {
		profile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := *source.OsSKU
		osSKUTemp := genruntime.ToEnum(osSKU, oSSKU_STATUS_Values)
		profile.OsSKU = &osSKUTemp
	} else {
		profile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, managedClusterAgentPoolProfile_OsType_STATUS_Values)
		profile.OsType = &osTypeTemp
	} else {
		profile.OsType = nil
	}

	// PodIPAllocationMode
	if source.PodIPAllocationMode != nil {
		podIPAllocationMode := *source.PodIPAllocationMode
		podIPAllocationModeTemp := genruntime.ToEnum(podIPAllocationMode, podIPAllocationMode_STATUS_Values)
		profile.PodIPAllocationMode = &podIPAllocationModeTemp
	} else {
		profile.PodIPAllocationMode = nil
	}

	// PodSubnetID
	profile.PodSubnetID = genruntime.ClonePointerToString(source.PodSubnetID)

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_STATUS
		err := powerState.AssignProperties_From_PowerState_STATUS(source.PowerState)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PowerState_STATUS() to populate field PowerState")
		}
		profile.PowerState = &powerState
	} else {
		profile.PowerState = nil
	}

	// ProvisioningState
	profile.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleDownMode
	if source.ScaleDownMode != nil {
		scaleDownMode := *source.ScaleDownMode
		scaleDownModeTemp := genruntime.ToEnum(scaleDownMode, scaleDownMode_STATUS_Values)
		profile.ScaleDownMode = &scaleDownModeTemp
	} else {
		profile.ScaleDownMode = nil
	}

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *source.ScaleSetEvictionPolicy
		scaleSetEvictionPolicyTemp := genruntime.ToEnum(scaleSetEvictionPolicy, managedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Values)
		profile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicyTemp
	} else {
		profile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := *source.ScaleSetPriority
		scaleSetPriorityTemp := genruntime.ToEnum(scaleSetPriority, managedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Values)
		profile.ScaleSetPriority = &scaleSetPriorityTemp
	} else {
		profile.ScaleSetPriority = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile AgentPoolSecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_AgentPoolSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Status
	if source.Status != nil {
		var status AgentPoolStatus_STATUS
		err := status.AssignProperties_From_AgentPoolStatus_STATUS(source.Status)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolStatus_STATUS() to populate field Status")
		}
		profile.Status = &status
	} else {
		profile.Status = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, agentPoolType_STATUS_Values)
		profile.Type = &typeTemp
	} else {
		profile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings_STATUS
		err := upgradeSetting.AssignProperties_From_AgentPoolUpgradeSettings_STATUS(source.UpgradeSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// UpgradeSettingsBlueGreen
	if source.UpgradeSettingsBlueGreen != nil {
		var upgradeSettingsBlueGreen AgentPoolBlueGreenUpgradeSettings_STATUS
		err := upgradeSettingsBlueGreen.AssignProperties_From_AgentPoolBlueGreenUpgradeSettings_STATUS(source.UpgradeSettingsBlueGreen)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolBlueGreenUpgradeSettings_STATUS() to populate field UpgradeSettingsBlueGreen")
		}
		profile.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	} else {
		profile.UpgradeSettingsBlueGreen = nil
	}

	// UpgradeStrategy
	if source.UpgradeStrategy != nil {
		upgradeStrategy := *source.UpgradeStrategy
		upgradeStrategyTemp := genruntime.ToEnum(upgradeStrategy, upgradeStrategy_STATUS_Values)
		profile.UpgradeStrategy = &upgradeStrategyTemp
	} else {
		profile.UpgradeStrategy = nil
	}

	// VirtualMachineNodesStatus
	if source.VirtualMachineNodesStatus != nil {
		virtualMachineNodesStatusList := make([]VirtualMachineNodes_STATUS, len(source.VirtualMachineNodesStatus))
		for virtualMachineNodesStatusIndex, virtualMachineNodesStatusItem := range source.VirtualMachineNodesStatus {
			var virtualMachineNodesStatus VirtualMachineNodes_STATUS
			err := virtualMachineNodesStatus.AssignProperties_From_VirtualMachineNodes_STATUS(&virtualMachineNodesStatusItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineNodes_STATUS() to populate field VirtualMachineNodesStatus")
			}
			virtualMachineNodesStatusList[virtualMachineNodesStatusIndex] = virtualMachineNodesStatus
		}
		profile.VirtualMachineNodesStatus = virtualMachineNodesStatusList
	} else {
		profile.VirtualMachineNodesStatus = nil
	}

	// VirtualMachinesProfile
	if source.VirtualMachinesProfile != nil {
		var virtualMachinesProfile VirtualMachinesProfile_STATUS
		err := virtualMachinesProfile.AssignProperties_From_VirtualMachinesProfile_STATUS(source.VirtualMachinesProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachinesProfile_STATUS() to populate field VirtualMachinesProfile")
		}
		profile.VirtualMachinesProfile = &virtualMachinesProfile
	} else {
		profile.VirtualMachinesProfile = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetID
	profile.VnetSubnetID = genruntime.ClonePointerToString(source.VnetSubnetID)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile AgentPoolWindowsProfile_STATUS
		err := windowsProfile.AssignProperties_From_AgentPoolWindowsProfile_STATUS(source.WindowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentPoolWindowsProfile_STATUS() to populate field WindowsProfile")
		}
		profile.WindowsProfile = &windowsProfile
	} else {
		profile.WindowsProfile = nil
	}

	// WorkloadRuntime
	if source.WorkloadRuntime != nil {
		workloadRuntime := *source.WorkloadRuntime
		workloadRuntimeTemp := genruntime.ToEnum(workloadRuntime, workloadRuntime_STATUS_Values)
		profile.WorkloadRuntime = &workloadRuntimeTemp
	} else {
		profile.WorkloadRuntime = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS populates the provided destination ManagedClusterAgentPoolProfile_STATUS from our ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS(destination *storage.ManagedClusterAgentPoolProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArtifactStreamingProfile
	if profile.ArtifactStreamingProfile != nil {
		var artifactStreamingProfile storage.AgentPoolArtifactStreamingProfile_STATUS
		err := profile.ArtifactStreamingProfile.AssignProperties_To_AgentPoolArtifactStreamingProfile_STATUS(&artifactStreamingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolArtifactStreamingProfile_STATUS() to populate field ArtifactStreamingProfile")
		}
		destination.ArtifactStreamingProfile = &artifactStreamingProfile
	} else {
		destination.ArtifactStreamingProfile = nil
	}

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// CapacityReservationGroupID
	destination.CapacityReservationGroupID = genruntime.ClonePointerToString(profile.CapacityReservationGroupID)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// CreationData
	if profile.CreationData != nil {
		var creationDatum storage.CreationData_STATUS
		err := profile.CreationData.AssignProperties_To_CreationData_STATUS(&creationDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CreationData_STATUS() to populate field CreationData")
		}
		destination.CreationData = &creationDatum
	} else {
		destination.CreationData = nil
	}

	// CurrentOrchestratorVersion
	destination.CurrentOrchestratorVersion = genruntime.ClonePointerToString(profile.CurrentOrchestratorVersion)

	// ETag
	destination.ETag = genruntime.ClonePointerToString(profile.ETag)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GatewayProfile
	if profile.GatewayProfile != nil {
		var gatewayProfile storage.AgentPoolGatewayProfile_STATUS
		err := profile.GatewayProfile.AssignProperties_To_AgentPoolGatewayProfile_STATUS(&gatewayProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolGatewayProfile_STATUS() to populate field GatewayProfile")
		}
		destination.GatewayProfile = &gatewayProfile
	} else {
		destination.GatewayProfile = nil
	}

	// GpuInstanceProfile
	if profile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*profile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// GpuProfile
	if profile.GpuProfile != nil {
		var gpuProfile storage.GPUProfile_STATUS
		err := profile.GpuProfile.AssignProperties_To_GPUProfile_STATUS(&gpuProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GPUProfile_STATUS() to populate field GpuProfile")
		}
		destination.GpuProfile = &gpuProfile
	} else {
		destination.GpuProfile = nil
	}

	// HostGroupID
	destination.HostGroupID = genruntime.ClonePointerToString(profile.HostGroupID)

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig storage.KubeletConfig_STATUS
		err := profile.KubeletConfig.AssignProperties_To_KubeletConfig_STATUS(&kubeletConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KubeletConfig_STATUS() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if profile.KubeletDiskType != nil {
		kubeletDiskType := string(*profile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig storage.LinuxOSConfig_STATUS
		err := profile.LinuxOSConfig.AssignProperties_To_LinuxOSConfig_STATUS(&linuxOSConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LinuxOSConfig_STATUS() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// LocalDNSProfile
	if profile.LocalDNSProfile != nil {
		var localDNSProfile storage.LocalDNSProfile_STATUS
		err := profile.LocalDNSProfile.AssignProperties_To_LocalDNSProfile_STATUS(&localDNSProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LocalDNSProfile_STATUS() to populate field LocalDNSProfile")
		}
		destination.LocalDNSProfile = &localDNSProfile
	} else {
		destination.LocalDNSProfile = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MessageOfTheDay
	destination.MessageOfTheDay = genruntime.ClonePointerToString(profile.MessageOfTheDay)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile storage.AgentPoolNetworkProfile_STATUS
		err := profile.NetworkProfile.AssignProperties_To_AgentPoolNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeCustomizationProfile
	if profile.NodeCustomizationProfile != nil {
		var nodeCustomizationProfile storage.NodeCustomizationProfile_STATUS
		err := profile.NodeCustomizationProfile.AssignProperties_To_NodeCustomizationProfile_STATUS(&nodeCustomizationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodeCustomizationProfile_STATUS() to populate field NodeCustomizationProfile")
		}
		destination.NodeCustomizationProfile = &nodeCustomizationProfile
	} else {
		destination.NodeCustomizationProfile = nil
	}

	// NodeImageVersion
	destination.NodeImageVersion = genruntime.ClonePointerToString(profile.NodeImageVersion)

	// NodeInitializationTaints
	destination.NodeInitializationTaints = genruntime.CloneSliceOfString(profile.NodeInitializationTaints)

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixID
	destination.NodePublicIPPrefixID = genruntime.ClonePointerToString(profile.NodePublicIPPrefixID)

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	destination.OsDiskSizeGB = genruntime.ClonePointerToInt(profile.OsDiskSizeGB)

	// OsDiskType
	if profile.OsDiskType != nil {
		osDiskType := string(*profile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if profile.OsSKU != nil {
		osSKU := string(*profile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if profile.OsType != nil {
		osType := string(*profile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodIPAllocationMode
	if profile.PodIPAllocationMode != nil {
		podIPAllocationMode := string(*profile.PodIPAllocationMode)
		destination.PodIPAllocationMode = &podIPAllocationMode
	} else {
		destination.PodIPAllocationMode = nil
	}

	// PodSubnetID
	destination.PodSubnetID = genruntime.ClonePointerToString(profile.PodSubnetID)

	// PowerState
	if profile.PowerState != nil {
		var powerState storage.PowerState_STATUS
		err := profile.PowerState.AssignProperties_To_PowerState_STATUS(&powerState)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PowerState_STATUS() to populate field PowerState")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(profile.ProvisioningState)

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleDownMode
	if profile.ScaleDownMode != nil {
		scaleDownMode := string(*profile.ScaleDownMode)
		destination.ScaleDownMode = &scaleDownMode
	} else {
		destination.ScaleDownMode = nil
	}

	// ScaleSetEvictionPolicy
	if profile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*profile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if profile.ScaleSetPriority != nil {
		scaleSetPriority := string(*profile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile storage.AgentPoolSecurityProfile_STATUS
		err := profile.SecurityProfile.AssignProperties_To_AgentPoolSecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Status
	if profile.Status != nil {
		var status storage.AgentPoolStatus_STATUS
		err := profile.Status.AssignProperties_To_AgentPoolStatus_STATUS(&status)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting storage.AgentPoolUpgradeSettings_STATUS
		err := profile.UpgradeSettings.AssignProperties_To_AgentPoolUpgradeSettings_STATUS(&upgradeSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// UpgradeSettingsBlueGreen
	if profile.UpgradeSettingsBlueGreen != nil {
		var upgradeSettingsBlueGreen storage.AgentPoolBlueGreenUpgradeSettings_STATUS
		err := profile.UpgradeSettingsBlueGreen.AssignProperties_To_AgentPoolBlueGreenUpgradeSettings_STATUS(&upgradeSettingsBlueGreen)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolBlueGreenUpgradeSettings_STATUS() to populate field UpgradeSettingsBlueGreen")
		}
		destination.UpgradeSettingsBlueGreen = &upgradeSettingsBlueGreen
	} else {
		destination.UpgradeSettingsBlueGreen = nil
	}

	// UpgradeStrategy
	if profile.UpgradeStrategy != nil {
		upgradeStrategy := string(*profile.UpgradeStrategy)
		destination.UpgradeStrategy = &upgradeStrategy
	} else {
		destination.UpgradeStrategy = nil
	}

	// VirtualMachineNodesStatus
	if profile.VirtualMachineNodesStatus != nil {
		virtualMachineNodesStatusList := make([]storage.VirtualMachineNodes_STATUS, len(profile.VirtualMachineNodesStatus))
		for virtualMachineNodesStatusIndex, virtualMachineNodesStatusItem := range profile.VirtualMachineNodesStatus {
			var virtualMachineNodesStatus storage.VirtualMachineNodes_STATUS
			err := virtualMachineNodesStatusItem.AssignProperties_To_VirtualMachineNodes_STATUS(&virtualMachineNodesStatus)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineNodes_STATUS() to populate field VirtualMachineNodesStatus")
			}
			virtualMachineNodesStatusList[virtualMachineNodesStatusIndex] = virtualMachineNodesStatus
		}
		destination.VirtualMachineNodesStatus = virtualMachineNodesStatusList
	} else {
		destination.VirtualMachineNodesStatus = nil
	}

	// VirtualMachinesProfile
	if profile.VirtualMachinesProfile != nil {
		var virtualMachinesProfile storage.VirtualMachinesProfile_STATUS
		err := profile.VirtualMachinesProfile.AssignProperties_To_VirtualMachinesProfile_STATUS(&virtualMachinesProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachinesProfile_STATUS() to populate field VirtualMachinesProfile")
		}
		destination.VirtualMachinesProfile = &virtualMachinesProfile
	} else {
		destination.VirtualMachinesProfile = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetID
	destination.VnetSubnetID = genruntime.ClonePointerToString(profile.VnetSubnetID)

	// WindowsProfile
	if profile.WindowsProfile != nil {
		var windowsProfile storage.AgentPoolWindowsProfile_STATUS
		err := profile.WindowsProfile.AssignProperties_To_AgentPoolWindowsProfile_STATUS(&windowsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentPoolWindowsProfile_STATUS() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// WorkloadRuntime
	if profile.WorkloadRuntime != nil {
		workloadRuntime := string(*profile.WorkloadRuntime)
		destination.WorkloadRuntime = &workloadRuntime
	} else {
		destination.WorkloadRuntime = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// When enabling the operator, a set of AKS managed CRDs and controllers will be installed in the cluster. The operator
// automates the deployment of OSS models for inference and/or training purposes. It provides a set of preset models and
// enables distributed inference against them.
type ManagedClusterAIToolchainOperatorProfile struct {
	// Enabled: Whether to enable AI toolchain operator to the cluster. Indicates if AI toolchain operator  enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAIToolchainOperatorProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAIToolchainOperatorProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAIToolchainOperatorProfile{}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAIToolchainOperatorProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAIToolchainOperatorProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAIToolchainOperatorProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAIToolchainOperatorProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAIToolchainOperatorProfile, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAIToolchainOperatorProfile populates our ManagedClusterAIToolchainOperatorProfile from the provided source ManagedClusterAIToolchainOperatorProfile
func (profile *ManagedClusterAIToolchainOperatorProfile) AssignProperties_From_ManagedClusterAIToolchainOperatorProfile(source *storage.ManagedClusterAIToolchainOperatorProfile) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAIToolchainOperatorProfile populates the provided destination ManagedClusterAIToolchainOperatorProfile from our ManagedClusterAIToolchainOperatorProfile
func (profile *ManagedClusterAIToolchainOperatorProfile) AssignProperties_To_ManagedClusterAIToolchainOperatorProfile(destination *storage.ManagedClusterAIToolchainOperatorProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// When enabling the operator, a set of AKS managed CRDs and controllers will be installed in the cluster. The operator
// automates the deployment of OSS models for inference and/or training purposes. It provides a set of preset models and
// enables distributed inference against them.
type ManagedClusterAIToolchainOperatorProfile_STATUS struct {
	// Enabled: Whether to enable AI toolchain operator to the cluster. Indicates if AI toolchain operator  enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAIToolchainOperatorProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAIToolchainOperatorProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAIToolchainOperatorProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAIToolchainOperatorProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAIToolchainOperatorProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAIToolchainOperatorProfile_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAIToolchainOperatorProfile_STATUS populates our ManagedClusterAIToolchainOperatorProfile_STATUS from the provided source ManagedClusterAIToolchainOperatorProfile_STATUS
func (profile *ManagedClusterAIToolchainOperatorProfile_STATUS) AssignProperties_From_ManagedClusterAIToolchainOperatorProfile_STATUS(source *storage.ManagedClusterAIToolchainOperatorProfile_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAIToolchainOperatorProfile_STATUS populates the provided destination ManagedClusterAIToolchainOperatorProfile_STATUS from our ManagedClusterAIToolchainOperatorProfile_STATUS
func (profile *ManagedClusterAIToolchainOperatorProfile_STATUS) AssignProperties_To_ManagedClusterAIToolchainOperatorProfile_STATUS(destination *storage.ManagedClusterAIToolchainOperatorProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Access profile for managed cluster API server.
type ManagedClusterAPIServerAccessProfile struct {
	// AuthorizedIPRanges: The IP ranges authorized to access the Kubernetes API server. IP ranges are specified in CIDR
	// format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters
	// that are using a Basic Load Balancer. For more information see [API server authorized IP
	// ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
	AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`

	// DisableRunCommand: Whether to disable run command for the cluster or not.
	DisableRunCommand *bool `json:"disableRunCommand,omitempty"`

	// EnablePrivateCluster: Whether to create the cluster as a private cluster or not. For more details, see [Creating a
	// private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	// EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	// EnableVnetIntegration: Whether to enable apiserver vnet integration for the cluster or not. See
	// aka.ms/AksVnetIntegration for more details.
	EnableVnetIntegration *bool `json:"enableVnetIntegration,omitempty"`

	// PrivateDNSZone: The private DNS zone mode for the cluster. The default is System. For more details see [configure
	// private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are
	// 'system' and 'none'.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`

	// SubnetReference: The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new
	// cluster with BYO Vnet, or when updating an existing cluster to enable apiserver vnet integration.
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAPIServerAccessProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAPIServerAccessProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAPIServerAccessProfile{}

	// Set property "AuthorizedIPRanges":
	for _, item := range profile.AuthorizedIPRanges {
		result.AuthorizedIPRanges = append(result.AuthorizedIPRanges, item)
	}

	// Set property "DisableRunCommand":
	if profile.DisableRunCommand != nil {
		disableRunCommand := *profile.DisableRunCommand
		result.DisableRunCommand = &disableRunCommand
	}

	// Set property "EnablePrivateCluster":
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		result.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property "EnablePrivateClusterPublicFQDN":
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		result.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property "EnableVnetIntegration":
	if profile.EnableVnetIntegration != nil {
		enableVnetIntegration := *profile.EnableVnetIntegration
		result.EnableVnetIntegration = &enableVnetIntegration
	}

	// Set property "PrivateDNSZone":
	if profile.PrivateDNSZone != nil {
		privateDNSZone := *profile.PrivateDNSZone
		result.PrivateDNSZone = &privateDNSZone
	}

	// Set property "SubnetId":
	if profile.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAPIServerAccessProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAPIServerAccessProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAPIServerAccessProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAPIServerAccessProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAPIServerAccessProfile, got %T", armInput)
	}

	// Set property "AuthorizedIPRanges":
	for _, item := range typedInput.AuthorizedIPRanges {
		profile.AuthorizedIPRanges = append(profile.AuthorizedIPRanges, item)
	}

	// Set property "DisableRunCommand":
	if typedInput.DisableRunCommand != nil {
		disableRunCommand := *typedInput.DisableRunCommand
		profile.DisableRunCommand = &disableRunCommand
	}

	// Set property "EnablePrivateCluster":
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property "EnablePrivateClusterPublicFQDN":
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property "EnableVnetIntegration":
	if typedInput.EnableVnetIntegration != nil {
		enableVnetIntegration := *typedInput.EnableVnetIntegration
		profile.EnableVnetIntegration = &enableVnetIntegration
	}

	// Set property "PrivateDNSZone":
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		profile.PrivateDNSZone = &privateDNSZone
	}

	// no assignment for property "SubnetReference"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAPIServerAccessProfile populates our ManagedClusterAPIServerAccessProfile from the provided source ManagedClusterAPIServerAccessProfile
func (profile *ManagedClusterAPIServerAccessProfile) AssignProperties_From_ManagedClusterAPIServerAccessProfile(source *storage.ManagedClusterAPIServerAccessProfile) error {

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// DisableRunCommand
	if source.DisableRunCommand != nil {
		disableRunCommand := *source.DisableRunCommand
		profile.DisableRunCommand = &disableRunCommand
	} else {
		profile.DisableRunCommand = nil
	}

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// EnableVnetIntegration
	if source.EnableVnetIntegration != nil {
		enableVnetIntegration := *source.EnableVnetIntegration
		profile.EnableVnetIntegration = &enableVnetIntegration
	} else {
		profile.EnableVnetIntegration = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		profile.SubnetReference = &subnetReference
	} else {
		profile.SubnetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAPIServerAccessProfile populates the provided destination ManagedClusterAPIServerAccessProfile from our ManagedClusterAPIServerAccessProfile
func (profile *ManagedClusterAPIServerAccessProfile) AssignProperties_To_ManagedClusterAPIServerAccessProfile(destination *storage.ManagedClusterAPIServerAccessProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// DisableRunCommand
	if profile.DisableRunCommand != nil {
		disableRunCommand := *profile.DisableRunCommand
		destination.DisableRunCommand = &disableRunCommand
	} else {
		destination.DisableRunCommand = nil
	}

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// EnableVnetIntegration
	if profile.EnableVnetIntegration != nil {
		enableVnetIntegration := *profile.EnableVnetIntegration
		destination.EnableVnetIntegration = &enableVnetIntegration
	} else {
		destination.EnableVnetIntegration = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// SubnetReference
	if profile.SubnetReference != nil {
		subnetReference := profile.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Access profile for managed cluster API server.
type ManagedClusterAPIServerAccessProfile_STATUS struct {
	// AuthorizedIPRanges: The IP ranges authorized to access the Kubernetes API server. IP ranges are specified in CIDR
	// format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters
	// that are using a Basic Load Balancer. For more information see [API server authorized IP
	// ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
	AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`

	// DisableRunCommand: Whether to disable run command for the cluster or not.
	DisableRunCommand *bool `json:"disableRunCommand,omitempty"`

	// EnablePrivateCluster: Whether to create the cluster as a private cluster or not. For more details, see [Creating a
	// private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	// EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	// EnableVnetIntegration: Whether to enable apiserver vnet integration for the cluster or not. See
	// aka.ms/AksVnetIntegration for more details.
	EnableVnetIntegration *bool `json:"enableVnetIntegration,omitempty"`

	// PrivateDNSZone: The private DNS zone mode for the cluster. The default is System. For more details see [configure
	// private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are
	// 'system' and 'none'.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`

	// SubnetId: The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new cluster
	// with BYO Vnet, or when updating an existing cluster to enable apiserver vnet integration.
	SubnetId *string `json:"subnetId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAPIServerAccessProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAPIServerAccessProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAPIServerAccessProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAPIServerAccessProfile_STATUS, got %T", armInput)
	}

	// Set property "AuthorizedIPRanges":
	for _, item := range typedInput.AuthorizedIPRanges {
		profile.AuthorizedIPRanges = append(profile.AuthorizedIPRanges, item)
	}

	// Set property "DisableRunCommand":
	if typedInput.DisableRunCommand != nil {
		disableRunCommand := *typedInput.DisableRunCommand
		profile.DisableRunCommand = &disableRunCommand
	}

	// Set property "EnablePrivateCluster":
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property "EnablePrivateClusterPublicFQDN":
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property "EnableVnetIntegration":
	if typedInput.EnableVnetIntegration != nil {
		enableVnetIntegration := *typedInput.EnableVnetIntegration
		profile.EnableVnetIntegration = &enableVnetIntegration
	}

	// Set property "PrivateDNSZone":
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		profile.PrivateDNSZone = &privateDNSZone
	}

	// Set property "SubnetId":
	if typedInput.SubnetId != nil {
		subnetId := *typedInput.SubnetId
		profile.SubnetId = &subnetId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS populates our ManagedClusterAPIServerAccessProfile_STATUS from the provided source ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS(source *storage.ManagedClusterAPIServerAccessProfile_STATUS) error {

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// DisableRunCommand
	if source.DisableRunCommand != nil {
		disableRunCommand := *source.DisableRunCommand
		profile.DisableRunCommand = &disableRunCommand
	} else {
		profile.DisableRunCommand = nil
	}

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// EnableVnetIntegration
	if source.EnableVnetIntegration != nil {
		enableVnetIntegration := *source.EnableVnetIntegration
		profile.EnableVnetIntegration = &enableVnetIntegration
	} else {
		profile.EnableVnetIntegration = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// SubnetId
	profile.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS populates the provided destination ManagedClusterAPIServerAccessProfile_STATUS from our ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS(destination *storage.ManagedClusterAPIServerAccessProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// DisableRunCommand
	if profile.DisableRunCommand != nil {
		disableRunCommand := *profile.DisableRunCommand
		destination.DisableRunCommand = &disableRunCommand
	} else {
		destination.DisableRunCommand = nil
	}

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// EnableVnetIntegration
	if profile.EnableVnetIntegration != nil {
		enableVnetIntegration := *profile.EnableVnetIntegration
		destination.EnableVnetIntegration = &enableVnetIntegration
	} else {
		destination.EnableVnetIntegration = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(profile.SubnetId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Auto upgrade profile for a managed cluster.
type ManagedClusterAutoUpgradeProfile struct {
	// NodeOSUpgradeChannel: Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
	NodeOSUpgradeChannel *NodeOSUpgradeChannel `json:"nodeOSUpgradeChannel,omitempty"`

	// UpgradeChannel: The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS
	// cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
	UpgradeChannel *UpgradeChannel `json:"upgradeChannel,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAutoUpgradeProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAutoUpgradeProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAutoUpgradeProfile{}

	// Set property "NodeOSUpgradeChannel":
	if profile.NodeOSUpgradeChannel != nil {
		var temp string
		temp = string(*profile.NodeOSUpgradeChannel)
		nodeOSUpgradeChannel := arm.NodeOSUpgradeChannel(temp)
		result.NodeOSUpgradeChannel = &nodeOSUpgradeChannel
	}

	// Set property "UpgradeChannel":
	if profile.UpgradeChannel != nil {
		var temp string
		temp = string(*profile.UpgradeChannel)
		upgradeChannel := arm.UpgradeChannel(temp)
		result.UpgradeChannel = &upgradeChannel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAutoUpgradeProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAutoUpgradeProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAutoUpgradeProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAutoUpgradeProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAutoUpgradeProfile, got %T", armInput)
	}

	// Set property "NodeOSUpgradeChannel":
	if typedInput.NodeOSUpgradeChannel != nil {
		var temp string
		temp = string(*typedInput.NodeOSUpgradeChannel)
		nodeOSUpgradeChannel := NodeOSUpgradeChannel(temp)
		profile.NodeOSUpgradeChannel = &nodeOSUpgradeChannel
	}

	// Set property "UpgradeChannel":
	if typedInput.UpgradeChannel != nil {
		var temp string
		temp = string(*typedInput.UpgradeChannel)
		upgradeChannel := UpgradeChannel(temp)
		profile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAutoUpgradeProfile populates our ManagedClusterAutoUpgradeProfile from the provided source ManagedClusterAutoUpgradeProfile
func (profile *ManagedClusterAutoUpgradeProfile) AssignProperties_From_ManagedClusterAutoUpgradeProfile(source *storage.ManagedClusterAutoUpgradeProfile) error {

	// NodeOSUpgradeChannel
	if source.NodeOSUpgradeChannel != nil {
		nodeOSUpgradeChannel := *source.NodeOSUpgradeChannel
		nodeOSUpgradeChannelTemp := genruntime.ToEnum(nodeOSUpgradeChannel, nodeOSUpgradeChannel_Values)
		profile.NodeOSUpgradeChannel = &nodeOSUpgradeChannelTemp
	} else {
		profile.NodeOSUpgradeChannel = nil
	}

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := *source.UpgradeChannel
		upgradeChannelTemp := genruntime.ToEnum(upgradeChannel, upgradeChannel_Values)
		profile.UpgradeChannel = &upgradeChannelTemp
	} else {
		profile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAutoUpgradeProfile populates the provided destination ManagedClusterAutoUpgradeProfile from our ManagedClusterAutoUpgradeProfile
func (profile *ManagedClusterAutoUpgradeProfile) AssignProperties_To_ManagedClusterAutoUpgradeProfile(destination *storage.ManagedClusterAutoUpgradeProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NodeOSUpgradeChannel
	if profile.NodeOSUpgradeChannel != nil {
		nodeOSUpgradeChannel := string(*profile.NodeOSUpgradeChannel)
		destination.NodeOSUpgradeChannel = &nodeOSUpgradeChannel
	} else {
		destination.NodeOSUpgradeChannel = nil
	}

	// UpgradeChannel
	if profile.UpgradeChannel != nil {
		upgradeChannel := string(*profile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Auto upgrade profile for a managed cluster.
type ManagedClusterAutoUpgradeProfile_STATUS struct {
	// NodeOSUpgradeChannel: Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
	NodeOSUpgradeChannel *NodeOSUpgradeChannel_STATUS `json:"nodeOSUpgradeChannel,omitempty"`

	// UpgradeChannel: The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS
	// cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
	UpgradeChannel *UpgradeChannel_STATUS `json:"upgradeChannel,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAutoUpgradeProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAutoUpgradeProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAutoUpgradeProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAutoUpgradeProfile_STATUS, got %T", armInput)
	}

	// Set property "NodeOSUpgradeChannel":
	if typedInput.NodeOSUpgradeChannel != nil {
		var temp string
		temp = string(*typedInput.NodeOSUpgradeChannel)
		nodeOSUpgradeChannel := NodeOSUpgradeChannel_STATUS(temp)
		profile.NodeOSUpgradeChannel = &nodeOSUpgradeChannel
	}

	// Set property "UpgradeChannel":
	if typedInput.UpgradeChannel != nil {
		var temp string
		temp = string(*typedInput.UpgradeChannel)
		upgradeChannel := UpgradeChannel_STATUS(temp)
		profile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS populates our ManagedClusterAutoUpgradeProfile_STATUS from the provided source ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS(source *storage.ManagedClusterAutoUpgradeProfile_STATUS) error {

	// NodeOSUpgradeChannel
	if source.NodeOSUpgradeChannel != nil {
		nodeOSUpgradeChannel := *source.NodeOSUpgradeChannel
		nodeOSUpgradeChannelTemp := genruntime.ToEnum(nodeOSUpgradeChannel, nodeOSUpgradeChannel_STATUS_Values)
		profile.NodeOSUpgradeChannel = &nodeOSUpgradeChannelTemp
	} else {
		profile.NodeOSUpgradeChannel = nil
	}

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := *source.UpgradeChannel
		upgradeChannelTemp := genruntime.ToEnum(upgradeChannel, upgradeChannel_STATUS_Values)
		profile.UpgradeChannel = &upgradeChannelTemp
	} else {
		profile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS populates the provided destination ManagedClusterAutoUpgradeProfile_STATUS from our ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS(destination *storage.ManagedClusterAutoUpgradeProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NodeOSUpgradeChannel
	if profile.NodeOSUpgradeChannel != nil {
		nodeOSUpgradeChannel := string(*profile.NodeOSUpgradeChannel)
		destination.NodeOSUpgradeChannel = &nodeOSUpgradeChannel
	} else {
		destination.NodeOSUpgradeChannel = nil
	}

	// UpgradeChannel
	if profile.UpgradeChannel != nil {
		upgradeChannel := string(*profile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Monitor addon profiles for monitoring the managed cluster.
type ManagedClusterAzureMonitorProfile struct {
	// AppMonitoring: Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics
	// and traces through auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	AppMonitoring *ManagedClusterAzureMonitorProfileAppMonitoring `json:"appMonitoring,omitempty"`

	// ContainerInsights: Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout &
	// stderr logs etc. See aka.ms/AzureMonitorContainerInsights for an overview.
	ContainerInsights *ManagedClusterAzureMonitorProfileContainerInsights `json:"containerInsights,omitempty"`

	// Metrics: Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes
	// infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See
	// aka.ms/AzureManagedPrometheus for an overview.
	Metrics *ManagedClusterAzureMonitorProfileMetrics `json:"metrics,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterAzureMonitorProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfile{}

	// Set property "AppMonitoring":
	if profile.AppMonitoring != nil {
		appMonitoring_ARM, err := profile.AppMonitoring.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		appMonitoring := *appMonitoring_ARM.(*arm.ManagedClusterAzureMonitorProfileAppMonitoring)
		result.AppMonitoring = &appMonitoring
	}

	// Set property "ContainerInsights":
	if profile.ContainerInsights != nil {
		containerInsights_ARM, err := profile.ContainerInsights.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		containerInsights := *containerInsights_ARM.(*arm.ManagedClusterAzureMonitorProfileContainerInsights)
		result.ContainerInsights = &containerInsights
	}

	// Set property "Metrics":
	if profile.Metrics != nil {
		metrics_ARM, err := profile.Metrics.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		metrics := *metrics_ARM.(*arm.ManagedClusterAzureMonitorProfileMetrics)
		result.Metrics = &metrics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAzureMonitorProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAzureMonitorProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfile, got %T", armInput)
	}

	// Set property "AppMonitoring":
	if typedInput.AppMonitoring != nil {
		var appMonitoring1 ManagedClusterAzureMonitorProfileAppMonitoring
		err := appMonitoring1.PopulateFromARM(owner, *typedInput.AppMonitoring)
		if err != nil {
			return err
		}
		appMonitoring := appMonitoring1
		profile.AppMonitoring = &appMonitoring
	}

	// Set property "ContainerInsights":
	if typedInput.ContainerInsights != nil {
		var containerInsights1 ManagedClusterAzureMonitorProfileContainerInsights
		err := containerInsights1.PopulateFromARM(owner, *typedInput.ContainerInsights)
		if err != nil {
			return err
		}
		containerInsights := containerInsights1
		profile.ContainerInsights = &containerInsights
	}

	// Set property "Metrics":
	if typedInput.Metrics != nil {
		var metrics1 ManagedClusterAzureMonitorProfileMetrics
		err := metrics1.PopulateFromARM(owner, *typedInput.Metrics)
		if err != nil {
			return err
		}
		metrics := metrics1
		profile.Metrics = &metrics
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfile populates our ManagedClusterAzureMonitorProfile from the provided source ManagedClusterAzureMonitorProfile
func (profile *ManagedClusterAzureMonitorProfile) AssignProperties_From_ManagedClusterAzureMonitorProfile(source *storage.ManagedClusterAzureMonitorProfile) error {

	// AppMonitoring
	if source.AppMonitoring != nil {
		var appMonitoring ManagedClusterAzureMonitorProfileAppMonitoring
		err := appMonitoring.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring(source.AppMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring() to populate field AppMonitoring")
		}
		profile.AppMonitoring = &appMonitoring
	} else {
		profile.AppMonitoring = nil
	}

	// ContainerInsights
	if source.ContainerInsights != nil {
		var containerInsight ManagedClusterAzureMonitorProfileContainerInsights
		err := containerInsight.AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights(source.ContainerInsights)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights() to populate field ContainerInsights")
		}
		profile.ContainerInsights = &containerInsight
	} else {
		profile.ContainerInsights = nil
	}

	// Metrics
	if source.Metrics != nil {
		var metric ManagedClusterAzureMonitorProfileMetrics
		err := metric.AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics(source.Metrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics() to populate field Metrics")
		}
		profile.Metrics = &metric
	} else {
		profile.Metrics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfile populates the provided destination ManagedClusterAzureMonitorProfile from our ManagedClusterAzureMonitorProfile
func (profile *ManagedClusterAzureMonitorProfile) AssignProperties_To_ManagedClusterAzureMonitorProfile(destination *storage.ManagedClusterAzureMonitorProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppMonitoring
	if profile.AppMonitoring != nil {
		var appMonitoring storage.ManagedClusterAzureMonitorProfileAppMonitoring
		err := profile.AppMonitoring.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring(&appMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring() to populate field AppMonitoring")
		}
		destination.AppMonitoring = &appMonitoring
	} else {
		destination.AppMonitoring = nil
	}

	// ContainerInsights
	if profile.ContainerInsights != nil {
		var containerInsight storage.ManagedClusterAzureMonitorProfileContainerInsights
		err := profile.ContainerInsights.AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights(&containerInsight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights() to populate field ContainerInsights")
		}
		destination.ContainerInsights = &containerInsight
	} else {
		destination.ContainerInsights = nil
	}

	// Metrics
	if profile.Metrics != nil {
		var metric storage.ManagedClusterAzureMonitorProfileMetrics
		err := profile.Metrics.AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics(&metric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics() to populate field Metrics")
		}
		destination.Metrics = &metric
	} else {
		destination.Metrics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Monitor addon profiles for monitoring the managed cluster.
type ManagedClusterAzureMonitorProfile_STATUS struct {
	// AppMonitoring: Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics
	// and traces through auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	AppMonitoring *ManagedClusterAzureMonitorProfileAppMonitoring_STATUS `json:"appMonitoring,omitempty"`

	// ContainerInsights: Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout &
	// stderr logs etc. See aka.ms/AzureMonitorContainerInsights for an overview.
	ContainerInsights *ManagedClusterAzureMonitorProfileContainerInsights_STATUS `json:"containerInsights,omitempty"`

	// Metrics: Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes
	// infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See
	// aka.ms/AzureManagedPrometheus for an overview.
	Metrics *ManagedClusterAzureMonitorProfileMetrics_STATUS `json:"metrics,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterAzureMonitorProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterAzureMonitorProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfile_STATUS, got %T", armInput)
	}

	// Set property "AppMonitoring":
	if typedInput.AppMonitoring != nil {
		var appMonitoring1 ManagedClusterAzureMonitorProfileAppMonitoring_STATUS
		err := appMonitoring1.PopulateFromARM(owner, *typedInput.AppMonitoring)
		if err != nil {
			return err
		}
		appMonitoring := appMonitoring1
		profile.AppMonitoring = &appMonitoring
	}

	// Set property "ContainerInsights":
	if typedInput.ContainerInsights != nil {
		var containerInsights1 ManagedClusterAzureMonitorProfileContainerInsights_STATUS
		err := containerInsights1.PopulateFromARM(owner, *typedInput.ContainerInsights)
		if err != nil {
			return err
		}
		containerInsights := containerInsights1
		profile.ContainerInsights = &containerInsights
	}

	// Set property "Metrics":
	if typedInput.Metrics != nil {
		var metrics1 ManagedClusterAzureMonitorProfileMetrics_STATUS
		err := metrics1.PopulateFromARM(owner, *typedInput.Metrics)
		if err != nil {
			return err
		}
		metrics := metrics1
		profile.Metrics = &metrics
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfile_STATUS populates our ManagedClusterAzureMonitorProfile_STATUS from the provided source ManagedClusterAzureMonitorProfile_STATUS
func (profile *ManagedClusterAzureMonitorProfile_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfile_STATUS(source *storage.ManagedClusterAzureMonitorProfile_STATUS) error {

	// AppMonitoring
	if source.AppMonitoring != nil {
		var appMonitoring ManagedClusterAzureMonitorProfileAppMonitoring_STATUS
		err := appMonitoring.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS(source.AppMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS() to populate field AppMonitoring")
		}
		profile.AppMonitoring = &appMonitoring
	} else {
		profile.AppMonitoring = nil
	}

	// ContainerInsights
	if source.ContainerInsights != nil {
		var containerInsight ManagedClusterAzureMonitorProfileContainerInsights_STATUS
		err := containerInsight.AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights_STATUS(source.ContainerInsights)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights_STATUS() to populate field ContainerInsights")
		}
		profile.ContainerInsights = &containerInsight
	} else {
		profile.ContainerInsights = nil
	}

	// Metrics
	if source.Metrics != nil {
		var metric ManagedClusterAzureMonitorProfileMetrics_STATUS
		err := metric.AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics_STATUS(source.Metrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics_STATUS() to populate field Metrics")
		}
		profile.Metrics = &metric
	} else {
		profile.Metrics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfile_STATUS populates the provided destination ManagedClusterAzureMonitorProfile_STATUS from our ManagedClusterAzureMonitorProfile_STATUS
func (profile *ManagedClusterAzureMonitorProfile_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfile_STATUS(destination *storage.ManagedClusterAzureMonitorProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppMonitoring
	if profile.AppMonitoring != nil {
		var appMonitoring storage.ManagedClusterAzureMonitorProfileAppMonitoring_STATUS
		err := profile.AppMonitoring.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS(&appMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS() to populate field AppMonitoring")
		}
		destination.AppMonitoring = &appMonitoring
	} else {
		destination.AppMonitoring = nil
	}

	// ContainerInsights
	if profile.ContainerInsights != nil {
		var containerInsight storage.ManagedClusterAzureMonitorProfileContainerInsights_STATUS
		err := profile.ContainerInsights.AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights_STATUS(&containerInsight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights_STATUS() to populate field ContainerInsights")
		}
		destination.ContainerInsights = &containerInsight
	} else {
		destination.ContainerInsights = nil
	}

	// Metrics
	if profile.Metrics != nil {
		var metric storage.ManagedClusterAzureMonitorProfileMetrics_STATUS
		err := profile.Metrics.AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics_STATUS(&metric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics_STATUS() to populate field Metrics")
		}
		destination.Metrics = &metric
	} else {
		destination.Metrics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The bootstrap profile.
type ManagedClusterBootstrapProfile struct {
	// ArtifactSource: The artifact source. The source where the artifacts are downloaded from.
	ArtifactSource *ManagedClusterBootstrapProfile_ArtifactSource `json:"artifactSource,omitempty"`

	// ContainerRegistryReference: The resource Id of Azure Container Registry. The registry must have private network access,
	// premium SKU and zone redundancy.
	ContainerRegistryReference *genruntime.ResourceReference `armReference:"ContainerRegistryId" json:"containerRegistryReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterBootstrapProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterBootstrapProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterBootstrapProfile{}

	// Set property "ArtifactSource":
	if profile.ArtifactSource != nil {
		var temp string
		temp = string(*profile.ArtifactSource)
		artifactSource := arm.ManagedClusterBootstrapProfile_ArtifactSource(temp)
		result.ArtifactSource = &artifactSource
	}

	// Set property "ContainerRegistryId":
	if profile.ContainerRegistryReference != nil {
		containerRegistryReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.ContainerRegistryReference)
		if err != nil {
			return nil, err
		}
		containerRegistryReference := containerRegistryReferenceARMID
		result.ContainerRegistryId = &containerRegistryReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterBootstrapProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterBootstrapProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterBootstrapProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterBootstrapProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterBootstrapProfile, got %T", armInput)
	}

	// Set property "ArtifactSource":
	if typedInput.ArtifactSource != nil {
		var temp string
		temp = string(*typedInput.ArtifactSource)
		artifactSource := ManagedClusterBootstrapProfile_ArtifactSource(temp)
		profile.ArtifactSource = &artifactSource
	}

	// no assignment for property "ContainerRegistryReference"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterBootstrapProfile populates our ManagedClusterBootstrapProfile from the provided source ManagedClusterBootstrapProfile
func (profile *ManagedClusterBootstrapProfile) AssignProperties_From_ManagedClusterBootstrapProfile(source *storage.ManagedClusterBootstrapProfile) error {

	// ArtifactSource
	if source.ArtifactSource != nil {
		artifactSource := *source.ArtifactSource
		artifactSourceTemp := genruntime.ToEnum(artifactSource, managedClusterBootstrapProfile_ArtifactSource_Values)
		profile.ArtifactSource = &artifactSourceTemp
	} else {
		profile.ArtifactSource = nil
	}

	// ContainerRegistryReference
	if source.ContainerRegistryReference != nil {
		containerRegistryReference := source.ContainerRegistryReference.Copy()
		profile.ContainerRegistryReference = &containerRegistryReference
	} else {
		profile.ContainerRegistryReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterBootstrapProfile populates the provided destination ManagedClusterBootstrapProfile from our ManagedClusterBootstrapProfile
func (profile *ManagedClusterBootstrapProfile) AssignProperties_To_ManagedClusterBootstrapProfile(destination *storage.ManagedClusterBootstrapProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArtifactSource
	if profile.ArtifactSource != nil {
		artifactSource := string(*profile.ArtifactSource)
		destination.ArtifactSource = &artifactSource
	} else {
		destination.ArtifactSource = nil
	}

	// ContainerRegistryReference
	if profile.ContainerRegistryReference != nil {
		containerRegistryReference := profile.ContainerRegistryReference.Copy()
		destination.ContainerRegistryReference = &containerRegistryReference
	} else {
		destination.ContainerRegistryReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The bootstrap profile.
type ManagedClusterBootstrapProfile_STATUS struct {
	// ArtifactSource: The artifact source. The source where the artifacts are downloaded from.
	ArtifactSource *ManagedClusterBootstrapProfile_ArtifactSource_STATUS `json:"artifactSource,omitempty"`

	// ContainerRegistryId: The resource Id of Azure Container Registry. The registry must have private network access, premium
	// SKU and zone redundancy.
	ContainerRegistryId *string `json:"containerRegistryId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterBootstrapProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterBootstrapProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterBootstrapProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterBootstrapProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterBootstrapProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterBootstrapProfile_STATUS, got %T", armInput)
	}

	// Set property "ArtifactSource":
	if typedInput.ArtifactSource != nil {
		var temp string
		temp = string(*typedInput.ArtifactSource)
		artifactSource := ManagedClusterBootstrapProfile_ArtifactSource_STATUS(temp)
		profile.ArtifactSource = &artifactSource
	}

	// Set property "ContainerRegistryId":
	if typedInput.ContainerRegistryId != nil {
		containerRegistryId := *typedInput.ContainerRegistryId
		profile.ContainerRegistryId = &containerRegistryId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterBootstrapProfile_STATUS populates our ManagedClusterBootstrapProfile_STATUS from the provided source ManagedClusterBootstrapProfile_STATUS
func (profile *ManagedClusterBootstrapProfile_STATUS) AssignProperties_From_ManagedClusterBootstrapProfile_STATUS(source *storage.ManagedClusterBootstrapProfile_STATUS) error {

	// ArtifactSource
	if source.ArtifactSource != nil {
		artifactSource := *source.ArtifactSource
		artifactSourceTemp := genruntime.ToEnum(artifactSource, managedClusterBootstrapProfile_ArtifactSource_STATUS_Values)
		profile.ArtifactSource = &artifactSourceTemp
	} else {
		profile.ArtifactSource = nil
	}

	// ContainerRegistryId
	profile.ContainerRegistryId = genruntime.ClonePointerToString(source.ContainerRegistryId)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterBootstrapProfile_STATUS populates the provided destination ManagedClusterBootstrapProfile_STATUS from our ManagedClusterBootstrapProfile_STATUS
func (profile *ManagedClusterBootstrapProfile_STATUS) AssignProperties_To_ManagedClusterBootstrapProfile_STATUS(destination *storage.ManagedClusterBootstrapProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArtifactSource
	if profile.ArtifactSource != nil {
		artifactSource := string(*profile.ArtifactSource)
		destination.ArtifactSource = &artifactSource
	} else {
		destination.ArtifactSource = nil
	}

	// ContainerRegistryId
	destination.ContainerRegistryId = genruntime.ClonePointerToString(profile.ContainerRegistryId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for hosted system addons.
type ManagedClusterHostedSystemProfile struct {
	// Enabled: Whether to enable hosted system addons for the cluster.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterHostedSystemProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterHostedSystemProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterHostedSystemProfile{}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterHostedSystemProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterHostedSystemProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterHostedSystemProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterHostedSystemProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterHostedSystemProfile, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterHostedSystemProfile populates our ManagedClusterHostedSystemProfile from the provided source ManagedClusterHostedSystemProfile
func (profile *ManagedClusterHostedSystemProfile) AssignProperties_From_ManagedClusterHostedSystemProfile(source *storage.ManagedClusterHostedSystemProfile) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHostedSystemProfile populates the provided destination ManagedClusterHostedSystemProfile from our ManagedClusterHostedSystemProfile
func (profile *ManagedClusterHostedSystemProfile) AssignProperties_To_ManagedClusterHostedSystemProfile(destination *storage.ManagedClusterHostedSystemProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for hosted system addons.
type ManagedClusterHostedSystemProfile_STATUS struct {
	// Enabled: Whether to enable hosted system addons for the cluster.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterHostedSystemProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterHostedSystemProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterHostedSystemProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterHostedSystemProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterHostedSystemProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterHostedSystemProfile_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterHostedSystemProfile_STATUS populates our ManagedClusterHostedSystemProfile_STATUS from the provided source ManagedClusterHostedSystemProfile_STATUS
func (profile *ManagedClusterHostedSystemProfile_STATUS) AssignProperties_From_ManagedClusterHostedSystemProfile_STATUS(source *storage.ManagedClusterHostedSystemProfile_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHostedSystemProfile_STATUS populates the provided destination ManagedClusterHostedSystemProfile_STATUS from our ManagedClusterHostedSystemProfile_STATUS
func (profile *ManagedClusterHostedSystemProfile_STATUS) AssignProperties_To_ManagedClusterHostedSystemProfile_STATUS(destination *storage.ManagedClusterHostedSystemProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Cluster HTTP proxy configuration.
type ManagedClusterHTTPProxyConfig struct {
	// Enabled: Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and
	// nodes.
	Enabled *bool `json:"enabled,omitempty"`

	// HttpProxy: The HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	// HttpsProxy: The HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	// NoProxy: The endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy,omitempty"`

	// TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterHTTPProxyConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ManagedClusterHTTPProxyConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterHTTPProxyConfig{}

	// Set property "Enabled":
	if config.Enabled != nil {
		enabled := *config.Enabled
		result.Enabled = &enabled
	}

	// Set property "HttpProxy":
	if config.HttpProxy != nil {
		httpProxy := *config.HttpProxy
		result.HttpProxy = &httpProxy
	}

	// Set property "HttpsProxy":
	if config.HttpsProxy != nil {
		httpsProxy := *config.HttpsProxy
		result.HttpsProxy = &httpsProxy
	}

	// Set property "NoProxy":
	for _, item := range config.NoProxy {
		result.NoProxy = append(result.NoProxy, item)
	}

	// Set property "TrustedCa":
	if config.TrustedCa != nil {
		trustedCa := *config.TrustedCa
		result.TrustedCa = &trustedCa
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ManagedClusterHTTPProxyConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterHTTPProxyConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ManagedClusterHTTPProxyConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterHTTPProxyConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterHTTPProxyConfig, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		config.Enabled = &enabled
	}

	// Set property "HttpProxy":
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		config.HttpProxy = &httpProxy
	}

	// Set property "HttpsProxy":
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		config.HttpsProxy = &httpsProxy
	}

	// Set property "NoProxy":
	for _, item := range typedInput.NoProxy {
		config.NoProxy = append(config.NoProxy, item)
	}

	// Set property "TrustedCa":
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		config.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterHTTPProxyConfig populates our ManagedClusterHTTPProxyConfig from the provided source ManagedClusterHTTPProxyConfig
func (config *ManagedClusterHTTPProxyConfig) AssignProperties_From_ManagedClusterHTTPProxyConfig(source *storage.ManagedClusterHTTPProxyConfig) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		config.Enabled = &enabled
	} else {
		config.Enabled = nil
	}

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHTTPProxyConfig populates the provided destination ManagedClusterHTTPProxyConfig from our ManagedClusterHTTPProxyConfig
func (config *ManagedClusterHTTPProxyConfig) AssignProperties_To_ManagedClusterHTTPProxyConfig(destination *storage.ManagedClusterHTTPProxyConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if config.Enabled != nil {
		enabled := *config.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Cluster HTTP proxy configuration.
type ManagedClusterHTTPProxyConfig_STATUS struct {
	// EffectiveNoProxy: A read-only list of all endpoints for which traffic should not be sent to the proxy. This list is a
	// superset of noProxy and values injected by AKS.
	EffectiveNoProxy []string `json:"effectiveNoProxy,omitempty"`

	// Enabled: Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and
	// nodes.
	Enabled *bool `json:"enabled,omitempty"`

	// HttpProxy: The HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	// HttpsProxy: The HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	// NoProxy: The endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy,omitempty"`

	// TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterHTTPProxyConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ManagedClusterHTTPProxyConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterHTTPProxyConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ManagedClusterHTTPProxyConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterHTTPProxyConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterHTTPProxyConfig_STATUS, got %T", armInput)
	}

	// Set property "EffectiveNoProxy":
	for _, item := range typedInput.EffectiveNoProxy {
		config.EffectiveNoProxy = append(config.EffectiveNoProxy, item)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		config.Enabled = &enabled
	}

	// Set property "HttpProxy":
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		config.HttpProxy = &httpProxy
	}

	// Set property "HttpsProxy":
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		config.HttpsProxy = &httpsProxy
	}

	// Set property "NoProxy":
	for _, item := range typedInput.NoProxy {
		config.NoProxy = append(config.NoProxy, item)
	}

	// Set property "TrustedCa":
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		config.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS populates our ManagedClusterHTTPProxyConfig_STATUS from the provided source ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS(source *storage.ManagedClusterHTTPProxyConfig_STATUS) error {

	// EffectiveNoProxy
	config.EffectiveNoProxy = genruntime.CloneSliceOfString(source.EffectiveNoProxy)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		config.Enabled = &enabled
	} else {
		config.Enabled = nil
	}

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS populates the provided destination ManagedClusterHTTPProxyConfig_STATUS from our ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS(destination *storage.ManagedClusterHTTPProxyConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EffectiveNoProxy
	destination.EffectiveNoProxy = genruntime.CloneSliceOfString(config.EffectiveNoProxy)

	// Enabled
	if config.Enabled != nil {
		enabled := *config.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the managed cluster.
type ManagedClusterIdentity struct {
	// DelegatedResources: The delegated identity resources assigned to this managed cluster. This can only be set by another
	// Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.
	DelegatedResources map[string]DelegatedResource `json:"delegatedResources,omitempty"`

	// Type: The type of identity used for the managed cluster. For more information see [use managed identities in
	// AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
	Type *ResourceIdentityType `json:"type,omitempty"`

	// UserAssignedIdentities: The user identity associated with the managed cluster. This identity will be used in control
	// plane. Only one user assigned identity is allowed. The keys must be ARM resource IDs in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIdentity{}

	// Set property "DelegatedResources":
	if identity.DelegatedResources != nil {
		result.DelegatedResources = make(map[string]arm.DelegatedResource, len(identity.DelegatedResources))
		for key, value := range identity.DelegatedResources {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.DelegatedResources[key] = *value_ARM.(*arm.DelegatedResource)
		}
	}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ResourceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIdentity, got %T", armInput)
	}

	// Set property "DelegatedResources":
	if typedInput.DelegatedResources != nil {
		identity.DelegatedResources = make(map[string]DelegatedResource, len(typedInput.DelegatedResources))
		for key, value := range typedInput.DelegatedResources {
			var value1 DelegatedResource
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.DelegatedResources[key] = value1
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ResourceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIdentity populates our ManagedClusterIdentity from the provided source ManagedClusterIdentity
func (identity *ManagedClusterIdentity) AssignProperties_From_ManagedClusterIdentity(source *storage.ManagedClusterIdentity) error {

	// DelegatedResources
	if source.DelegatedResources != nil {
		delegatedResourceMap := make(map[string]DelegatedResource, len(source.DelegatedResources))
		for delegatedResourceKey, delegatedResourceValue := range source.DelegatedResources {
			var delegatedResource DelegatedResource
			err := delegatedResource.AssignProperties_From_DelegatedResource(&delegatedResourceValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_DelegatedResource() to populate field DelegatedResources")
			}
			delegatedResourceMap[delegatedResourceKey] = delegatedResource
		}
		identity.DelegatedResources = delegatedResourceMap
	} else {
		identity.DelegatedResources = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, resourceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIdentity populates the provided destination ManagedClusterIdentity from our ManagedClusterIdentity
func (identity *ManagedClusterIdentity) AssignProperties_To_ManagedClusterIdentity(destination *storage.ManagedClusterIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelegatedResources
	if identity.DelegatedResources != nil {
		delegatedResourceMap := make(map[string]storage.DelegatedResource, len(identity.DelegatedResources))
		for delegatedResourceKey, delegatedResourceValue := range identity.DelegatedResources {
			var delegatedResource storage.DelegatedResource
			err := delegatedResourceValue.AssignProperties_To_DelegatedResource(&delegatedResource)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_DelegatedResource() to populate field DelegatedResources")
			}
			delegatedResourceMap[delegatedResourceKey] = delegatedResource
		}
		destination.DelegatedResources = delegatedResourceMap
	} else {
		destination.DelegatedResources = nil
	}

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the managed cluster.
type ManagedClusterIdentity_STATUS struct {
	// DelegatedResources: The delegated identity resources assigned to this managed cluster. This can only be set by another
	// Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.
	DelegatedResources map[string]DelegatedResource_STATUS `json:"delegatedResources,omitempty"`

	// PrincipalId: The principal id of the system assigned identity which is used by master components.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id of the system assigned identity which is used by master components.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the managed cluster. For more information see [use managed identities in
	// AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
	Type *ResourceIdentityType_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The user identity associated with the managed cluster. This identity will be used in control
	// plane. Only one user assigned identity is allowed. The keys must be ARM resource IDs in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIdentity_STATUS, got %T", armInput)
	}

	// Set property "DelegatedResources":
	if typedInput.DelegatedResources != nil {
		identity.DelegatedResources = make(map[string]DelegatedResource_STATUS, len(typedInput.DelegatedResources))
		for key, value := range typedInput.DelegatedResources {
			var value1 DelegatedResource_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.DelegatedResources[key] = value1
		}
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ResourceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIdentity_STATUS populates our ManagedClusterIdentity_STATUS from the provided source ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignProperties_From_ManagedClusterIdentity_STATUS(source *storage.ManagedClusterIdentity_STATUS) error {

	// DelegatedResources
	if source.DelegatedResources != nil {
		delegatedResourceMap := make(map[string]DelegatedResource_STATUS, len(source.DelegatedResources))
		for delegatedResourceKey, delegatedResourceValue := range source.DelegatedResources {
			var delegatedResource DelegatedResource_STATUS
			err := delegatedResource.AssignProperties_From_DelegatedResource_STATUS(&delegatedResourceValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_DelegatedResource_STATUS() to populate field DelegatedResources")
			}
			delegatedResourceMap[delegatedResourceKey] = delegatedResource
		}
		identity.DelegatedResources = delegatedResourceMap
	} else {
		identity.DelegatedResources = nil
	}

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, resourceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			var userAssignedIdentity ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIdentity_STATUS populates the provided destination ManagedClusterIdentity_STATUS from our ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignProperties_To_ManagedClusterIdentity_STATUS(destination *storage.ManagedClusterIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelegatedResources
	if identity.DelegatedResources != nil {
		delegatedResourceMap := make(map[string]storage.DelegatedResource_STATUS, len(identity.DelegatedResources))
		for delegatedResourceKey, delegatedResourceValue := range identity.DelegatedResources {
			var delegatedResource storage.DelegatedResource_STATUS
			err := delegatedResourceValue.AssignProperties_To_DelegatedResource_STATUS(&delegatedResource)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_DelegatedResource_STATUS() to populate field DelegatedResources")
			}
			delegatedResourceMap[delegatedResourceKey] = delegatedResource
		}
		destination.DelegatedResources = delegatedResourceMap
	} else {
		destination.DelegatedResources = nil
	}

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Ingress profile for the container service cluster.
type ManagedClusterIngressProfile struct {
	// ApplicationLoadBalancer: Settings for the managed Application Load Balancer installation
	ApplicationLoadBalancer *ManagedClusterIngressProfileApplicationLoadBalancer `json:"applicationLoadBalancer,omitempty"`

	// GatewayAPI: Settings for the managed Gateway API installation
	GatewayAPI *ManagedClusterIngressProfileGatewayConfiguration `json:"gatewayAPI,omitempty"`

	// WebAppRouting: App Routing settings for the ingress profile. You can find an overview and onboarding guide for this
	// feature at https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default.
	WebAppRouting *ManagedClusterIngressProfileWebAppRouting `json:"webAppRouting,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIngressProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterIngressProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIngressProfile{}

	// Set property "ApplicationLoadBalancer":
	if profile.ApplicationLoadBalancer != nil {
		applicationLoadBalancer_ARM, err := profile.ApplicationLoadBalancer.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		applicationLoadBalancer := *applicationLoadBalancer_ARM.(*arm.ManagedClusterIngressProfileApplicationLoadBalancer)
		result.ApplicationLoadBalancer = &applicationLoadBalancer
	}

	// Set property "GatewayAPI":
	if profile.GatewayAPI != nil {
		gatewayAPI_ARM, err := profile.GatewayAPI.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gatewayAPI := *gatewayAPI_ARM.(*arm.ManagedClusterIngressProfileGatewayConfiguration)
		result.GatewayAPI = &gatewayAPI
	}

	// Set property "WebAppRouting":
	if profile.WebAppRouting != nil {
		webAppRouting_ARM, err := profile.WebAppRouting.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		webAppRouting := *webAppRouting_ARM.(*arm.ManagedClusterIngressProfileWebAppRouting)
		result.WebAppRouting = &webAppRouting
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterIngressProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterIngressProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfile, got %T", armInput)
	}

	// Set property "ApplicationLoadBalancer":
	if typedInput.ApplicationLoadBalancer != nil {
		var applicationLoadBalancer1 ManagedClusterIngressProfileApplicationLoadBalancer
		err := applicationLoadBalancer1.PopulateFromARM(owner, *typedInput.ApplicationLoadBalancer)
		if err != nil {
			return err
		}
		applicationLoadBalancer := applicationLoadBalancer1
		profile.ApplicationLoadBalancer = &applicationLoadBalancer
	}

	// Set property "GatewayAPI":
	if typedInput.GatewayAPI != nil {
		var gatewayAPI1 ManagedClusterIngressProfileGatewayConfiguration
		err := gatewayAPI1.PopulateFromARM(owner, *typedInput.GatewayAPI)
		if err != nil {
			return err
		}
		gatewayAPI := gatewayAPI1
		profile.GatewayAPI = &gatewayAPI
	}

	// Set property "WebAppRouting":
	if typedInput.WebAppRouting != nil {
		var webAppRouting1 ManagedClusterIngressProfileWebAppRouting
		err := webAppRouting1.PopulateFromARM(owner, *typedInput.WebAppRouting)
		if err != nil {
			return err
		}
		webAppRouting := webAppRouting1
		profile.WebAppRouting = &webAppRouting
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfile populates our ManagedClusterIngressProfile from the provided source ManagedClusterIngressProfile
func (profile *ManagedClusterIngressProfile) AssignProperties_From_ManagedClusterIngressProfile(source *storage.ManagedClusterIngressProfile) error {

	// ApplicationLoadBalancer
	if source.ApplicationLoadBalancer != nil {
		var applicationLoadBalancer ManagedClusterIngressProfileApplicationLoadBalancer
		err := applicationLoadBalancer.AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer(source.ApplicationLoadBalancer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer() to populate field ApplicationLoadBalancer")
		}
		profile.ApplicationLoadBalancer = &applicationLoadBalancer
	} else {
		profile.ApplicationLoadBalancer = nil
	}

	// GatewayAPI
	if source.GatewayAPI != nil {
		var gatewayAPI ManagedClusterIngressProfileGatewayConfiguration
		err := gatewayAPI.AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration(source.GatewayAPI)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration() to populate field GatewayAPI")
		}
		profile.GatewayAPI = &gatewayAPI
	} else {
		profile.GatewayAPI = nil
	}

	// WebAppRouting
	if source.WebAppRouting != nil {
		var webAppRouting ManagedClusterIngressProfileWebAppRouting
		err := webAppRouting.AssignProperties_From_ManagedClusterIngressProfileWebAppRouting(source.WebAppRouting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileWebAppRouting() to populate field WebAppRouting")
		}
		profile.WebAppRouting = &webAppRouting
	} else {
		profile.WebAppRouting = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfile populates the provided destination ManagedClusterIngressProfile from our ManagedClusterIngressProfile
func (profile *ManagedClusterIngressProfile) AssignProperties_To_ManagedClusterIngressProfile(destination *storage.ManagedClusterIngressProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationLoadBalancer
	if profile.ApplicationLoadBalancer != nil {
		var applicationLoadBalancer storage.ManagedClusterIngressProfileApplicationLoadBalancer
		err := profile.ApplicationLoadBalancer.AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer(&applicationLoadBalancer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer() to populate field ApplicationLoadBalancer")
		}
		destination.ApplicationLoadBalancer = &applicationLoadBalancer
	} else {
		destination.ApplicationLoadBalancer = nil
	}

	// GatewayAPI
	if profile.GatewayAPI != nil {
		var gatewayAPI storage.ManagedClusterIngressProfileGatewayConfiguration
		err := profile.GatewayAPI.AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration(&gatewayAPI)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration() to populate field GatewayAPI")
		}
		destination.GatewayAPI = &gatewayAPI
	} else {
		destination.GatewayAPI = nil
	}

	// WebAppRouting
	if profile.WebAppRouting != nil {
		var webAppRouting storage.ManagedClusterIngressProfileWebAppRouting
		err := profile.WebAppRouting.AssignProperties_To_ManagedClusterIngressProfileWebAppRouting(&webAppRouting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileWebAppRouting() to populate field WebAppRouting")
		}
		destination.WebAppRouting = &webAppRouting
	} else {
		destination.WebAppRouting = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Ingress profile for the container service cluster.
type ManagedClusterIngressProfile_STATUS struct {
	// ApplicationLoadBalancer: Settings for the managed Application Load Balancer installation
	ApplicationLoadBalancer *ManagedClusterIngressProfileApplicationLoadBalancer_STATUS `json:"applicationLoadBalancer,omitempty"`

	// GatewayAPI: Settings for the managed Gateway API installation
	GatewayAPI *ManagedClusterIngressProfileGatewayConfiguration_STATUS `json:"gatewayAPI,omitempty"`

	// WebAppRouting: App Routing settings for the ingress profile. You can find an overview and onboarding guide for this
	// feature at https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default.
	WebAppRouting *ManagedClusterIngressProfileWebAppRouting_STATUS `json:"webAppRouting,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIngressProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterIngressProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterIngressProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfile_STATUS, got %T", armInput)
	}

	// Set property "ApplicationLoadBalancer":
	if typedInput.ApplicationLoadBalancer != nil {
		var applicationLoadBalancer1 ManagedClusterIngressProfileApplicationLoadBalancer_STATUS
		err := applicationLoadBalancer1.PopulateFromARM(owner, *typedInput.ApplicationLoadBalancer)
		if err != nil {
			return err
		}
		applicationLoadBalancer := applicationLoadBalancer1
		profile.ApplicationLoadBalancer = &applicationLoadBalancer
	}

	// Set property "GatewayAPI":
	if typedInput.GatewayAPI != nil {
		var gatewayAPI1 ManagedClusterIngressProfileGatewayConfiguration_STATUS
		err := gatewayAPI1.PopulateFromARM(owner, *typedInput.GatewayAPI)
		if err != nil {
			return err
		}
		gatewayAPI := gatewayAPI1
		profile.GatewayAPI = &gatewayAPI
	}

	// Set property "WebAppRouting":
	if typedInput.WebAppRouting != nil {
		var webAppRouting1 ManagedClusterIngressProfileWebAppRouting_STATUS
		err := webAppRouting1.PopulateFromARM(owner, *typedInput.WebAppRouting)
		if err != nil {
			return err
		}
		webAppRouting := webAppRouting1
		profile.WebAppRouting = &webAppRouting
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfile_STATUS populates our ManagedClusterIngressProfile_STATUS from the provided source ManagedClusterIngressProfile_STATUS
func (profile *ManagedClusterIngressProfile_STATUS) AssignProperties_From_ManagedClusterIngressProfile_STATUS(source *storage.ManagedClusterIngressProfile_STATUS) error {

	// ApplicationLoadBalancer
	if source.ApplicationLoadBalancer != nil {
		var applicationLoadBalancer ManagedClusterIngressProfileApplicationLoadBalancer_STATUS
		err := applicationLoadBalancer.AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS(source.ApplicationLoadBalancer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS() to populate field ApplicationLoadBalancer")
		}
		profile.ApplicationLoadBalancer = &applicationLoadBalancer
	} else {
		profile.ApplicationLoadBalancer = nil
	}

	// GatewayAPI
	if source.GatewayAPI != nil {
		var gatewayAPI ManagedClusterIngressProfileGatewayConfiguration_STATUS
		err := gatewayAPI.AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration_STATUS(source.GatewayAPI)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration_STATUS() to populate field GatewayAPI")
		}
		profile.GatewayAPI = &gatewayAPI
	} else {
		profile.GatewayAPI = nil
	}

	// WebAppRouting
	if source.WebAppRouting != nil {
		var webAppRouting ManagedClusterIngressProfileWebAppRouting_STATUS
		err := webAppRouting.AssignProperties_From_ManagedClusterIngressProfileWebAppRouting_STATUS(source.WebAppRouting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileWebAppRouting_STATUS() to populate field WebAppRouting")
		}
		profile.WebAppRouting = &webAppRouting
	} else {
		profile.WebAppRouting = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfile_STATUS populates the provided destination ManagedClusterIngressProfile_STATUS from our ManagedClusterIngressProfile_STATUS
func (profile *ManagedClusterIngressProfile_STATUS) AssignProperties_To_ManagedClusterIngressProfile_STATUS(destination *storage.ManagedClusterIngressProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationLoadBalancer
	if profile.ApplicationLoadBalancer != nil {
		var applicationLoadBalancer storage.ManagedClusterIngressProfileApplicationLoadBalancer_STATUS
		err := profile.ApplicationLoadBalancer.AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS(&applicationLoadBalancer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS() to populate field ApplicationLoadBalancer")
		}
		destination.ApplicationLoadBalancer = &applicationLoadBalancer
	} else {
		destination.ApplicationLoadBalancer = nil
	}

	// GatewayAPI
	if profile.GatewayAPI != nil {
		var gatewayAPI storage.ManagedClusterIngressProfileGatewayConfiguration_STATUS
		err := profile.GatewayAPI.AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration_STATUS(&gatewayAPI)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration_STATUS() to populate field GatewayAPI")
		}
		destination.GatewayAPI = &gatewayAPI
	} else {
		destination.GatewayAPI = nil
	}

	// WebAppRouting
	if profile.WebAppRouting != nil {
		var webAppRouting storage.ManagedClusterIngressProfileWebAppRouting_STATUS
		err := profile.WebAppRouting.AssignProperties_To_ManagedClusterIngressProfileWebAppRouting_STATUS(&webAppRouting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileWebAppRouting_STATUS() to populate field WebAppRouting")
		}
		destination.WebAppRouting = &webAppRouting
	} else {
		destination.WebAppRouting = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The metrics profile for the ManagedCluster.
type ManagedClusterMetricsProfile struct {
	// CostAnalysis: The configuration for detailed per-Kubernetes resource cost analysis.
	CostAnalysis *ManagedClusterCostAnalysis `json:"costAnalysis,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterMetricsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterMetricsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterMetricsProfile{}

	// Set property "CostAnalysis":
	if profile.CostAnalysis != nil {
		costAnalysis_ARM, err := profile.CostAnalysis.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		costAnalysis := *costAnalysis_ARM.(*arm.ManagedClusterCostAnalysis)
		result.CostAnalysis = &costAnalysis
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterMetricsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterMetricsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterMetricsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterMetricsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterMetricsProfile, got %T", armInput)
	}

	// Set property "CostAnalysis":
	if typedInput.CostAnalysis != nil {
		var costAnalysis1 ManagedClusterCostAnalysis
		err := costAnalysis1.PopulateFromARM(owner, *typedInput.CostAnalysis)
		if err != nil {
			return err
		}
		costAnalysis := costAnalysis1
		profile.CostAnalysis = &costAnalysis
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterMetricsProfile populates our ManagedClusterMetricsProfile from the provided source ManagedClusterMetricsProfile
func (profile *ManagedClusterMetricsProfile) AssignProperties_From_ManagedClusterMetricsProfile(source *storage.ManagedClusterMetricsProfile) error {

	// CostAnalysis
	if source.CostAnalysis != nil {
		var costAnalysis ManagedClusterCostAnalysis
		err := costAnalysis.AssignProperties_From_ManagedClusterCostAnalysis(source.CostAnalysis)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterCostAnalysis() to populate field CostAnalysis")
		}
		profile.CostAnalysis = &costAnalysis
	} else {
		profile.CostAnalysis = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterMetricsProfile populates the provided destination ManagedClusterMetricsProfile from our ManagedClusterMetricsProfile
func (profile *ManagedClusterMetricsProfile) AssignProperties_To_ManagedClusterMetricsProfile(destination *storage.ManagedClusterMetricsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CostAnalysis
	if profile.CostAnalysis != nil {
		var costAnalysis storage.ManagedClusterCostAnalysis
		err := profile.CostAnalysis.AssignProperties_To_ManagedClusterCostAnalysis(&costAnalysis)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterCostAnalysis() to populate field CostAnalysis")
		}
		destination.CostAnalysis = &costAnalysis
	} else {
		destination.CostAnalysis = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The metrics profile for the ManagedCluster.
type ManagedClusterMetricsProfile_STATUS struct {
	// CostAnalysis: The configuration for detailed per-Kubernetes resource cost analysis.
	CostAnalysis *ManagedClusterCostAnalysis_STATUS `json:"costAnalysis,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterMetricsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterMetricsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterMetricsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterMetricsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterMetricsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterMetricsProfile_STATUS, got %T", armInput)
	}

	// Set property "CostAnalysis":
	if typedInput.CostAnalysis != nil {
		var costAnalysis1 ManagedClusterCostAnalysis_STATUS
		err := costAnalysis1.PopulateFromARM(owner, *typedInput.CostAnalysis)
		if err != nil {
			return err
		}
		costAnalysis := costAnalysis1
		profile.CostAnalysis = &costAnalysis
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterMetricsProfile_STATUS populates our ManagedClusterMetricsProfile_STATUS from the provided source ManagedClusterMetricsProfile_STATUS
func (profile *ManagedClusterMetricsProfile_STATUS) AssignProperties_From_ManagedClusterMetricsProfile_STATUS(source *storage.ManagedClusterMetricsProfile_STATUS) error {

	// CostAnalysis
	if source.CostAnalysis != nil {
		var costAnalysis ManagedClusterCostAnalysis_STATUS
		err := costAnalysis.AssignProperties_From_ManagedClusterCostAnalysis_STATUS(source.CostAnalysis)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterCostAnalysis_STATUS() to populate field CostAnalysis")
		}
		profile.CostAnalysis = &costAnalysis
	} else {
		profile.CostAnalysis = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterMetricsProfile_STATUS populates the provided destination ManagedClusterMetricsProfile_STATUS from our ManagedClusterMetricsProfile_STATUS
func (profile *ManagedClusterMetricsProfile_STATUS) AssignProperties_To_ManagedClusterMetricsProfile_STATUS(destination *storage.ManagedClusterMetricsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CostAnalysis
	if profile.CostAnalysis != nil {
		var costAnalysis storage.ManagedClusterCostAnalysis_STATUS
		err := profile.CostAnalysis.AssignProperties_To_ManagedClusterCostAnalysis_STATUS(&costAnalysis)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterCostAnalysis_STATUS() to populate field CostAnalysis")
		}
		destination.CostAnalysis = &costAnalysis
	} else {
		destination.CostAnalysis = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterNodeProvisioningProfile struct {
	// DefaultNodePools: The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has no
	// effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default
	// Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools. It is strongly
	// recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified,
	// the default is Auto. For more information see aka.ms/aks/nap#node-pools.
	DefaultNodePools *ManagedClusterNodeProvisioningProfile_DefaultNodePools `json:"defaultNodePools,omitempty"`

	// Mode: The node provisioning mode. If not specified, the default is Manual.
	Mode *NodeProvisioningMode `json:"mode,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterNodeProvisioningProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterNodeProvisioningProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterNodeProvisioningProfile{}

	// Set property "DefaultNodePools":
	if profile.DefaultNodePools != nil {
		var temp string
		temp = string(*profile.DefaultNodePools)
		defaultNodePools := arm.ManagedClusterNodeProvisioningProfile_DefaultNodePools(temp)
		result.DefaultNodePools = &defaultNodePools
	}

	// Set property "Mode":
	if profile.Mode != nil {
		var temp string
		temp = string(*profile.Mode)
		mode := arm.NodeProvisioningMode(temp)
		result.Mode = &mode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterNodeProvisioningProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterNodeProvisioningProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterNodeProvisioningProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterNodeProvisioningProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterNodeProvisioningProfile, got %T", armInput)
	}

	// Set property "DefaultNodePools":
	if typedInput.DefaultNodePools != nil {
		var temp string
		temp = string(*typedInput.DefaultNodePools)
		defaultNodePools := ManagedClusterNodeProvisioningProfile_DefaultNodePools(temp)
		profile.DefaultNodePools = &defaultNodePools
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := NodeProvisioningMode(temp)
		profile.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterNodeProvisioningProfile populates our ManagedClusterNodeProvisioningProfile from the provided source ManagedClusterNodeProvisioningProfile
func (profile *ManagedClusterNodeProvisioningProfile) AssignProperties_From_ManagedClusterNodeProvisioningProfile(source *storage.ManagedClusterNodeProvisioningProfile) error {

	// DefaultNodePools
	if source.DefaultNodePools != nil {
		defaultNodePool := *source.DefaultNodePools
		defaultNodePoolTemp := genruntime.ToEnum(defaultNodePool, managedClusterNodeProvisioningProfile_DefaultNodePools_Values)
		profile.DefaultNodePools = &defaultNodePoolTemp
	} else {
		profile.DefaultNodePools = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, nodeProvisioningMode_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterNodeProvisioningProfile populates the provided destination ManagedClusterNodeProvisioningProfile from our ManagedClusterNodeProvisioningProfile
func (profile *ManagedClusterNodeProvisioningProfile) AssignProperties_To_ManagedClusterNodeProvisioningProfile(destination *storage.ManagedClusterNodeProvisioningProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultNodePools
	if profile.DefaultNodePools != nil {
		defaultNodePool := string(*profile.DefaultNodePools)
		destination.DefaultNodePools = &defaultNodePool
	} else {
		destination.DefaultNodePools = nil
	}

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterNodeProvisioningProfile_STATUS struct {
	// DefaultNodePools: The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has no
	// effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default
	// Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools. It is strongly
	// recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified,
	// the default is Auto. For more information see aka.ms/aks/nap#node-pools.
	DefaultNodePools *ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS `json:"defaultNodePools,omitempty"`

	// Mode: The node provisioning mode. If not specified, the default is Manual.
	Mode *NodeProvisioningMode_STATUS `json:"mode,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterNodeProvisioningProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterNodeProvisioningProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterNodeProvisioningProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterNodeProvisioningProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterNodeProvisioningProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterNodeProvisioningProfile_STATUS, got %T", armInput)
	}

	// Set property "DefaultNodePools":
	if typedInput.DefaultNodePools != nil {
		var temp string
		temp = string(*typedInput.DefaultNodePools)
		defaultNodePools := ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS(temp)
		profile.DefaultNodePools = &defaultNodePools
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := NodeProvisioningMode_STATUS(temp)
		profile.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterNodeProvisioningProfile_STATUS populates our ManagedClusterNodeProvisioningProfile_STATUS from the provided source ManagedClusterNodeProvisioningProfile_STATUS
func (profile *ManagedClusterNodeProvisioningProfile_STATUS) AssignProperties_From_ManagedClusterNodeProvisioningProfile_STATUS(source *storage.ManagedClusterNodeProvisioningProfile_STATUS) error {

	// DefaultNodePools
	if source.DefaultNodePools != nil {
		defaultNodePool := *source.DefaultNodePools
		defaultNodePoolTemp := genruntime.ToEnum(defaultNodePool, managedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Values)
		profile.DefaultNodePools = &defaultNodePoolTemp
	} else {
		profile.DefaultNodePools = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, nodeProvisioningMode_STATUS_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterNodeProvisioningProfile_STATUS populates the provided destination ManagedClusterNodeProvisioningProfile_STATUS from our ManagedClusterNodeProvisioningProfile_STATUS
func (profile *ManagedClusterNodeProvisioningProfile_STATUS) AssignProperties_To_ManagedClusterNodeProvisioningProfile_STATUS(destination *storage.ManagedClusterNodeProvisioningProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultNodePools
	if profile.DefaultNodePools != nil {
		defaultNodePool := string(*profile.DefaultNodePools)
		destination.DefaultNodePools = &defaultNodePool
	} else {
		destination.DefaultNodePools = nil
	}

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Node resource group lockdown profile for a managed cluster.
type ManagedClusterNodeResourceGroupProfile struct {
	// RestrictionLevel: The restriction level applied to the cluster's node resource group. If not specified, the default is
	// 'Unrestricted'
	RestrictionLevel *RestrictionLevel `json:"restrictionLevel,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterNodeResourceGroupProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterNodeResourceGroupProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterNodeResourceGroupProfile{}

	// Set property "RestrictionLevel":
	if profile.RestrictionLevel != nil {
		var temp string
		temp = string(*profile.RestrictionLevel)
		restrictionLevel := arm.RestrictionLevel(temp)
		result.RestrictionLevel = &restrictionLevel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterNodeResourceGroupProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterNodeResourceGroupProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterNodeResourceGroupProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterNodeResourceGroupProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterNodeResourceGroupProfile, got %T", armInput)
	}

	// Set property "RestrictionLevel":
	if typedInput.RestrictionLevel != nil {
		var temp string
		temp = string(*typedInput.RestrictionLevel)
		restrictionLevel := RestrictionLevel(temp)
		profile.RestrictionLevel = &restrictionLevel
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterNodeResourceGroupProfile populates our ManagedClusterNodeResourceGroupProfile from the provided source ManagedClusterNodeResourceGroupProfile
func (profile *ManagedClusterNodeResourceGroupProfile) AssignProperties_From_ManagedClusterNodeResourceGroupProfile(source *storage.ManagedClusterNodeResourceGroupProfile) error {

	// RestrictionLevel
	if source.RestrictionLevel != nil {
		restrictionLevel := *source.RestrictionLevel
		restrictionLevelTemp := genruntime.ToEnum(restrictionLevel, restrictionLevel_Values)
		profile.RestrictionLevel = &restrictionLevelTemp
	} else {
		profile.RestrictionLevel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterNodeResourceGroupProfile populates the provided destination ManagedClusterNodeResourceGroupProfile from our ManagedClusterNodeResourceGroupProfile
func (profile *ManagedClusterNodeResourceGroupProfile) AssignProperties_To_ManagedClusterNodeResourceGroupProfile(destination *storage.ManagedClusterNodeResourceGroupProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RestrictionLevel
	if profile.RestrictionLevel != nil {
		restrictionLevel := string(*profile.RestrictionLevel)
		destination.RestrictionLevel = &restrictionLevel
	} else {
		destination.RestrictionLevel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Node resource group lockdown profile for a managed cluster.
type ManagedClusterNodeResourceGroupProfile_STATUS struct {
	// RestrictionLevel: The restriction level applied to the cluster's node resource group. If not specified, the default is
	// 'Unrestricted'
	RestrictionLevel *RestrictionLevel_STATUS `json:"restrictionLevel,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterNodeResourceGroupProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterNodeResourceGroupProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterNodeResourceGroupProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterNodeResourceGroupProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterNodeResourceGroupProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterNodeResourceGroupProfile_STATUS, got %T", armInput)
	}

	// Set property "RestrictionLevel":
	if typedInput.RestrictionLevel != nil {
		var temp string
		temp = string(*typedInput.RestrictionLevel)
		restrictionLevel := RestrictionLevel_STATUS(temp)
		profile.RestrictionLevel = &restrictionLevel
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterNodeResourceGroupProfile_STATUS populates our ManagedClusterNodeResourceGroupProfile_STATUS from the provided source ManagedClusterNodeResourceGroupProfile_STATUS
func (profile *ManagedClusterNodeResourceGroupProfile_STATUS) AssignProperties_From_ManagedClusterNodeResourceGroupProfile_STATUS(source *storage.ManagedClusterNodeResourceGroupProfile_STATUS) error {

	// RestrictionLevel
	if source.RestrictionLevel != nil {
		restrictionLevel := *source.RestrictionLevel
		restrictionLevelTemp := genruntime.ToEnum(restrictionLevel, restrictionLevel_STATUS_Values)
		profile.RestrictionLevel = &restrictionLevelTemp
	} else {
		profile.RestrictionLevel = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterNodeResourceGroupProfile_STATUS populates the provided destination ManagedClusterNodeResourceGroupProfile_STATUS from our ManagedClusterNodeResourceGroupProfile_STATUS
func (profile *ManagedClusterNodeResourceGroupProfile_STATUS) AssignProperties_To_ManagedClusterNodeResourceGroupProfile_STATUS(destination *storage.ManagedClusterNodeResourceGroupProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RestrictionLevel
	if profile.RestrictionLevel != nil {
		restrictionLevel := string(*profile.RestrictionLevel)
		destination.RestrictionLevel = &restrictionLevel
	} else {
		destination.RestrictionLevel = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The OIDC issuer profile of the Managed Cluster.
type ManagedClusterOIDCIssuerProfile struct {
	// Enabled: Whether the OIDC issuer is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterOIDCIssuerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterOIDCIssuerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterOIDCIssuerProfile{}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterOIDCIssuerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterOIDCIssuerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterOIDCIssuerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterOIDCIssuerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterOIDCIssuerProfile, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterOIDCIssuerProfile populates our ManagedClusterOIDCIssuerProfile from the provided source ManagedClusterOIDCIssuerProfile
func (profile *ManagedClusterOIDCIssuerProfile) AssignProperties_From_ManagedClusterOIDCIssuerProfile(source *storage.ManagedClusterOIDCIssuerProfile) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOIDCIssuerProfile populates the provided destination ManagedClusterOIDCIssuerProfile from our ManagedClusterOIDCIssuerProfile
func (profile *ManagedClusterOIDCIssuerProfile) AssignProperties_To_ManagedClusterOIDCIssuerProfile(destination *storage.ManagedClusterOIDCIssuerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The OIDC issuer profile of the Managed Cluster.
type ManagedClusterOIDCIssuerProfile_STATUS struct {
	// Enabled: Whether the OIDC issuer is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// IssuerURL: The OIDC issuer url of the Managed Cluster.
	IssuerURL *string `json:"issuerURL,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterOIDCIssuerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterOIDCIssuerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterOIDCIssuerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterOIDCIssuerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterOIDCIssuerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterOIDCIssuerProfile_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "IssuerURL":
	if typedInput.IssuerURL != nil {
		issuerURL := *typedInput.IssuerURL
		profile.IssuerURL = &issuerURL
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterOIDCIssuerProfile_STATUS populates our ManagedClusterOIDCIssuerProfile_STATUS from the provided source ManagedClusterOIDCIssuerProfile_STATUS
func (profile *ManagedClusterOIDCIssuerProfile_STATUS) AssignProperties_From_ManagedClusterOIDCIssuerProfile_STATUS(source *storage.ManagedClusterOIDCIssuerProfile_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// IssuerURL
	profile.IssuerURL = genruntime.ClonePointerToString(source.IssuerURL)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOIDCIssuerProfile_STATUS populates the provided destination ManagedClusterOIDCIssuerProfile_STATUS from our ManagedClusterOIDCIssuerProfile_STATUS
func (profile *ManagedClusterOIDCIssuerProfile_STATUS) AssignProperties_To_ManagedClusterOIDCIssuerProfile_STATUS(destination *storage.ManagedClusterOIDCIssuerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IssuerURL
	destination.IssuerURL = genruntime.ClonePointerToString(profile.IssuerURL)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ManagedClusterOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *ManagedClusterOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *ManagedClusterOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorSpec populates our ManagedClusterOperatorSpec from the provided source ManagedClusterOperatorSpec
func (operator *ManagedClusterOperatorSpec) AssignProperties_From_ManagedClusterOperatorSpec(source *storage.ManagedClusterOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap ManagedClusterOperatorConfigMaps
		err := configMap.AssignProperties_From_ManagedClusterOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret ManagedClusterOperatorSecrets
		err := secret.AssignProperties_From_ManagedClusterOperatorSecrets(source.Secrets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorSpec populates the provided destination ManagedClusterOperatorSpec from our ManagedClusterOperatorSpec
func (operator *ManagedClusterOperatorSpec) AssignProperties_To_ManagedClusterOperatorSpec(destination *storage.ManagedClusterOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.ManagedClusterOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_ManagedClusterOperatorConfigMaps(&configMap)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.ManagedClusterOperatorSecrets
		err := operator.Secrets.AssignProperties_To_ManagedClusterOperatorSecrets(&secret)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The pod identity profile of the Managed Cluster. See [use AAD pod
// identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on pod identity integration.
type ManagedClusterPodIdentityProfile struct {
	// AllowNetworkPluginKubenet: Whether pod identity is allowed to run on clusters with Kubenet networking. Running in
	// Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See
	// [using Kubenet network plugin with AAD Pod
	// Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
	// for more information.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	// Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// UserAssignedIdentities: The pod identities to use in the cluster.
	UserAssignedIdentities []ManagedClusterPodIdentity `json:"userAssignedIdentities,omitempty"`

	// UserAssignedIdentityExceptions: The pod identity exceptions to allow.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterPodIdentityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPodIdentityProfile{}

	// Set property "AllowNetworkPluginKubenet":
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		result.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}

	// Set property "UserAssignedIdentities":
	for _, item := range profile.UserAssignedIdentities {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentities = append(result.UserAssignedIdentities, *item_ARM.(*arm.ManagedClusterPodIdentity))
	}

	// Set property "UserAssignedIdentityExceptions":
	for _, item := range profile.UserAssignedIdentityExceptions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentityExceptions = append(result.UserAssignedIdentityExceptions, *item_ARM.(*arm.ManagedClusterPodIdentityException))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPodIdentityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPodIdentityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProfile, got %T", armInput)
	}

	// Set property "AllowNetworkPluginKubenet":
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "UserAssignedIdentities":
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentities = append(profile.UserAssignedIdentities, item1)
	}

	// Set property "UserAssignedIdentityExceptions":
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentityExceptions = append(profile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProfile populates our ManagedClusterPodIdentityProfile from the provided source ManagedClusterPodIdentityProfile
func (profile *ManagedClusterPodIdentityProfile) AssignProperties_From_ManagedClusterPodIdentityProfile(source *storage.ManagedClusterPodIdentityProfile) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			var userAssignedIdentity ManagedClusterPodIdentity
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterPodIdentity(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			var userAssignedIdentityException ManagedClusterPodIdentityException
			err := userAssignedIdentityException.AssignProperties_From_ManagedClusterPodIdentityException(&userAssignedIdentityExceptionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityException() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProfile populates the provided destination ManagedClusterPodIdentityProfile from our ManagedClusterPodIdentityProfile
func (profile *ManagedClusterPodIdentityProfile) AssignProperties_To_ManagedClusterPodIdentityProfile(destination *storage.ManagedClusterPodIdentityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.ManagedClusterPodIdentity, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			var userAssignedIdentity storage.ManagedClusterPodIdentity
			err := userAssignedIdentityItem.AssignProperties_To_ManagedClusterPodIdentity(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]storage.ManagedClusterPodIdentityException, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			var userAssignedIdentityException storage.ManagedClusterPodIdentityException
			err := userAssignedIdentityExceptionItem.AssignProperties_To_ManagedClusterPodIdentityException(&userAssignedIdentityException)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityException() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The pod identity profile of the Managed Cluster. See [use AAD pod
// identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on pod identity integration.
type ManagedClusterPodIdentityProfile_STATUS struct {
	// AllowNetworkPluginKubenet: Whether pod identity is allowed to run on clusters with Kubenet networking. Running in
	// Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See
	// [using Kubenet network plugin with AAD Pod
	// Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
	// for more information.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	// Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// UserAssignedIdentities: The pod identities to use in the cluster.
	UserAssignedIdentities []ManagedClusterPodIdentity_STATUS `json:"userAssignedIdentities,omitempty"`

	// UserAssignedIdentityExceptions: The pod identity exceptions to allow.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_STATUS `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPodIdentityProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPodIdentityProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProfile_STATUS, got %T", armInput)
	}

	// Set property "AllowNetworkPluginKubenet":
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "UserAssignedIdentities":
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentities = append(profile.UserAssignedIdentities, item1)
	}

	// Set property "UserAssignedIdentityExceptions":
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.UserAssignedIdentityExceptions = append(profile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS populates our ManagedClusterPodIdentityProfile_STATUS from the provided source ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS(source *storage.ManagedClusterPodIdentityProfile_STATUS) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			var userAssignedIdentity ManagedClusterPodIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterPodIdentity_STATUS(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException_STATUS, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			var userAssignedIdentityException ManagedClusterPodIdentityException_STATUS
			err := userAssignedIdentityException.AssignProperties_From_ManagedClusterPodIdentityException_STATUS(&userAssignedIdentityExceptionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS populates the provided destination ManagedClusterPodIdentityProfile_STATUS from our ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS(destination *storage.ManagedClusterPodIdentityProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.ManagedClusterPodIdentity_STATUS, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			var userAssignedIdentity storage.ManagedClusterPodIdentity_STATUS
			err := userAssignedIdentityItem.AssignProperties_To_ManagedClusterPodIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]storage.ManagedClusterPodIdentityException_STATUS, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			var userAssignedIdentityException storage.ManagedClusterPodIdentityException_STATUS
			err := userAssignedIdentityExceptionItem.AssignProperties_To_ManagedClusterPodIdentityException_STATUS(&userAssignedIdentityException)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to be applied to the cluster-autoscaler when enabled
type ManagedClusterPropertiesAutoScalerProfile struct {
	// BalanceSimilarNodeGroups: Detects similar node pools and balances the number of nodes between them. Valid values are
	// 'true' and 'false'
	BalanceSimilarNodeGroups *string `json:"balance-similar-node-groups,omitempty"`

	// DaemonsetEvictionForEmptyNodes: DaemonSet pods will be gracefully terminated from empty nodes. If set to true, all
	// daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted
	// another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods
	// are deleted or evicted.
	DaemonsetEvictionForEmptyNodes *bool `json:"daemonset-eviction-for-empty-nodes,omitempty"`

	// DaemonsetEvictionForOccupiedNodes: DaemonSet pods will be gracefully terminated from non-empty nodes. If set to true,
	// all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted
	// another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods
	// are deleted or evicted.
	DaemonsetEvictionForOccupiedNodes *bool `json:"daemonset-eviction-for-occupied-nodes,omitempty"`

	// Expander: The expander to use when scaling up. If not specified, the default is 'random'. See
	// [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more
	// information.
	Expander *Expander `json:"expander,omitempty"`

	// IgnoreDaemonsetsUtilization: Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. If
	// set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
	IgnoreDaemonsetsUtilization *bool `json:"ignore-daemonsets-utilization,omitempty"`

	// MaxEmptyBulkDelete: The maximum number of empty nodes that can be deleted at the same time. This must be a positive
	// integer. The default is 10.
	MaxEmptyBulkDelete *string `json:"max-empty-bulk-delete,omitempty"`

	// MaxGracefulTerminationSec: The maximum number of seconds the cluster autoscaler waits for pod termination when trying to
	// scale down a node. The default is 600.
	MaxGracefulTerminationSec *string `json:"max-graceful-termination-sec,omitempty"`

	// MaxNodeProvisionTime: The maximum time the autoscaler waits for a node to be provisioned. The default is '15m'. Values
	// must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	MaxNodeProvisionTime *string `json:"max-node-provision-time,omitempty"`

	// MaxTotalUnreadyPercentage: The maximum percentage of unready nodes in the cluster. After this percentage is exceeded,
	// cluster autoscaler halts operations. The default is 45. The maximum is 100 and the minimum is 0.
	MaxTotalUnreadyPercentage *string `json:"max-total-unready-percentage,omitempty"`

	// NewPodScaleUpDelay: Ignore unscheduled pods before they're a certain age. For scenarios like burst/batch scale where you
	// don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled
	// pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds,
	// 'm' for minutes, 'h' for hours, etc).
	NewPodScaleUpDelay *string `json:"new-pod-scale-up-delay,omitempty"`

	// OkTotalUnreadyCount: The number of allowed unready nodes, irrespective of max-total-unready-percentage. This must be an
	// integer. The default is 3.
	OkTotalUnreadyCount *string `json:"ok-total-unready-count,omitempty"`

	// ScaleDownDelayAfterAdd: How long after scale up that scale down evaluation resumes. The default is '10m'. Values must be
	// an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterAdd *string `json:"scale-down-delay-after-add,omitempty"`

	// ScaleDownDelayAfterDelete: How long after node deletion that scale down evaluation resumes. The default is the
	// scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterDelete *string `json:"scale-down-delay-after-delete,omitempty"`

	// ScaleDownDelayAfterFailure: How long after scale down failure that scale down evaluation resumes. The default is '3m'.
	// Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterFailure *string `json:"scale-down-delay-after-failure,omitempty"`

	// ScaleDownUnneededTime: How long a node should be unneeded before it is eligible for scale down. The default is '10m'.
	// Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnneededTime *string `json:"scale-down-unneeded-time,omitempty"`

	// ScaleDownUnreadyTime: How long an unready node should be unneeded before it is eligible for scale down. The default is
	// '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnreadyTime *string `json:"scale-down-unready-time,omitempty"`

	// ScaleDownUtilizationThreshold: Node utilization level, defined as sum of requested resources divided by capacity, below
	// which a node can be considered for scale down. The default is '0.5'.
	ScaleDownUtilizationThreshold *string `json:"scale-down-utilization-threshold,omitempty"`

	// ScanInterval: How often cluster is reevaluated for scale up or down. The default is '10'. Values must be an integer
	// number of seconds.
	ScanInterval *string `json:"scan-interval,omitempty"`

	// SkipNodesWithLocalStorage: If cluster autoscaler will skip deleting nodes with pods with local storage, for example,
	// EmptyDir or HostPath. The default is true.
	SkipNodesWithLocalStorage *string `json:"skip-nodes-with-local-storage,omitempty"`

	// SkipNodesWithSystemPods: If cluster autoscaler will skip deleting nodes with pods from kube-system (except for DaemonSet
	// or mirror pods). The default is true.
	SkipNodesWithSystemPods *string `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPropertiesAutoScalerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterPropertiesAutoScalerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPropertiesAutoScalerProfile{}

	// Set property "BalanceSimilarNodeGroups":
	if profile.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *profile.BalanceSimilarNodeGroups
		result.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property "DaemonsetEvictionForEmptyNodes":
	if profile.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNodes := *profile.DaemonsetEvictionForEmptyNodes
		result.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNodes
	}

	// Set property "DaemonsetEvictionForOccupiedNodes":
	if profile.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNodes := *profile.DaemonsetEvictionForOccupiedNodes
		result.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNodes
	}

	// Set property "Expander":
	if profile.Expander != nil {
		var temp string
		temp = string(*profile.Expander)
		expander := arm.Expander(temp)
		result.Expander = &expander
	}

	// Set property "IgnoreDaemonsetsUtilization":
	if profile.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *profile.IgnoreDaemonsetsUtilization
		result.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	}

	// Set property "MaxEmptyBulkDelete":
	if profile.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *profile.MaxEmptyBulkDelete
		result.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property "MaxGracefulTerminationSec":
	if profile.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *profile.MaxGracefulTerminationSec
		result.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property "MaxNodeProvisionTime":
	if profile.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *profile.MaxNodeProvisionTime
		result.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property "MaxTotalUnreadyPercentage":
	if profile.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *profile.MaxTotalUnreadyPercentage
		result.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property "NewPodScaleUpDelay":
	if profile.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *profile.NewPodScaleUpDelay
		result.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property "OkTotalUnreadyCount":
	if profile.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *profile.OkTotalUnreadyCount
		result.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property "ScaleDownDelayAfterAdd":
	if profile.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *profile.ScaleDownDelayAfterAdd
		result.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property "ScaleDownDelayAfterDelete":
	if profile.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *profile.ScaleDownDelayAfterDelete
		result.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property "ScaleDownDelayAfterFailure":
	if profile.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *profile.ScaleDownDelayAfterFailure
		result.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property "ScaleDownUnneededTime":
	if profile.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *profile.ScaleDownUnneededTime
		result.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property "ScaleDownUnreadyTime":
	if profile.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *profile.ScaleDownUnreadyTime
		result.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property "ScaleDownUtilizationThreshold":
	if profile.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *profile.ScaleDownUtilizationThreshold
		result.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property "ScanInterval":
	if profile.ScanInterval != nil {
		scanInterval := *profile.ScanInterval
		result.ScanInterval = &scanInterval
	}

	// Set property "SkipNodesWithLocalStorage":
	if profile.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *profile.SkipNodesWithLocalStorage
		result.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property "SkipNodesWithSystemPods":
	if profile.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *profile.SkipNodesWithSystemPods
		result.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPropertiesAutoScalerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPropertiesAutoScalerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPropertiesAutoScalerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPropertiesAutoScalerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPropertiesAutoScalerProfile, got %T", armInput)
	}

	// Set property "BalanceSimilarNodeGroups":
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		profile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property "DaemonsetEvictionForEmptyNodes":
	if typedInput.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNodes := *typedInput.DaemonsetEvictionForEmptyNodes
		profile.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNodes
	}

	// Set property "DaemonsetEvictionForOccupiedNodes":
	if typedInput.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNodes := *typedInput.DaemonsetEvictionForOccupiedNodes
		profile.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNodes
	}

	// Set property "Expander":
	if typedInput.Expander != nil {
		var temp string
		temp = string(*typedInput.Expander)
		expander := Expander(temp)
		profile.Expander = &expander
	}

	// Set property "IgnoreDaemonsetsUtilization":
	if typedInput.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *typedInput.IgnoreDaemonsetsUtilization
		profile.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	}

	// Set property "MaxEmptyBulkDelete":
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		profile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property "MaxGracefulTerminationSec":
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		profile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property "MaxNodeProvisionTime":
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		profile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property "MaxTotalUnreadyPercentage":
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		profile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property "NewPodScaleUpDelay":
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		profile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property "OkTotalUnreadyCount":
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		profile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property "ScaleDownDelayAfterAdd":
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		profile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property "ScaleDownDelayAfterDelete":
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		profile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property "ScaleDownDelayAfterFailure":
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		profile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property "ScaleDownUnneededTime":
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		profile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property "ScaleDownUnreadyTime":
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		profile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property "ScaleDownUtilizationThreshold":
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		profile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property "ScanInterval":
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		profile.ScanInterval = &scanInterval
	}

	// Set property "SkipNodesWithLocalStorage":
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		profile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property "SkipNodesWithSystemPods":
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		profile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile populates our ManagedClusterPropertiesAutoScalerProfile from the provided source ManagedClusterPropertiesAutoScalerProfile
func (profile *ManagedClusterPropertiesAutoScalerProfile) AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile(source *storage.ManagedClusterPropertiesAutoScalerProfile) error {

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// DaemonsetEvictionForEmptyNodes
	if source.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNode := *source.DaemonsetEvictionForEmptyNodes
		profile.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNode
	} else {
		profile.DaemonsetEvictionForEmptyNodes = nil
	}

	// DaemonsetEvictionForOccupiedNodes
	if source.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNode := *source.DaemonsetEvictionForOccupiedNodes
		profile.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNode
	} else {
		profile.DaemonsetEvictionForOccupiedNodes = nil
	}

	// Expander
	if source.Expander != nil {
		expander := *source.Expander
		expanderTemp := genruntime.ToEnum(expander, expander_Values)
		profile.Expander = &expanderTemp
	} else {
		profile.Expander = nil
	}

	// IgnoreDaemonsetsUtilization
	if source.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *source.IgnoreDaemonsetsUtilization
		profile.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	} else {
		profile.IgnoreDaemonsetsUtilization = nil
	}

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile populates the provided destination ManagedClusterPropertiesAutoScalerProfile from our ManagedClusterPropertiesAutoScalerProfile
func (profile *ManagedClusterPropertiesAutoScalerProfile) AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile(destination *storage.ManagedClusterPropertiesAutoScalerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// DaemonsetEvictionForEmptyNodes
	if profile.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNode := *profile.DaemonsetEvictionForEmptyNodes
		destination.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNode
	} else {
		destination.DaemonsetEvictionForEmptyNodes = nil
	}

	// DaemonsetEvictionForOccupiedNodes
	if profile.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNode := *profile.DaemonsetEvictionForOccupiedNodes
		destination.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNode
	} else {
		destination.DaemonsetEvictionForOccupiedNodes = nil
	}

	// Expander
	if profile.Expander != nil {
		expander := string(*profile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// IgnoreDaemonsetsUtilization
	if profile.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *profile.IgnoreDaemonsetsUtilization
		destination.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	} else {
		destination.IgnoreDaemonsetsUtilization = nil
	}

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters to be applied to the cluster-autoscaler when enabled
type ManagedClusterPropertiesAutoScalerProfile_STATUS struct {
	// BalanceSimilarNodeGroups: Detects similar node pools and balances the number of nodes between them. Valid values are
	// 'true' and 'false'
	BalanceSimilarNodeGroups *string `json:"balance-similar-node-groups,omitempty"`

	// DaemonsetEvictionForEmptyNodes: DaemonSet pods will be gracefully terminated from empty nodes. If set to true, all
	// daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted
	// another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods
	// are deleted or evicted.
	DaemonsetEvictionForEmptyNodes *bool `json:"daemonset-eviction-for-empty-nodes,omitempty"`

	// DaemonsetEvictionForOccupiedNodes: DaemonSet pods will be gracefully terminated from non-empty nodes. If set to true,
	// all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted
	// another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods
	// are deleted or evicted.
	DaemonsetEvictionForOccupiedNodes *bool `json:"daemonset-eviction-for-occupied-nodes,omitempty"`

	// Expander: The expander to use when scaling up. If not specified, the default is 'random'. See
	// [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more
	// information.
	Expander *Expander_STATUS `json:"expander,omitempty"`

	// IgnoreDaemonsetsUtilization: Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. If
	// set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
	IgnoreDaemonsetsUtilization *bool `json:"ignore-daemonsets-utilization,omitempty"`

	// MaxEmptyBulkDelete: The maximum number of empty nodes that can be deleted at the same time. This must be a positive
	// integer. The default is 10.
	MaxEmptyBulkDelete *string `json:"max-empty-bulk-delete,omitempty"`

	// MaxGracefulTerminationSec: The maximum number of seconds the cluster autoscaler waits for pod termination when trying to
	// scale down a node. The default is 600.
	MaxGracefulTerminationSec *string `json:"max-graceful-termination-sec,omitempty"`

	// MaxNodeProvisionTime: The maximum time the autoscaler waits for a node to be provisioned. The default is '15m'. Values
	// must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	MaxNodeProvisionTime *string `json:"max-node-provision-time,omitempty"`

	// MaxTotalUnreadyPercentage: The maximum percentage of unready nodes in the cluster. After this percentage is exceeded,
	// cluster autoscaler halts operations. The default is 45. The maximum is 100 and the minimum is 0.
	MaxTotalUnreadyPercentage *string `json:"max-total-unready-percentage,omitempty"`

	// NewPodScaleUpDelay: Ignore unscheduled pods before they're a certain age. For scenarios like burst/batch scale where you
	// don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled
	// pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds,
	// 'm' for minutes, 'h' for hours, etc).
	NewPodScaleUpDelay *string `json:"new-pod-scale-up-delay,omitempty"`

	// OkTotalUnreadyCount: The number of allowed unready nodes, irrespective of max-total-unready-percentage. This must be an
	// integer. The default is 3.
	OkTotalUnreadyCount *string `json:"ok-total-unready-count,omitempty"`

	// ScaleDownDelayAfterAdd: How long after scale up that scale down evaluation resumes. The default is '10m'. Values must be
	// an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterAdd *string `json:"scale-down-delay-after-add,omitempty"`

	// ScaleDownDelayAfterDelete: How long after node deletion that scale down evaluation resumes. The default is the
	// scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterDelete *string `json:"scale-down-delay-after-delete,omitempty"`

	// ScaleDownDelayAfterFailure: How long after scale down failure that scale down evaluation resumes. The default is '3m'.
	// Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterFailure *string `json:"scale-down-delay-after-failure,omitempty"`

	// ScaleDownUnneededTime: How long a node should be unneeded before it is eligible for scale down. The default is '10m'.
	// Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnneededTime *string `json:"scale-down-unneeded-time,omitempty"`

	// ScaleDownUnreadyTime: How long an unready node should be unneeded before it is eligible for scale down. The default is
	// '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnreadyTime *string `json:"scale-down-unready-time,omitempty"`

	// ScaleDownUtilizationThreshold: Node utilization level, defined as sum of requested resources divided by capacity, below
	// which a node can be considered for scale down. The default is '0.5'.
	ScaleDownUtilizationThreshold *string `json:"scale-down-utilization-threshold,omitempty"`

	// ScanInterval: How often cluster is reevaluated for scale up or down. The default is '10'. Values must be an integer
	// number of seconds.
	ScanInterval *string `json:"scan-interval,omitempty"`

	// SkipNodesWithLocalStorage: If cluster autoscaler will skip deleting nodes with pods with local storage, for example,
	// EmptyDir or HostPath. The default is true.
	SkipNodesWithLocalStorage *string `json:"skip-nodes-with-local-storage,omitempty"`

	// SkipNodesWithSystemPods: If cluster autoscaler will skip deleting nodes with pods from kube-system (except for DaemonSet
	// or mirror pods). The default is true.
	SkipNodesWithSystemPods *string `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPropertiesAutoScalerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterPropertiesAutoScalerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPropertiesAutoScalerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterPropertiesAutoScalerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPropertiesAutoScalerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPropertiesAutoScalerProfile_STATUS, got %T", armInput)
	}

	// Set property "BalanceSimilarNodeGroups":
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		profile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property "DaemonsetEvictionForEmptyNodes":
	if typedInput.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNodes := *typedInput.DaemonsetEvictionForEmptyNodes
		profile.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNodes
	}

	// Set property "DaemonsetEvictionForOccupiedNodes":
	if typedInput.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNodes := *typedInput.DaemonsetEvictionForOccupiedNodes
		profile.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNodes
	}

	// Set property "Expander":
	if typedInput.Expander != nil {
		var temp string
		temp = string(*typedInput.Expander)
		expander := Expander_STATUS(temp)
		profile.Expander = &expander
	}

	// Set property "IgnoreDaemonsetsUtilization":
	if typedInput.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *typedInput.IgnoreDaemonsetsUtilization
		profile.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	}

	// Set property "MaxEmptyBulkDelete":
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		profile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property "MaxGracefulTerminationSec":
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		profile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property "MaxNodeProvisionTime":
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		profile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property "MaxTotalUnreadyPercentage":
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		profile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property "NewPodScaleUpDelay":
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		profile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property "OkTotalUnreadyCount":
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		profile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property "ScaleDownDelayAfterAdd":
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		profile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property "ScaleDownDelayAfterDelete":
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		profile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property "ScaleDownDelayAfterFailure":
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		profile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property "ScaleDownUnneededTime":
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		profile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property "ScaleDownUnreadyTime":
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		profile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property "ScaleDownUtilizationThreshold":
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		profile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property "ScanInterval":
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		profile.ScanInterval = &scanInterval
	}

	// Set property "SkipNodesWithLocalStorage":
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		profile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property "SkipNodesWithSystemPods":
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		profile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile_STATUS populates our ManagedClusterPropertiesAutoScalerProfile_STATUS from the provided source ManagedClusterPropertiesAutoScalerProfile_STATUS
func (profile *ManagedClusterPropertiesAutoScalerProfile_STATUS) AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile_STATUS(source *storage.ManagedClusterPropertiesAutoScalerProfile_STATUS) error {

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// DaemonsetEvictionForEmptyNodes
	if source.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNode := *source.DaemonsetEvictionForEmptyNodes
		profile.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNode
	} else {
		profile.DaemonsetEvictionForEmptyNodes = nil
	}

	// DaemonsetEvictionForOccupiedNodes
	if source.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNode := *source.DaemonsetEvictionForOccupiedNodes
		profile.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNode
	} else {
		profile.DaemonsetEvictionForOccupiedNodes = nil
	}

	// Expander
	if source.Expander != nil {
		expander := *source.Expander
		expanderTemp := genruntime.ToEnum(expander, expander_STATUS_Values)
		profile.Expander = &expanderTemp
	} else {
		profile.Expander = nil
	}

	// IgnoreDaemonsetsUtilization
	if source.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *source.IgnoreDaemonsetsUtilization
		profile.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	} else {
		profile.IgnoreDaemonsetsUtilization = nil
	}

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile_STATUS populates the provided destination ManagedClusterPropertiesAutoScalerProfile_STATUS from our ManagedClusterPropertiesAutoScalerProfile_STATUS
func (profile *ManagedClusterPropertiesAutoScalerProfile_STATUS) AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile_STATUS(destination *storage.ManagedClusterPropertiesAutoScalerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// DaemonsetEvictionForEmptyNodes
	if profile.DaemonsetEvictionForEmptyNodes != nil {
		daemonsetEvictionForEmptyNode := *profile.DaemonsetEvictionForEmptyNodes
		destination.DaemonsetEvictionForEmptyNodes = &daemonsetEvictionForEmptyNode
	} else {
		destination.DaemonsetEvictionForEmptyNodes = nil
	}

	// DaemonsetEvictionForOccupiedNodes
	if profile.DaemonsetEvictionForOccupiedNodes != nil {
		daemonsetEvictionForOccupiedNode := *profile.DaemonsetEvictionForOccupiedNodes
		destination.DaemonsetEvictionForOccupiedNodes = &daemonsetEvictionForOccupiedNode
	} else {
		destination.DaemonsetEvictionForOccupiedNodes = nil
	}

	// Expander
	if profile.Expander != nil {
		expander := string(*profile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// IgnoreDaemonsetsUtilization
	if profile.IgnoreDaemonsetsUtilization != nil {
		ignoreDaemonsetsUtilization := *profile.IgnoreDaemonsetsUtilization
		destination.IgnoreDaemonsetsUtilization = &ignoreDaemonsetsUtilization
	} else {
		destination.IgnoreDaemonsetsUtilization = nil
	}

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Security profile for the container service cluster.
type ManagedClusterSecurityProfile struct {
	// AzureKeyVaultKms: Azure Key Vault [key management
	// service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for the security profile.
	AzureKeyVaultKms *AzureKeyVaultKms `json:"azureKeyVaultKms,omitempty"`

	// +kubebuilder:validation:MaxItems=10
	// +kubebuilder:validation:MinItems=0
	// CustomCATrustCertificates: A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in
	// the cluster. For more information see [Custom CA Trust
	// Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
	CustomCATrustCertificates []string `json:"customCATrustCertificates,omitempty"`

	// Defender: Microsoft Defender settings for the security profile.
	Defender *ManagedClusterSecurityProfileDefender `json:"defender,omitempty"`

	// ImageCleaner: Image Cleaner settings for the security profile.
	ImageCleaner *ManagedClusterSecurityProfileImageCleaner `json:"imageCleaner,omitempty"`

	// ImageIntegrity: Image integrity is a feature that works with Azure Policy to verify image integrity by signature. This
	// will not have any effect unless Azure Policy is applied to enforce image signatures. See
	// https://aka.ms/aks/image-integrity for how to use this feature via policy.
	ImageIntegrity *ManagedClusterSecurityProfileImageIntegrity `json:"imageIntegrity,omitempty"`

	// KubernetesResourceObjectEncryptionProfile: Encryption at rest of Kubernetes resource objects. More information on this
	// can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption
	KubernetesResourceObjectEncryptionProfile *KubernetesResourceObjectEncryptionProfile `json:"kubernetesResourceObjectEncryptionProfile,omitempty"`

	// NodeRestriction: [Node
	// Restriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) settings
	// for the security profile.
	NodeRestriction *ManagedClusterSecurityProfileNodeRestriction `json:"nodeRestriction,omitempty"`

	// WorkloadIdentity: Workload identity settings for the security profile. Workload identity enables Kubernetes applications
	// to access Azure cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
	WorkloadIdentity *ManagedClusterSecurityProfileWorkloadIdentity `json:"workloadIdentity,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterSecurityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfile{}

	// Set property "AzureKeyVaultKms":
	if profile.AzureKeyVaultKms != nil {
		azureKeyVaultKms_ARM, err := profile.AzureKeyVaultKms.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureKeyVaultKms := *azureKeyVaultKms_ARM.(*arm.AzureKeyVaultKms)
		result.AzureKeyVaultKms = &azureKeyVaultKms
	}

	// Set property "CustomCATrustCertificates":
	for _, item := range profile.CustomCATrustCertificates {
		result.CustomCATrustCertificates = append(result.CustomCATrustCertificates, item)
	}

	// Set property "Defender":
	if profile.Defender != nil {
		defender_ARM, err := profile.Defender.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defender := *defender_ARM.(*arm.ManagedClusterSecurityProfileDefender)
		result.Defender = &defender
	}

	// Set property "ImageCleaner":
	if profile.ImageCleaner != nil {
		imageCleaner_ARM, err := profile.ImageCleaner.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageCleaner := *imageCleaner_ARM.(*arm.ManagedClusterSecurityProfileImageCleaner)
		result.ImageCleaner = &imageCleaner
	}

	// Set property "ImageIntegrity":
	if profile.ImageIntegrity != nil {
		imageIntegrity_ARM, err := profile.ImageIntegrity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageIntegrity := *imageIntegrity_ARM.(*arm.ManagedClusterSecurityProfileImageIntegrity)
		result.ImageIntegrity = &imageIntegrity
	}

	// Set property "KubernetesResourceObjectEncryptionProfile":
	if profile.KubernetesResourceObjectEncryptionProfile != nil {
		kubernetesResourceObjectEncryptionProfile_ARM, err := profile.KubernetesResourceObjectEncryptionProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubernetesResourceObjectEncryptionProfile := *kubernetesResourceObjectEncryptionProfile_ARM.(*arm.KubernetesResourceObjectEncryptionProfile)
		result.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	}

	// Set property "NodeRestriction":
	if profile.NodeRestriction != nil {
		nodeRestriction_ARM, err := profile.NodeRestriction.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nodeRestriction := *nodeRestriction_ARM.(*arm.ManagedClusterSecurityProfileNodeRestriction)
		result.NodeRestriction = &nodeRestriction
	}

	// Set property "WorkloadIdentity":
	if profile.WorkloadIdentity != nil {
		workloadIdentity_ARM, err := profile.WorkloadIdentity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		workloadIdentity := *workloadIdentity_ARM.(*arm.ManagedClusterSecurityProfileWorkloadIdentity)
		result.WorkloadIdentity = &workloadIdentity
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterSecurityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterSecurityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfile, got %T", armInput)
	}

	// Set property "AzureKeyVaultKms":
	if typedInput.AzureKeyVaultKms != nil {
		var azureKeyVaultKms1 AzureKeyVaultKms
		err := azureKeyVaultKms1.PopulateFromARM(owner, *typedInput.AzureKeyVaultKms)
		if err != nil {
			return err
		}
		azureKeyVaultKms := azureKeyVaultKms1
		profile.AzureKeyVaultKms = &azureKeyVaultKms
	}

	// Set property "CustomCATrustCertificates":
	for _, item := range typedInput.CustomCATrustCertificates {
		profile.CustomCATrustCertificates = append(profile.CustomCATrustCertificates, item)
	}

	// Set property "Defender":
	if typedInput.Defender != nil {
		var defender1 ManagedClusterSecurityProfileDefender
		err := defender1.PopulateFromARM(owner, *typedInput.Defender)
		if err != nil {
			return err
		}
		defender := defender1
		profile.Defender = &defender
	}

	// Set property "ImageCleaner":
	if typedInput.ImageCleaner != nil {
		var imageCleaner1 ManagedClusterSecurityProfileImageCleaner
		err := imageCleaner1.PopulateFromARM(owner, *typedInput.ImageCleaner)
		if err != nil {
			return err
		}
		imageCleaner := imageCleaner1
		profile.ImageCleaner = &imageCleaner
	}

	// Set property "ImageIntegrity":
	if typedInput.ImageIntegrity != nil {
		var imageIntegrity1 ManagedClusterSecurityProfileImageIntegrity
		err := imageIntegrity1.PopulateFromARM(owner, *typedInput.ImageIntegrity)
		if err != nil {
			return err
		}
		imageIntegrity := imageIntegrity1
		profile.ImageIntegrity = &imageIntegrity
	}

	// Set property "KubernetesResourceObjectEncryptionProfile":
	if typedInput.KubernetesResourceObjectEncryptionProfile != nil {
		var kubernetesResourceObjectEncryptionProfile1 KubernetesResourceObjectEncryptionProfile
		err := kubernetesResourceObjectEncryptionProfile1.PopulateFromARM(owner, *typedInput.KubernetesResourceObjectEncryptionProfile)
		if err != nil {
			return err
		}
		kubernetesResourceObjectEncryptionProfile := kubernetesResourceObjectEncryptionProfile1
		profile.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	}

	// Set property "NodeRestriction":
	if typedInput.NodeRestriction != nil {
		var nodeRestriction1 ManagedClusterSecurityProfileNodeRestriction
		err := nodeRestriction1.PopulateFromARM(owner, *typedInput.NodeRestriction)
		if err != nil {
			return err
		}
		nodeRestriction := nodeRestriction1
		profile.NodeRestriction = &nodeRestriction
	}

	// Set property "WorkloadIdentity":
	if typedInput.WorkloadIdentity != nil {
		var workloadIdentity1 ManagedClusterSecurityProfileWorkloadIdentity
		err := workloadIdentity1.PopulateFromARM(owner, *typedInput.WorkloadIdentity)
		if err != nil {
			return err
		}
		workloadIdentity := workloadIdentity1
		profile.WorkloadIdentity = &workloadIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfile populates our ManagedClusterSecurityProfile from the provided source ManagedClusterSecurityProfile
func (profile *ManagedClusterSecurityProfile) AssignProperties_From_ManagedClusterSecurityProfile(source *storage.ManagedClusterSecurityProfile) error {

	// AzureKeyVaultKms
	if source.AzureKeyVaultKms != nil {
		var azureKeyVaultKm AzureKeyVaultKms
		err := azureKeyVaultKm.AssignProperties_From_AzureKeyVaultKms(source.AzureKeyVaultKms)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureKeyVaultKms() to populate field AzureKeyVaultKms")
		}
		profile.AzureKeyVaultKms = &azureKeyVaultKm
	} else {
		profile.AzureKeyVaultKms = nil
	}

	// CustomCATrustCertificates
	profile.CustomCATrustCertificates = genruntime.CloneSliceOfString(source.CustomCATrustCertificates)

	// Defender
	if source.Defender != nil {
		var defender ManagedClusterSecurityProfileDefender
		err := defender.AssignProperties_From_ManagedClusterSecurityProfileDefender(source.Defender)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefender() to populate field Defender")
		}
		profile.Defender = &defender
	} else {
		profile.Defender = nil
	}

	// ImageCleaner
	if source.ImageCleaner != nil {
		var imageCleaner ManagedClusterSecurityProfileImageCleaner
		err := imageCleaner.AssignProperties_From_ManagedClusterSecurityProfileImageCleaner(source.ImageCleaner)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileImageCleaner() to populate field ImageCleaner")
		}
		profile.ImageCleaner = &imageCleaner
	} else {
		profile.ImageCleaner = nil
	}

	// ImageIntegrity
	if source.ImageIntegrity != nil {
		var imageIntegrity ManagedClusterSecurityProfileImageIntegrity
		err := imageIntegrity.AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity(source.ImageIntegrity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity() to populate field ImageIntegrity")
		}
		profile.ImageIntegrity = &imageIntegrity
	} else {
		profile.ImageIntegrity = nil
	}

	// KubernetesResourceObjectEncryptionProfile
	if source.KubernetesResourceObjectEncryptionProfile != nil {
		var kubernetesResourceObjectEncryptionProfile KubernetesResourceObjectEncryptionProfile
		err := kubernetesResourceObjectEncryptionProfile.AssignProperties_From_KubernetesResourceObjectEncryptionProfile(source.KubernetesResourceObjectEncryptionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KubernetesResourceObjectEncryptionProfile() to populate field KubernetesResourceObjectEncryptionProfile")
		}
		profile.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	} else {
		profile.KubernetesResourceObjectEncryptionProfile = nil
	}

	// NodeRestriction
	if source.NodeRestriction != nil {
		var nodeRestriction ManagedClusterSecurityProfileNodeRestriction
		err := nodeRestriction.AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction(source.NodeRestriction)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction() to populate field NodeRestriction")
		}
		profile.NodeRestriction = &nodeRestriction
	} else {
		profile.NodeRestriction = nil
	}

	// WorkloadIdentity
	if source.WorkloadIdentity != nil {
		var workloadIdentity ManagedClusterSecurityProfileWorkloadIdentity
		err := workloadIdentity.AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity(source.WorkloadIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity() to populate field WorkloadIdentity")
		}
		profile.WorkloadIdentity = &workloadIdentity
	} else {
		profile.WorkloadIdentity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfile populates the provided destination ManagedClusterSecurityProfile from our ManagedClusterSecurityProfile
func (profile *ManagedClusterSecurityProfile) AssignProperties_To_ManagedClusterSecurityProfile(destination *storage.ManagedClusterSecurityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureKeyVaultKms
	if profile.AzureKeyVaultKms != nil {
		var azureKeyVaultKm storage.AzureKeyVaultKms
		err := profile.AzureKeyVaultKms.AssignProperties_To_AzureKeyVaultKms(&azureKeyVaultKm)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureKeyVaultKms() to populate field AzureKeyVaultKms")
		}
		destination.AzureKeyVaultKms = &azureKeyVaultKm
	} else {
		destination.AzureKeyVaultKms = nil
	}

	// CustomCATrustCertificates
	destination.CustomCATrustCertificates = genruntime.CloneSliceOfString(profile.CustomCATrustCertificates)

	// Defender
	if profile.Defender != nil {
		var defender storage.ManagedClusterSecurityProfileDefender
		err := profile.Defender.AssignProperties_To_ManagedClusterSecurityProfileDefender(&defender)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefender() to populate field Defender")
		}
		destination.Defender = &defender
	} else {
		destination.Defender = nil
	}

	// ImageCleaner
	if profile.ImageCleaner != nil {
		var imageCleaner storage.ManagedClusterSecurityProfileImageCleaner
		err := profile.ImageCleaner.AssignProperties_To_ManagedClusterSecurityProfileImageCleaner(&imageCleaner)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileImageCleaner() to populate field ImageCleaner")
		}
		destination.ImageCleaner = &imageCleaner
	} else {
		destination.ImageCleaner = nil
	}

	// ImageIntegrity
	if profile.ImageIntegrity != nil {
		var imageIntegrity storage.ManagedClusterSecurityProfileImageIntegrity
		err := profile.ImageIntegrity.AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity(&imageIntegrity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity() to populate field ImageIntegrity")
		}
		destination.ImageIntegrity = &imageIntegrity
	} else {
		destination.ImageIntegrity = nil
	}

	// KubernetesResourceObjectEncryptionProfile
	if profile.KubernetesResourceObjectEncryptionProfile != nil {
		var kubernetesResourceObjectEncryptionProfile storage.KubernetesResourceObjectEncryptionProfile
		err := profile.KubernetesResourceObjectEncryptionProfile.AssignProperties_To_KubernetesResourceObjectEncryptionProfile(&kubernetesResourceObjectEncryptionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KubernetesResourceObjectEncryptionProfile() to populate field KubernetesResourceObjectEncryptionProfile")
		}
		destination.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	} else {
		destination.KubernetesResourceObjectEncryptionProfile = nil
	}

	// NodeRestriction
	if profile.NodeRestriction != nil {
		var nodeRestriction storage.ManagedClusterSecurityProfileNodeRestriction
		err := profile.NodeRestriction.AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction(&nodeRestriction)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction() to populate field NodeRestriction")
		}
		destination.NodeRestriction = &nodeRestriction
	} else {
		destination.NodeRestriction = nil
	}

	// WorkloadIdentity
	if profile.WorkloadIdentity != nil {
		var workloadIdentity storage.ManagedClusterSecurityProfileWorkloadIdentity
		err := profile.WorkloadIdentity.AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity(&workloadIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity() to populate field WorkloadIdentity")
		}
		destination.WorkloadIdentity = &workloadIdentity
	} else {
		destination.WorkloadIdentity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Security profile for the container service cluster.
type ManagedClusterSecurityProfile_STATUS struct {
	// AzureKeyVaultKms: Azure Key Vault [key management
	// service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for the security profile.
	AzureKeyVaultKms *AzureKeyVaultKms_STATUS `json:"azureKeyVaultKms,omitempty"`

	// CustomCATrustCertificates: A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in
	// the cluster. For more information see [Custom CA Trust
	// Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
	CustomCATrustCertificates []string `json:"customCATrustCertificates,omitempty"`

	// Defender: Microsoft Defender settings for the security profile.
	Defender *ManagedClusterSecurityProfileDefender_STATUS `json:"defender,omitempty"`

	// ImageCleaner: Image Cleaner settings for the security profile.
	ImageCleaner *ManagedClusterSecurityProfileImageCleaner_STATUS `json:"imageCleaner,omitempty"`

	// ImageIntegrity: Image integrity is a feature that works with Azure Policy to verify image integrity by signature. This
	// will not have any effect unless Azure Policy is applied to enforce image signatures. See
	// https://aka.ms/aks/image-integrity for how to use this feature via policy.
	ImageIntegrity *ManagedClusterSecurityProfileImageIntegrity_STATUS `json:"imageIntegrity,omitempty"`

	// KubernetesResourceObjectEncryptionProfile: Encryption at rest of Kubernetes resource objects. More information on this
	// can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption
	KubernetesResourceObjectEncryptionProfile *KubernetesResourceObjectEncryptionProfile_STATUS `json:"kubernetesResourceObjectEncryptionProfile,omitempty"`

	// NodeRestriction: [Node
	// Restriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) settings
	// for the security profile.
	NodeRestriction *ManagedClusterSecurityProfileNodeRestriction_STATUS `json:"nodeRestriction,omitempty"`

	// WorkloadIdentity: Workload identity settings for the security profile. Workload identity enables Kubernetes applications
	// to access Azure cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
	WorkloadIdentity *ManagedClusterSecurityProfileWorkloadIdentity_STATUS `json:"workloadIdentity,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterSecurityProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterSecurityProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfile_STATUS, got %T", armInput)
	}

	// Set property "AzureKeyVaultKms":
	if typedInput.AzureKeyVaultKms != nil {
		var azureKeyVaultKms1 AzureKeyVaultKms_STATUS
		err := azureKeyVaultKms1.PopulateFromARM(owner, *typedInput.AzureKeyVaultKms)
		if err != nil {
			return err
		}
		azureKeyVaultKms := azureKeyVaultKms1
		profile.AzureKeyVaultKms = &azureKeyVaultKms
	}

	// Set property "CustomCATrustCertificates":
	for _, item := range typedInput.CustomCATrustCertificates {
		profile.CustomCATrustCertificates = append(profile.CustomCATrustCertificates, item)
	}

	// Set property "Defender":
	if typedInput.Defender != nil {
		var defender1 ManagedClusterSecurityProfileDefender_STATUS
		err := defender1.PopulateFromARM(owner, *typedInput.Defender)
		if err != nil {
			return err
		}
		defender := defender1
		profile.Defender = &defender
	}

	// Set property "ImageCleaner":
	if typedInput.ImageCleaner != nil {
		var imageCleaner1 ManagedClusterSecurityProfileImageCleaner_STATUS
		err := imageCleaner1.PopulateFromARM(owner, *typedInput.ImageCleaner)
		if err != nil {
			return err
		}
		imageCleaner := imageCleaner1
		profile.ImageCleaner = &imageCleaner
	}

	// Set property "ImageIntegrity":
	if typedInput.ImageIntegrity != nil {
		var imageIntegrity1 ManagedClusterSecurityProfileImageIntegrity_STATUS
		err := imageIntegrity1.PopulateFromARM(owner, *typedInput.ImageIntegrity)
		if err != nil {
			return err
		}
		imageIntegrity := imageIntegrity1
		profile.ImageIntegrity = &imageIntegrity
	}

	// Set property "KubernetesResourceObjectEncryptionProfile":
	if typedInput.KubernetesResourceObjectEncryptionProfile != nil {
		var kubernetesResourceObjectEncryptionProfile1 KubernetesResourceObjectEncryptionProfile_STATUS
		err := kubernetesResourceObjectEncryptionProfile1.PopulateFromARM(owner, *typedInput.KubernetesResourceObjectEncryptionProfile)
		if err != nil {
			return err
		}
		kubernetesResourceObjectEncryptionProfile := kubernetesResourceObjectEncryptionProfile1
		profile.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	}

	// Set property "NodeRestriction":
	if typedInput.NodeRestriction != nil {
		var nodeRestriction1 ManagedClusterSecurityProfileNodeRestriction_STATUS
		err := nodeRestriction1.PopulateFromARM(owner, *typedInput.NodeRestriction)
		if err != nil {
			return err
		}
		nodeRestriction := nodeRestriction1
		profile.NodeRestriction = &nodeRestriction
	}

	// Set property "WorkloadIdentity":
	if typedInput.WorkloadIdentity != nil {
		var workloadIdentity1 ManagedClusterSecurityProfileWorkloadIdentity_STATUS
		err := workloadIdentity1.PopulateFromARM(owner, *typedInput.WorkloadIdentity)
		if err != nil {
			return err
		}
		workloadIdentity := workloadIdentity1
		profile.WorkloadIdentity = &workloadIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfile_STATUS populates our ManagedClusterSecurityProfile_STATUS from the provided source ManagedClusterSecurityProfile_STATUS
func (profile *ManagedClusterSecurityProfile_STATUS) AssignProperties_From_ManagedClusterSecurityProfile_STATUS(source *storage.ManagedClusterSecurityProfile_STATUS) error {

	// AzureKeyVaultKms
	if source.AzureKeyVaultKms != nil {
		var azureKeyVaultKm AzureKeyVaultKms_STATUS
		err := azureKeyVaultKm.AssignProperties_From_AzureKeyVaultKms_STATUS(source.AzureKeyVaultKms)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureKeyVaultKms_STATUS() to populate field AzureKeyVaultKms")
		}
		profile.AzureKeyVaultKms = &azureKeyVaultKm
	} else {
		profile.AzureKeyVaultKms = nil
	}

	// CustomCATrustCertificates
	profile.CustomCATrustCertificates = genruntime.CloneSliceOfString(source.CustomCATrustCertificates)

	// Defender
	if source.Defender != nil {
		var defender ManagedClusterSecurityProfileDefender_STATUS
		err := defender.AssignProperties_From_ManagedClusterSecurityProfileDefender_STATUS(source.Defender)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefender_STATUS() to populate field Defender")
		}
		profile.Defender = &defender
	} else {
		profile.Defender = nil
	}

	// ImageCleaner
	if source.ImageCleaner != nil {
		var imageCleaner ManagedClusterSecurityProfileImageCleaner_STATUS
		err := imageCleaner.AssignProperties_From_ManagedClusterSecurityProfileImageCleaner_STATUS(source.ImageCleaner)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileImageCleaner_STATUS() to populate field ImageCleaner")
		}
		profile.ImageCleaner = &imageCleaner
	} else {
		profile.ImageCleaner = nil
	}

	// ImageIntegrity
	if source.ImageIntegrity != nil {
		var imageIntegrity ManagedClusterSecurityProfileImageIntegrity_STATUS
		err := imageIntegrity.AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity_STATUS(source.ImageIntegrity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity_STATUS() to populate field ImageIntegrity")
		}
		profile.ImageIntegrity = &imageIntegrity
	} else {
		profile.ImageIntegrity = nil
	}

	// KubernetesResourceObjectEncryptionProfile
	if source.KubernetesResourceObjectEncryptionProfile != nil {
		var kubernetesResourceObjectEncryptionProfile KubernetesResourceObjectEncryptionProfile_STATUS
		err := kubernetesResourceObjectEncryptionProfile.AssignProperties_From_KubernetesResourceObjectEncryptionProfile_STATUS(source.KubernetesResourceObjectEncryptionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KubernetesResourceObjectEncryptionProfile_STATUS() to populate field KubernetesResourceObjectEncryptionProfile")
		}
		profile.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	} else {
		profile.KubernetesResourceObjectEncryptionProfile = nil
	}

	// NodeRestriction
	if source.NodeRestriction != nil {
		var nodeRestriction ManagedClusterSecurityProfileNodeRestriction_STATUS
		err := nodeRestriction.AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction_STATUS(source.NodeRestriction)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction_STATUS() to populate field NodeRestriction")
		}
		profile.NodeRestriction = &nodeRestriction
	} else {
		profile.NodeRestriction = nil
	}

	// WorkloadIdentity
	if source.WorkloadIdentity != nil {
		var workloadIdentity ManagedClusterSecurityProfileWorkloadIdentity_STATUS
		err := workloadIdentity.AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity_STATUS(source.WorkloadIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity_STATUS() to populate field WorkloadIdentity")
		}
		profile.WorkloadIdentity = &workloadIdentity
	} else {
		profile.WorkloadIdentity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfile_STATUS populates the provided destination ManagedClusterSecurityProfile_STATUS from our ManagedClusterSecurityProfile_STATUS
func (profile *ManagedClusterSecurityProfile_STATUS) AssignProperties_To_ManagedClusterSecurityProfile_STATUS(destination *storage.ManagedClusterSecurityProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureKeyVaultKms
	if profile.AzureKeyVaultKms != nil {
		var azureKeyVaultKm storage.AzureKeyVaultKms_STATUS
		err := profile.AzureKeyVaultKms.AssignProperties_To_AzureKeyVaultKms_STATUS(&azureKeyVaultKm)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureKeyVaultKms_STATUS() to populate field AzureKeyVaultKms")
		}
		destination.AzureKeyVaultKms = &azureKeyVaultKm
	} else {
		destination.AzureKeyVaultKms = nil
	}

	// CustomCATrustCertificates
	destination.CustomCATrustCertificates = genruntime.CloneSliceOfString(profile.CustomCATrustCertificates)

	// Defender
	if profile.Defender != nil {
		var defender storage.ManagedClusterSecurityProfileDefender_STATUS
		err := profile.Defender.AssignProperties_To_ManagedClusterSecurityProfileDefender_STATUS(&defender)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefender_STATUS() to populate field Defender")
		}
		destination.Defender = &defender
	} else {
		destination.Defender = nil
	}

	// ImageCleaner
	if profile.ImageCleaner != nil {
		var imageCleaner storage.ManagedClusterSecurityProfileImageCleaner_STATUS
		err := profile.ImageCleaner.AssignProperties_To_ManagedClusterSecurityProfileImageCleaner_STATUS(&imageCleaner)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileImageCleaner_STATUS() to populate field ImageCleaner")
		}
		destination.ImageCleaner = &imageCleaner
	} else {
		destination.ImageCleaner = nil
	}

	// ImageIntegrity
	if profile.ImageIntegrity != nil {
		var imageIntegrity storage.ManagedClusterSecurityProfileImageIntegrity_STATUS
		err := profile.ImageIntegrity.AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity_STATUS(&imageIntegrity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity_STATUS() to populate field ImageIntegrity")
		}
		destination.ImageIntegrity = &imageIntegrity
	} else {
		destination.ImageIntegrity = nil
	}

	// KubernetesResourceObjectEncryptionProfile
	if profile.KubernetesResourceObjectEncryptionProfile != nil {
		var kubernetesResourceObjectEncryptionProfile storage.KubernetesResourceObjectEncryptionProfile_STATUS
		err := profile.KubernetesResourceObjectEncryptionProfile.AssignProperties_To_KubernetesResourceObjectEncryptionProfile_STATUS(&kubernetesResourceObjectEncryptionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KubernetesResourceObjectEncryptionProfile_STATUS() to populate field KubernetesResourceObjectEncryptionProfile")
		}
		destination.KubernetesResourceObjectEncryptionProfile = &kubernetesResourceObjectEncryptionProfile
	} else {
		destination.KubernetesResourceObjectEncryptionProfile = nil
	}

	// NodeRestriction
	if profile.NodeRestriction != nil {
		var nodeRestriction storage.ManagedClusterSecurityProfileNodeRestriction_STATUS
		err := profile.NodeRestriction.AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction_STATUS(&nodeRestriction)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction_STATUS() to populate field NodeRestriction")
		}
		destination.NodeRestriction = &nodeRestriction
	} else {
		destination.NodeRestriction = nil
	}

	// WorkloadIdentity
	if profile.WorkloadIdentity != nil {
		var workloadIdentity storage.ManagedClusterSecurityProfileWorkloadIdentity_STATUS
		err := profile.WorkloadIdentity.AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity_STATUS(&workloadIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity_STATUS() to populate field WorkloadIdentity")
		}
		destination.WorkloadIdentity = &workloadIdentity
	} else {
		destination.WorkloadIdentity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about a service principal identity for the cluster to use for manipulating Azure APIs.
type ManagedClusterServicePrincipalProfile struct {
	// +kubebuilder:validation:Required
	// ClientId: The ID for the service principal.
	ClientId *string `json:"clientId,omitempty"`

	// Secret: The secret password associated with the service principal in plain text.
	Secret *genruntime.SecretReference `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterServicePrincipalProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterServicePrincipalProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterServicePrincipalProfile{}

	// Set property "ClientId":
	if profile.ClientId != nil {
		clientId := *profile.ClientId
		result.ClientId = &clientId
	}

	// Set property "Secret":
	if profile.Secret != nil {
		secretSecret, err := resolved.ResolvedSecrets.Lookup(*profile.Secret)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property Secret")
		}
		secret := secretSecret
		result.Secret = &secret
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterServicePrincipalProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterServicePrincipalProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterServicePrincipalProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterServicePrincipalProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterServicePrincipalProfile, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		profile.ClientId = &clientId
	}

	// no assignment for property "Secret"

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterServicePrincipalProfile populates our ManagedClusterServicePrincipalProfile from the provided source ManagedClusterServicePrincipalProfile
func (profile *ManagedClusterServicePrincipalProfile) AssignProperties_From_ManagedClusterServicePrincipalProfile(source *storage.ManagedClusterServicePrincipalProfile) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Secret
	if source.Secret != nil {
		secret := source.Secret.Copy()
		profile.Secret = &secret
	} else {
		profile.Secret = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterServicePrincipalProfile populates the provided destination ManagedClusterServicePrincipalProfile from our ManagedClusterServicePrincipalProfile
func (profile *ManagedClusterServicePrincipalProfile) AssignProperties_To_ManagedClusterServicePrincipalProfile(destination *storage.ManagedClusterServicePrincipalProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Secret
	if profile.Secret != nil {
		secret := profile.Secret.Copy()
		destination.Secret = &secret
	} else {
		destination.Secret = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about a service principal identity for the cluster to use for manipulating Azure APIs.
type ManagedClusterServicePrincipalProfile_STATUS struct {
	// ClientId: The ID for the service principal.
	ClientId *string `json:"clientId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterServicePrincipalProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterServicePrincipalProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterServicePrincipalProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterServicePrincipalProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterServicePrincipalProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterServicePrincipalProfile_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		profile.ClientId = &clientId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS populates our ManagedClusterServicePrincipalProfile_STATUS from the provided source ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS(source *storage.ManagedClusterServicePrincipalProfile_STATUS) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS populates the provided destination ManagedClusterServicePrincipalProfile_STATUS from our ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS(destination *storage.ManagedClusterServicePrincipalProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The SKU of a Managed Cluster.
type ManagedClusterSKU struct {
	// Name: The name of a managed cluster SKU.
	Name *ManagedClusterSKUName `json:"name,omitempty"`

	// Tier: The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing
	// Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
	Tier *ManagedClusterSKUTier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSKU{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (clusterSKU *ManagedClusterSKU) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if clusterSKU == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSKU{}

	// Set property "Name":
	if clusterSKU.Name != nil {
		var temp string
		temp = string(*clusterSKU.Name)
		name := arm.ManagedClusterSKUName(temp)
		result.Name = &name
	}

	// Set property "Tier":
	if clusterSKU.Tier != nil {
		var temp string
		temp = string(*clusterSKU.Tier)
		tier := arm.ManagedClusterSKUTier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (clusterSKU *ManagedClusterSKU) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSKU{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (clusterSKU *ManagedClusterSKU) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSKU)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSKU, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := ManagedClusterSKUName(temp)
		clusterSKU.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := ManagedClusterSKUTier(temp)
		clusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSKU populates our ManagedClusterSKU from the provided source ManagedClusterSKU
func (clusterSKU *ManagedClusterSKU) AssignProperties_From_ManagedClusterSKU(source *storage.ManagedClusterSKU) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, managedClusterSKUName_Values)
		clusterSKU.Name = &nameTemp
	} else {
		clusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, managedClusterSKUTier_Values)
		clusterSKU.Tier = &tierTemp
	} else {
		clusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSKU populates the provided destination ManagedClusterSKU from our ManagedClusterSKU
func (clusterSKU *ManagedClusterSKU) AssignProperties_To_ManagedClusterSKU(destination *storage.ManagedClusterSKU) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if clusterSKU.Name != nil {
		name := string(*clusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if clusterSKU.Tier != nil {
		tier := string(*clusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The SKU of a Managed Cluster.
type ManagedClusterSKU_STATUS struct {
	// Name: The name of a managed cluster SKU.
	Name *ManagedClusterSKUName_STATUS `json:"name,omitempty"`

	// Tier: The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing
	// Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
	Tier *ManagedClusterSKUTier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSKU_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (clusterSKU *ManagedClusterSKU_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSKU_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (clusterSKU *ManagedClusterSKU_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSKU_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSKU_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := ManagedClusterSKUName_STATUS(temp)
		clusterSKU.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := ManagedClusterSKUTier_STATUS(temp)
		clusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSKU_STATUS populates our ManagedClusterSKU_STATUS from the provided source ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignProperties_From_ManagedClusterSKU_STATUS(source *storage.ManagedClusterSKU_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, managedClusterSKUName_STATUS_Values)
		clusterSKU.Name = &nameTemp
	} else {
		clusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, managedClusterSKUTier_STATUS_Values)
		clusterSKU.Tier = &tierTemp
	} else {
		clusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSKU_STATUS populates the provided destination ManagedClusterSKU_STATUS from our ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignProperties_To_ManagedClusterSKU_STATUS(destination *storage.ManagedClusterSKU_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if clusterSKU.Name != nil {
		name := string(*clusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if clusterSKU.Tier != nil {
		tier := string(*clusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains read-only information about the Managed Cluster.
type ManagedClusterStatus_STATUS struct {
	// ProvisioningError: The error details information of the managed cluster. Preserves the detailed info of failure. If
	// there was no error, this field is omitted.
	ProvisioningError *ErrorDetail_STATUS `json:"provisioningError,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *ManagedClusterStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStatus_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *ManagedClusterStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStatus_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStatus_STATUS, got %T", armInput)
	}

	// Set property "ProvisioningError":
	if typedInput.ProvisioningError != nil {
		var provisioningError1 ErrorDetail_STATUS
		err := provisioningError1.PopulateFromARM(owner, *typedInput.ProvisioningError)
		if err != nil {
			return err
		}
		provisioningError := provisioningError1
		status.ProvisioningError = &provisioningError
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStatus_STATUS populates our ManagedClusterStatus_STATUS from the provided source ManagedClusterStatus_STATUS
func (status *ManagedClusterStatus_STATUS) AssignProperties_From_ManagedClusterStatus_STATUS(source *storage.ManagedClusterStatus_STATUS) error {

	// ProvisioningError
	if source.ProvisioningError != nil {
		var provisioningError ErrorDetail_STATUS
		err := provisioningError.AssignProperties_From_ErrorDetail_STATUS(source.ProvisioningError)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS() to populate field ProvisioningError")
		}
		status.ProvisioningError = &provisioningError
	} else {
		status.ProvisioningError = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStatus_STATUS populates the provided destination ManagedClusterStatus_STATUS from our ManagedClusterStatus_STATUS
func (status *ManagedClusterStatus_STATUS) AssignProperties_To_ManagedClusterStatus_STATUS(destination *storage.ManagedClusterStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProvisioningError
	if status.ProvisioningError != nil {
		var provisioningError storage.ErrorDetail_STATUS
		err := status.ProvisioningError.AssignProperties_To_ErrorDetail_STATUS(&provisioningError)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS() to populate field ProvisioningError")
		}
		destination.ProvisioningError = &provisioningError
	} else {
		destination.ProvisioningError = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage profile for the container service cluster.
type ManagedClusterStorageProfile struct {
	// BlobCSIDriver: AzureBlob CSI Driver settings for the storage profile.
	BlobCSIDriver *ManagedClusterStorageProfileBlobCSIDriver `json:"blobCSIDriver,omitempty"`

	// DiskCSIDriver: AzureDisk CSI Driver settings for the storage profile.
	DiskCSIDriver *ManagedClusterStorageProfileDiskCSIDriver `json:"diskCSIDriver,omitempty"`

	// FileCSIDriver: AzureFile CSI Driver settings for the storage profile.
	FileCSIDriver *ManagedClusterStorageProfileFileCSIDriver `json:"fileCSIDriver,omitempty"`

	// SnapshotController: Snapshot Controller settings for the storage profile.
	SnapshotController *ManagedClusterStorageProfileSnapshotController `json:"snapshotController,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterStorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterStorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterStorageProfile{}

	// Set property "BlobCSIDriver":
	if profile.BlobCSIDriver != nil {
		blobCSIDriver_ARM, err := profile.BlobCSIDriver.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		blobCSIDriver := *blobCSIDriver_ARM.(*arm.ManagedClusterStorageProfileBlobCSIDriver)
		result.BlobCSIDriver = &blobCSIDriver
	}

	// Set property "DiskCSIDriver":
	if profile.DiskCSIDriver != nil {
		diskCSIDriver_ARM, err := profile.DiskCSIDriver.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskCSIDriver := *diskCSIDriver_ARM.(*arm.ManagedClusterStorageProfileDiskCSIDriver)
		result.DiskCSIDriver = &diskCSIDriver
	}

	// Set property "FileCSIDriver":
	if profile.FileCSIDriver != nil {
		fileCSIDriver_ARM, err := profile.FileCSIDriver.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		fileCSIDriver := *fileCSIDriver_ARM.(*arm.ManagedClusterStorageProfileFileCSIDriver)
		result.FileCSIDriver = &fileCSIDriver
	}

	// Set property "SnapshotController":
	if profile.SnapshotController != nil {
		snapshotController_ARM, err := profile.SnapshotController.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		snapshotController := *snapshotController_ARM.(*arm.ManagedClusterStorageProfileSnapshotController)
		result.SnapshotController = &snapshotController
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterStorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterStorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfile, got %T", armInput)
	}

	// Set property "BlobCSIDriver":
	if typedInput.BlobCSIDriver != nil {
		var blobCSIDriver1 ManagedClusterStorageProfileBlobCSIDriver
		err := blobCSIDriver1.PopulateFromARM(owner, *typedInput.BlobCSIDriver)
		if err != nil {
			return err
		}
		blobCSIDriver := blobCSIDriver1
		profile.BlobCSIDriver = &blobCSIDriver
	}

	// Set property "DiskCSIDriver":
	if typedInput.DiskCSIDriver != nil {
		var diskCSIDriver1 ManagedClusterStorageProfileDiskCSIDriver
		err := diskCSIDriver1.PopulateFromARM(owner, *typedInput.DiskCSIDriver)
		if err != nil {
			return err
		}
		diskCSIDriver := diskCSIDriver1
		profile.DiskCSIDriver = &diskCSIDriver
	}

	// Set property "FileCSIDriver":
	if typedInput.FileCSIDriver != nil {
		var fileCSIDriver1 ManagedClusterStorageProfileFileCSIDriver
		err := fileCSIDriver1.PopulateFromARM(owner, *typedInput.FileCSIDriver)
		if err != nil {
			return err
		}
		fileCSIDriver := fileCSIDriver1
		profile.FileCSIDriver = &fileCSIDriver
	}

	// Set property "SnapshotController":
	if typedInput.SnapshotController != nil {
		var snapshotController1 ManagedClusterStorageProfileSnapshotController
		err := snapshotController1.PopulateFromARM(owner, *typedInput.SnapshotController)
		if err != nil {
			return err
		}
		snapshotController := snapshotController1
		profile.SnapshotController = &snapshotController
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfile populates our ManagedClusterStorageProfile from the provided source ManagedClusterStorageProfile
func (profile *ManagedClusterStorageProfile) AssignProperties_From_ManagedClusterStorageProfile(source *storage.ManagedClusterStorageProfile) error {

	// BlobCSIDriver
	if source.BlobCSIDriver != nil {
		var blobCSIDriver ManagedClusterStorageProfileBlobCSIDriver
		err := blobCSIDriver.AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver(source.BlobCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver() to populate field BlobCSIDriver")
		}
		profile.BlobCSIDriver = &blobCSIDriver
	} else {
		profile.BlobCSIDriver = nil
	}

	// DiskCSIDriver
	if source.DiskCSIDriver != nil {
		var diskCSIDriver ManagedClusterStorageProfileDiskCSIDriver
		err := diskCSIDriver.AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver(source.DiskCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver() to populate field DiskCSIDriver")
		}
		profile.DiskCSIDriver = &diskCSIDriver
	} else {
		profile.DiskCSIDriver = nil
	}

	// FileCSIDriver
	if source.FileCSIDriver != nil {
		var fileCSIDriver ManagedClusterStorageProfileFileCSIDriver
		err := fileCSIDriver.AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver(source.FileCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver() to populate field FileCSIDriver")
		}
		profile.FileCSIDriver = &fileCSIDriver
	} else {
		profile.FileCSIDriver = nil
	}

	// SnapshotController
	if source.SnapshotController != nil {
		var snapshotController ManagedClusterStorageProfileSnapshotController
		err := snapshotController.AssignProperties_From_ManagedClusterStorageProfileSnapshotController(source.SnapshotController)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileSnapshotController() to populate field SnapshotController")
		}
		profile.SnapshotController = &snapshotController
	} else {
		profile.SnapshotController = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfile populates the provided destination ManagedClusterStorageProfile from our ManagedClusterStorageProfile
func (profile *ManagedClusterStorageProfile) AssignProperties_To_ManagedClusterStorageProfile(destination *storage.ManagedClusterStorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobCSIDriver
	if profile.BlobCSIDriver != nil {
		var blobCSIDriver storage.ManagedClusterStorageProfileBlobCSIDriver
		err := profile.BlobCSIDriver.AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver(&blobCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver() to populate field BlobCSIDriver")
		}
		destination.BlobCSIDriver = &blobCSIDriver
	} else {
		destination.BlobCSIDriver = nil
	}

	// DiskCSIDriver
	if profile.DiskCSIDriver != nil {
		var diskCSIDriver storage.ManagedClusterStorageProfileDiskCSIDriver
		err := profile.DiskCSIDriver.AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver(&diskCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver() to populate field DiskCSIDriver")
		}
		destination.DiskCSIDriver = &diskCSIDriver
	} else {
		destination.DiskCSIDriver = nil
	}

	// FileCSIDriver
	if profile.FileCSIDriver != nil {
		var fileCSIDriver storage.ManagedClusterStorageProfileFileCSIDriver
		err := profile.FileCSIDriver.AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver(&fileCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver() to populate field FileCSIDriver")
		}
		destination.FileCSIDriver = &fileCSIDriver
	} else {
		destination.FileCSIDriver = nil
	}

	// SnapshotController
	if profile.SnapshotController != nil {
		var snapshotController storage.ManagedClusterStorageProfileSnapshotController
		err := profile.SnapshotController.AssignProperties_To_ManagedClusterStorageProfileSnapshotController(&snapshotController)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileSnapshotController() to populate field SnapshotController")
		}
		destination.SnapshotController = &snapshotController
	} else {
		destination.SnapshotController = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage profile for the container service cluster.
type ManagedClusterStorageProfile_STATUS struct {
	// BlobCSIDriver: AzureBlob CSI Driver settings for the storage profile.
	BlobCSIDriver *ManagedClusterStorageProfileBlobCSIDriver_STATUS `json:"blobCSIDriver,omitempty"`

	// DiskCSIDriver: AzureDisk CSI Driver settings for the storage profile.
	DiskCSIDriver *ManagedClusterStorageProfileDiskCSIDriver_STATUS `json:"diskCSIDriver,omitempty"`

	// FileCSIDriver: AzureFile CSI Driver settings for the storage profile.
	FileCSIDriver *ManagedClusterStorageProfileFileCSIDriver_STATUS `json:"fileCSIDriver,omitempty"`

	// SnapshotController: Snapshot Controller settings for the storage profile.
	SnapshotController *ManagedClusterStorageProfileSnapshotController_STATUS `json:"snapshotController,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterStorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterStorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfile_STATUS, got %T", armInput)
	}

	// Set property "BlobCSIDriver":
	if typedInput.BlobCSIDriver != nil {
		var blobCSIDriver1 ManagedClusterStorageProfileBlobCSIDriver_STATUS
		err := blobCSIDriver1.PopulateFromARM(owner, *typedInput.BlobCSIDriver)
		if err != nil {
			return err
		}
		blobCSIDriver := blobCSIDriver1
		profile.BlobCSIDriver = &blobCSIDriver
	}

	// Set property "DiskCSIDriver":
	if typedInput.DiskCSIDriver != nil {
		var diskCSIDriver1 ManagedClusterStorageProfileDiskCSIDriver_STATUS
		err := diskCSIDriver1.PopulateFromARM(owner, *typedInput.DiskCSIDriver)
		if err != nil {
			return err
		}
		diskCSIDriver := diskCSIDriver1
		profile.DiskCSIDriver = &diskCSIDriver
	}

	// Set property "FileCSIDriver":
	if typedInput.FileCSIDriver != nil {
		var fileCSIDriver1 ManagedClusterStorageProfileFileCSIDriver_STATUS
		err := fileCSIDriver1.PopulateFromARM(owner, *typedInput.FileCSIDriver)
		if err != nil {
			return err
		}
		fileCSIDriver := fileCSIDriver1
		profile.FileCSIDriver = &fileCSIDriver
	}

	// Set property "SnapshotController":
	if typedInput.SnapshotController != nil {
		var snapshotController1 ManagedClusterStorageProfileSnapshotController_STATUS
		err := snapshotController1.PopulateFromARM(owner, *typedInput.SnapshotController)
		if err != nil {
			return err
		}
		snapshotController := snapshotController1
		profile.SnapshotController = &snapshotController
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfile_STATUS populates our ManagedClusterStorageProfile_STATUS from the provided source ManagedClusterStorageProfile_STATUS
func (profile *ManagedClusterStorageProfile_STATUS) AssignProperties_From_ManagedClusterStorageProfile_STATUS(source *storage.ManagedClusterStorageProfile_STATUS) error {

	// BlobCSIDriver
	if source.BlobCSIDriver != nil {
		var blobCSIDriver ManagedClusterStorageProfileBlobCSIDriver_STATUS
		err := blobCSIDriver.AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver_STATUS(source.BlobCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver_STATUS() to populate field BlobCSIDriver")
		}
		profile.BlobCSIDriver = &blobCSIDriver
	} else {
		profile.BlobCSIDriver = nil
	}

	// DiskCSIDriver
	if source.DiskCSIDriver != nil {
		var diskCSIDriver ManagedClusterStorageProfileDiskCSIDriver_STATUS
		err := diskCSIDriver.AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver_STATUS(source.DiskCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver_STATUS() to populate field DiskCSIDriver")
		}
		profile.DiskCSIDriver = &diskCSIDriver
	} else {
		profile.DiskCSIDriver = nil
	}

	// FileCSIDriver
	if source.FileCSIDriver != nil {
		var fileCSIDriver ManagedClusterStorageProfileFileCSIDriver_STATUS
		err := fileCSIDriver.AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver_STATUS(source.FileCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver_STATUS() to populate field FileCSIDriver")
		}
		profile.FileCSIDriver = &fileCSIDriver
	} else {
		profile.FileCSIDriver = nil
	}

	// SnapshotController
	if source.SnapshotController != nil {
		var snapshotController ManagedClusterStorageProfileSnapshotController_STATUS
		err := snapshotController.AssignProperties_From_ManagedClusterStorageProfileSnapshotController_STATUS(source.SnapshotController)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterStorageProfileSnapshotController_STATUS() to populate field SnapshotController")
		}
		profile.SnapshotController = &snapshotController
	} else {
		profile.SnapshotController = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfile_STATUS populates the provided destination ManagedClusterStorageProfile_STATUS from our ManagedClusterStorageProfile_STATUS
func (profile *ManagedClusterStorageProfile_STATUS) AssignProperties_To_ManagedClusterStorageProfile_STATUS(destination *storage.ManagedClusterStorageProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobCSIDriver
	if profile.BlobCSIDriver != nil {
		var blobCSIDriver storage.ManagedClusterStorageProfileBlobCSIDriver_STATUS
		err := profile.BlobCSIDriver.AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver_STATUS(&blobCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver_STATUS() to populate field BlobCSIDriver")
		}
		destination.BlobCSIDriver = &blobCSIDriver
	} else {
		destination.BlobCSIDriver = nil
	}

	// DiskCSIDriver
	if profile.DiskCSIDriver != nil {
		var diskCSIDriver storage.ManagedClusterStorageProfileDiskCSIDriver_STATUS
		err := profile.DiskCSIDriver.AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver_STATUS(&diskCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver_STATUS() to populate field DiskCSIDriver")
		}
		destination.DiskCSIDriver = &diskCSIDriver
	} else {
		destination.DiskCSIDriver = nil
	}

	// FileCSIDriver
	if profile.FileCSIDriver != nil {
		var fileCSIDriver storage.ManagedClusterStorageProfileFileCSIDriver_STATUS
		err := profile.FileCSIDriver.AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver_STATUS(&fileCSIDriver)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver_STATUS() to populate field FileCSIDriver")
		}
		destination.FileCSIDriver = &fileCSIDriver
	} else {
		destination.FileCSIDriver = nil
	}

	// SnapshotController
	if profile.SnapshotController != nil {
		var snapshotController storage.ManagedClusterStorageProfileSnapshotController_STATUS
		err := profile.SnapshotController.AssignProperties_To_ManagedClusterStorageProfileSnapshotController_STATUS(&snapshotController)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterStorageProfileSnapshotController_STATUS() to populate field SnapshotController")
		}
		destination.SnapshotController = &snapshotController
	} else {
		destination.SnapshotController = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile for Windows VMs in the managed cluster.
type ManagedClusterWindowsProfile struct {
	// AdminPassword: Specifies the password of the administrator account.
	// Minimum-length: 8 characters
	// Max-length: 123 characters
	// Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	// Has lower characters
	// Has upper characters
	// Has a digit
	// Has a special character (Regex match [\W_])
	// Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
	// "Password22", "iloveyou!"
	AdminPassword *genruntime.SecretReference `json:"adminPassword,omitempty"`

	// +kubebuilder:validation:Required
	// AdminUsername: Specifies the name of the administrator account.
	// Restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length: 1 character
	// Max-length: 20 characters
	AdminUsername *string `json:"adminUsername,omitempty"`

	// EnableCSIProxy: Whether to enable CSI proxy. For more details on CSI proxy, see the [CSI proxy GitHub
	// repo](https://github.com/kubernetes-csi/csi-proxy).
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	// GmsaProfile: The Windows gMSA Profile in the Managed Cluster.
	GmsaProfile *WindowsGmsaProfile `json:"gmsaProfile,omitempty"`

	// LicenseType: The license type to use for Windows VMs. See [Azure Hybrid User
	// Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
	LicenseType *LicenseType `json:"licenseType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWindowsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterWindowsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterWindowsProfile{}

	// Set property "AdminPassword":
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*profile.AdminPassword)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property "AdminUsername":
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property "EnableCSIProxy":
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		result.EnableCSIProxy = &enableCSIProxy
	}

	// Set property "GmsaProfile":
	if profile.GmsaProfile != nil {
		gmsaProfile_ARM, err := profile.GmsaProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gmsaProfile := *gmsaProfile_ARM.(*arm.WindowsGmsaProfile)
		result.GmsaProfile = &gmsaProfile
	}

	// Set property "LicenseType":
	if profile.LicenseType != nil {
		var temp string
		temp = string(*profile.LicenseType)
		licenseType := arm.LicenseType(temp)
		result.LicenseType = &licenseType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWindowsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWindowsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWindowsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWindowsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWindowsProfile, got %T", armInput)
	}

	// no assignment for property "AdminPassword"

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "EnableCSIProxy":
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property "GmsaProfile":
	if typedInput.GmsaProfile != nil {
		var gmsaProfile1 WindowsGmsaProfile
		err := gmsaProfile1.PopulateFromARM(owner, *typedInput.GmsaProfile)
		if err != nil {
			return err
		}
		gmsaProfile := gmsaProfile1
		profile.GmsaProfile = &gmsaProfile
	}

	// Set property "LicenseType":
	if typedInput.LicenseType != nil {
		var temp string
		temp = string(*typedInput.LicenseType)
		licenseType := LicenseType(temp)
		profile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWindowsProfile populates our ManagedClusterWindowsProfile from the provided source ManagedClusterWindowsProfile
func (profile *ManagedClusterWindowsProfile) AssignProperties_From_ManagedClusterWindowsProfile(source *storage.ManagedClusterWindowsProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// GmsaProfile
	if source.GmsaProfile != nil {
		var gmsaProfile WindowsGmsaProfile
		err := gmsaProfile.AssignProperties_From_WindowsGmsaProfile(source.GmsaProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WindowsGmsaProfile() to populate field GmsaProfile")
		}
		profile.GmsaProfile = &gmsaProfile
	} else {
		profile.GmsaProfile = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := *source.LicenseType
		licenseTypeTemp := genruntime.ToEnum(licenseType, licenseType_Values)
		profile.LicenseType = &licenseTypeTemp
	} else {
		profile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWindowsProfile populates the provided destination ManagedClusterWindowsProfile from our ManagedClusterWindowsProfile
func (profile *ManagedClusterWindowsProfile) AssignProperties_To_ManagedClusterWindowsProfile(destination *storage.ManagedClusterWindowsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// GmsaProfile
	if profile.GmsaProfile != nil {
		var gmsaProfile storage.WindowsGmsaProfile
		err := profile.GmsaProfile.AssignProperties_To_WindowsGmsaProfile(&gmsaProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WindowsGmsaProfile() to populate field GmsaProfile")
		}
		destination.GmsaProfile = &gmsaProfile
	} else {
		destination.GmsaProfile = nil
	}

	// LicenseType
	if profile.LicenseType != nil {
		licenseType := string(*profile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile for Windows VMs in the managed cluster.
type ManagedClusterWindowsProfile_STATUS struct {
	// AdminUsername: Specifies the name of the administrator account.
	// Restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length: 1 character
	// Max-length: 20 characters
	AdminUsername *string `json:"adminUsername,omitempty"`

	// EnableCSIProxy: Whether to enable CSI proxy. For more details on CSI proxy, see the [CSI proxy GitHub
	// repo](https://github.com/kubernetes-csi/csi-proxy).
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	// GmsaProfile: The Windows gMSA Profile in the Managed Cluster.
	GmsaProfile *WindowsGmsaProfile_STATUS `json:"gmsaProfile,omitempty"`

	// LicenseType: The license type to use for Windows VMs. See [Azure Hybrid User
	// Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
	LicenseType *LicenseType_STATUS `json:"licenseType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWindowsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWindowsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWindowsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWindowsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWindowsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWindowsProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "EnableCSIProxy":
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property "GmsaProfile":
	if typedInput.GmsaProfile != nil {
		var gmsaProfile1 WindowsGmsaProfile_STATUS
		err := gmsaProfile1.PopulateFromARM(owner, *typedInput.GmsaProfile)
		if err != nil {
			return err
		}
		gmsaProfile := gmsaProfile1
		profile.GmsaProfile = &gmsaProfile
	}

	// Set property "LicenseType":
	if typedInput.LicenseType != nil {
		var temp string
		temp = string(*typedInput.LicenseType)
		licenseType := LicenseType_STATUS(temp)
		profile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWindowsProfile_STATUS populates our ManagedClusterWindowsProfile_STATUS from the provided source ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignProperties_From_ManagedClusterWindowsProfile_STATUS(source *storage.ManagedClusterWindowsProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// GmsaProfile
	if source.GmsaProfile != nil {
		var gmsaProfile WindowsGmsaProfile_STATUS
		err := gmsaProfile.AssignProperties_From_WindowsGmsaProfile_STATUS(source.GmsaProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WindowsGmsaProfile_STATUS() to populate field GmsaProfile")
		}
		profile.GmsaProfile = &gmsaProfile
	} else {
		profile.GmsaProfile = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := *source.LicenseType
		licenseTypeTemp := genruntime.ToEnum(licenseType, licenseType_STATUS_Values)
		profile.LicenseType = &licenseTypeTemp
	} else {
		profile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWindowsProfile_STATUS populates the provided destination ManagedClusterWindowsProfile_STATUS from our ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignProperties_To_ManagedClusterWindowsProfile_STATUS(destination *storage.ManagedClusterWindowsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// GmsaProfile
	if profile.GmsaProfile != nil {
		var gmsaProfile storage.WindowsGmsaProfile_STATUS
		err := profile.GmsaProfile.AssignProperties_To_WindowsGmsaProfile_STATUS(&gmsaProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WindowsGmsaProfile_STATUS() to populate field GmsaProfile")
		}
		destination.GmsaProfile = &gmsaProfile
	} else {
		destination.GmsaProfile = nil
	}

	// LicenseType
	if profile.LicenseType != nil {
		licenseType := string(*profile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Workload Auto-scaler profile for the managed cluster.
type ManagedClusterWorkloadAutoScalerProfile struct {
	// Keda: KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
	Keda *ManagedClusterWorkloadAutoScalerProfileKeda `json:"keda,omitempty"`

	// VerticalPodAutoscaler: VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
	VerticalPodAutoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler `json:"verticalPodAutoscaler,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWorkloadAutoScalerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterWorkloadAutoScalerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterWorkloadAutoScalerProfile{}

	// Set property "Keda":
	if profile.Keda != nil {
		keda_ARM, err := profile.Keda.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keda := *keda_ARM.(*arm.ManagedClusterWorkloadAutoScalerProfileKeda)
		result.Keda = &keda
	}

	// Set property "VerticalPodAutoscaler":
	if profile.VerticalPodAutoscaler != nil {
		verticalPodAutoscaler_ARM, err := profile.VerticalPodAutoscaler.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		verticalPodAutoscaler := *verticalPodAutoscaler_ARM.(*arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler)
		result.VerticalPodAutoscaler = &verticalPodAutoscaler
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWorkloadAutoScalerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWorkloadAutoScalerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWorkloadAutoScalerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWorkloadAutoScalerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWorkloadAutoScalerProfile, got %T", armInput)
	}

	// Set property "Keda":
	if typedInput.Keda != nil {
		var keda1 ManagedClusterWorkloadAutoScalerProfileKeda
		err := keda1.PopulateFromARM(owner, *typedInput.Keda)
		if err != nil {
			return err
		}
		keda := keda1
		profile.Keda = &keda
	}

	// Set property "VerticalPodAutoscaler":
	if typedInput.VerticalPodAutoscaler != nil {
		var verticalPodAutoscaler1 ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler
		err := verticalPodAutoscaler1.PopulateFromARM(owner, *typedInput.VerticalPodAutoscaler)
		if err != nil {
			return err
		}
		verticalPodAutoscaler := verticalPodAutoscaler1
		profile.VerticalPodAutoscaler = &verticalPodAutoscaler
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile populates our ManagedClusterWorkloadAutoScalerProfile from the provided source ManagedClusterWorkloadAutoScalerProfile
func (profile *ManagedClusterWorkloadAutoScalerProfile) AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile(source *storage.ManagedClusterWorkloadAutoScalerProfile) error {

	// Keda
	if source.Keda != nil {
		var kedum ManagedClusterWorkloadAutoScalerProfileKeda
		err := kedum.AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda(source.Keda)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda() to populate field Keda")
		}
		profile.Keda = &kedum
	} else {
		profile.Keda = nil
	}

	// VerticalPodAutoscaler
	if source.VerticalPodAutoscaler != nil {
		var verticalPodAutoscaler ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler
		err := verticalPodAutoscaler.AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler(source.VerticalPodAutoscaler)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler() to populate field VerticalPodAutoscaler")
		}
		profile.VerticalPodAutoscaler = &verticalPodAutoscaler
	} else {
		profile.VerticalPodAutoscaler = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile populates the provided destination ManagedClusterWorkloadAutoScalerProfile from our ManagedClusterWorkloadAutoScalerProfile
func (profile *ManagedClusterWorkloadAutoScalerProfile) AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile(destination *storage.ManagedClusterWorkloadAutoScalerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Keda
	if profile.Keda != nil {
		var kedum storage.ManagedClusterWorkloadAutoScalerProfileKeda
		err := profile.Keda.AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda(&kedum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda() to populate field Keda")
		}
		destination.Keda = &kedum
	} else {
		destination.Keda = nil
	}

	// VerticalPodAutoscaler
	if profile.VerticalPodAutoscaler != nil {
		var verticalPodAutoscaler storage.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler
		err := profile.VerticalPodAutoscaler.AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler(&verticalPodAutoscaler)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler() to populate field VerticalPodAutoscaler")
		}
		destination.VerticalPodAutoscaler = &verticalPodAutoscaler
	} else {
		destination.VerticalPodAutoscaler = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Workload Auto-scaler profile for the managed cluster.
type ManagedClusterWorkloadAutoScalerProfile_STATUS struct {
	// Keda: KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
	Keda *ManagedClusterWorkloadAutoScalerProfileKeda_STATUS `json:"keda,omitempty"`

	// VerticalPodAutoscaler: VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
	VerticalPodAutoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS `json:"verticalPodAutoscaler,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWorkloadAutoScalerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterWorkloadAutoScalerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWorkloadAutoScalerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterWorkloadAutoScalerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWorkloadAutoScalerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWorkloadAutoScalerProfile_STATUS, got %T", armInput)
	}

	// Set property "Keda":
	if typedInput.Keda != nil {
		var keda1 ManagedClusterWorkloadAutoScalerProfileKeda_STATUS
		err := keda1.PopulateFromARM(owner, *typedInput.Keda)
		if err != nil {
			return err
		}
		keda := keda1
		profile.Keda = &keda
	}

	// Set property "VerticalPodAutoscaler":
	if typedInput.VerticalPodAutoscaler != nil {
		var verticalPodAutoscaler1 ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS
		err := verticalPodAutoscaler1.PopulateFromARM(owner, *typedInput.VerticalPodAutoscaler)
		if err != nil {
			return err
		}
		verticalPodAutoscaler := verticalPodAutoscaler1
		profile.VerticalPodAutoscaler = &verticalPodAutoscaler
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile_STATUS populates our ManagedClusterWorkloadAutoScalerProfile_STATUS from the provided source ManagedClusterWorkloadAutoScalerProfile_STATUS
func (profile *ManagedClusterWorkloadAutoScalerProfile_STATUS) AssignProperties_From_ManagedClusterWorkloadAutoScalerProfile_STATUS(source *storage.ManagedClusterWorkloadAutoScalerProfile_STATUS) error {

	// Keda
	if source.Keda != nil {
		var kedum ManagedClusterWorkloadAutoScalerProfileKeda_STATUS
		err := kedum.AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS(source.Keda)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS() to populate field Keda")
		}
		profile.Keda = &kedum
	} else {
		profile.Keda = nil
	}

	// VerticalPodAutoscaler
	if source.VerticalPodAutoscaler != nil {
		var verticalPodAutoscaler ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS
		err := verticalPodAutoscaler.AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS(source.VerticalPodAutoscaler)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS() to populate field VerticalPodAutoscaler")
		}
		profile.VerticalPodAutoscaler = &verticalPodAutoscaler
	} else {
		profile.VerticalPodAutoscaler = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile_STATUS populates the provided destination ManagedClusterWorkloadAutoScalerProfile_STATUS from our ManagedClusterWorkloadAutoScalerProfile_STATUS
func (profile *ManagedClusterWorkloadAutoScalerProfile_STATUS) AssignProperties_To_ManagedClusterWorkloadAutoScalerProfile_STATUS(destination *storage.ManagedClusterWorkloadAutoScalerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Keda
	if profile.Keda != nil {
		var kedum storage.ManagedClusterWorkloadAutoScalerProfileKeda_STATUS
		err := profile.Keda.AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS(&kedum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS() to populate field Keda")
		}
		destination.Keda = &kedum
	} else {
		destination.Keda = nil
	}

	// VerticalPodAutoscaler
	if profile.VerticalPodAutoscaler != nil {
		var verticalPodAutoscaler storage.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS
		err := profile.VerticalPodAutoscaler.AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS(&verticalPodAutoscaler)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS() to populate field VerticalPodAutoscaler")
		}
		destination.VerticalPodAutoscaler = &verticalPodAutoscaler
	} else {
		destination.VerticalPodAutoscaler = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the Power State of the cluster
type PowerState_STATUS struct {
	// Code: Tells whether the cluster is Running or Stopped
	Code *Code_STATUS `json:"code,omitempty"`
}

var _ genruntime.FromARMConverter = &PowerState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *PowerState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PowerState_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *PowerState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PowerState_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PowerState_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		var temp string
		temp = string(*typedInput.Code)
		code := Code_STATUS(temp)
		state.Code = &code
	}

	// No error
	return nil
}

// AssignProperties_From_PowerState_STATUS populates our PowerState_STATUS from the provided source PowerState_STATUS
func (state *PowerState_STATUS) AssignProperties_From_PowerState_STATUS(source *storage.PowerState_STATUS) error {

	// Code
	if source.Code != nil {
		code := *source.Code
		codeTemp := genruntime.ToEnum(code, code_STATUS_Values)
		state.Code = &codeTemp
	} else {
		state.Code = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PowerState_STATUS populates the provided destination PowerState_STATUS from our PowerState_STATUS
func (state *PowerState_STATUS) AssignProperties_To_PowerState_STATUS(destination *storage.PowerState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	if state.Code != nil {
		code := string(*state.Code)
		destination.Code = &code
	} else {
		destination.Code = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A private link resource
type PrivateLinkResource struct {
	// GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	// Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	// Reference: The ID of the private link resource.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// RequiredMembers: The RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *PrivateLinkResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.PrivateLinkResource{}

	// Set property "GroupId":
	if resource.GroupId != nil {
		groupId := *resource.GroupId
		result.GroupId = &groupId
	}

	// Set property "Id":
	if resource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Name":
	if resource.Name != nil {
		name := *resource.Name
		result.Name = &name
	}

	// Set property "RequiredMembers":
	for _, item := range resource.RequiredMembers {
		result.RequiredMembers = append(result.RequiredMembers, item)
	}

	// Set property "Type":
	if resource.Type != nil {
		typeVar := *resource.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateLinkResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateLinkResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateLinkResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateLinkResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateLinkResource, got %T", armInput)
	}

	// Set property "GroupId":
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		resource.GroupId = &groupId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// no assignment for property "Reference"

	// Set property "RequiredMembers":
	for _, item := range typedInput.RequiredMembers {
		resource.RequiredMembers = append(resource.RequiredMembers, item)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateLinkResource populates our PrivateLinkResource from the provided source PrivateLinkResource
func (resource *PrivateLinkResource) AssignProperties_From_PrivateLinkResource(source *storage.PrivateLinkResource) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkResource populates the provided destination PrivateLinkResource from our PrivateLinkResource
func (resource *PrivateLinkResource) AssignProperties_To_PrivateLinkResource(destination *storage.PrivateLinkResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A private link resource
type PrivateLinkResource_STATUS struct {
	// GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	// Id: The ID of the private link resource.
	Id *string `json:"id,omitempty"`

	// Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	// PrivateLinkServiceID: The private link service ID of the resource, this field is exposed only to NRP internally.
	PrivateLinkServiceID *string `json:"privateLinkServiceID,omitempty"`

	// RequiredMembers: The RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateLinkResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateLinkResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateLinkResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateLinkResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateLinkResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateLinkResource_STATUS, got %T", armInput)
	}

	// Set property "GroupId":
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		resource.GroupId = &groupId
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "PrivateLinkServiceID":
	if typedInput.PrivateLinkServiceID != nil {
		privateLinkServiceID := *typedInput.PrivateLinkServiceID
		resource.PrivateLinkServiceID = &privateLinkServiceID
	}

	// Set property "RequiredMembers":
	for _, item := range typedInput.RequiredMembers {
		resource.RequiredMembers = append(resource.RequiredMembers, item)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateLinkResource_STATUS populates our PrivateLinkResource_STATUS from the provided source PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignProperties_From_PrivateLinkResource_STATUS(source *storage.PrivateLinkResource_STATUS) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkServiceID
	resource.PrivateLinkServiceID = genruntime.ClonePointerToString(source.PrivateLinkServiceID)

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkResource_STATUS populates the provided destination PrivateLinkResource_STATUS from our PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignProperties_To_PrivateLinkResource_STATUS(destination *storage.PrivateLinkResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PrivateLinkServiceID
	destination.PrivateLinkServiceID = genruntime.ClonePointerToString(resource.PrivateLinkServiceID)

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
// +kubebuilder:validation:Enum={"Disabled","Enabled","SecuredByPerimeter"}
type PublicNetworkAccess string

const (
	PublicNetworkAccess_Disabled           = PublicNetworkAccess("Disabled")
	PublicNetworkAccess_Enabled            = PublicNetworkAccess("Enabled")
	PublicNetworkAccess_SecuredByPerimeter = PublicNetworkAccess("SecuredByPerimeter")
)

// Mapping from string to PublicNetworkAccess
var publicNetworkAccess_Values = map[string]PublicNetworkAccess{
	"disabled":           PublicNetworkAccess_Disabled,
	"enabled":            PublicNetworkAccess_Enabled,
	"securedbyperimeter": PublicNetworkAccess_SecuredByPerimeter,
}

// PublicNetworkAccess of the managedCluster. Allow or deny public network access for AKS
type PublicNetworkAccess_STATUS string

const (
	PublicNetworkAccess_STATUS_Disabled           = PublicNetworkAccess_STATUS("Disabled")
	PublicNetworkAccess_STATUS_Enabled            = PublicNetworkAccess_STATUS("Enabled")
	PublicNetworkAccess_STATUS_SecuredByPerimeter = PublicNetworkAccess_STATUS("SecuredByPerimeter")
)

// Mapping from string to PublicNetworkAccess_STATUS
var publicNetworkAccess_STATUS_Values = map[string]PublicNetworkAccess_STATUS{
	"disabled":           PublicNetworkAccess_STATUS_Disabled,
	"enabled":            PublicNetworkAccess_STATUS_Enabled,
	"securedbyperimeter": PublicNetworkAccess_STATUS_SecuredByPerimeter,
}

// The pod scheduler profile for the cluster.
type SchedulerProfile struct {
	// SchedulerInstanceProfiles: Mapping of each scheduler instance to its profile.
	SchedulerInstanceProfiles *SchedulerProfileSchedulerInstanceProfiles `json:"schedulerInstanceProfiles,omitempty"`
}

var _ genruntime.ARMTransformer = &SchedulerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *SchedulerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.SchedulerProfile{}

	// Set property "SchedulerInstanceProfiles":
	if profile.SchedulerInstanceProfiles != nil {
		schedulerInstanceProfiles_ARM, err := profile.SchedulerInstanceProfiles.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedulerInstanceProfiles := *schedulerInstanceProfiles_ARM.(*arm.SchedulerProfileSchedulerInstanceProfiles)
		result.SchedulerInstanceProfiles = &schedulerInstanceProfiles
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SchedulerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SchedulerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SchedulerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SchedulerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SchedulerProfile, got %T", armInput)
	}

	// Set property "SchedulerInstanceProfiles":
	if typedInput.SchedulerInstanceProfiles != nil {
		var schedulerInstanceProfiles1 SchedulerProfileSchedulerInstanceProfiles
		err := schedulerInstanceProfiles1.PopulateFromARM(owner, *typedInput.SchedulerInstanceProfiles)
		if err != nil {
			return err
		}
		schedulerInstanceProfiles := schedulerInstanceProfiles1
		profile.SchedulerInstanceProfiles = &schedulerInstanceProfiles
	}

	// No error
	return nil
}

// AssignProperties_From_SchedulerProfile populates our SchedulerProfile from the provided source SchedulerProfile
func (profile *SchedulerProfile) AssignProperties_From_SchedulerProfile(source *storage.SchedulerProfile) error {

	// SchedulerInstanceProfiles
	if source.SchedulerInstanceProfiles != nil {
		var schedulerInstanceProfile SchedulerProfileSchedulerInstanceProfiles
		err := schedulerInstanceProfile.AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles(source.SchedulerInstanceProfiles)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles() to populate field SchedulerInstanceProfiles")
		}
		profile.SchedulerInstanceProfiles = &schedulerInstanceProfile
	} else {
		profile.SchedulerInstanceProfiles = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SchedulerProfile populates the provided destination SchedulerProfile from our SchedulerProfile
func (profile *SchedulerProfile) AssignProperties_To_SchedulerProfile(destination *storage.SchedulerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SchedulerInstanceProfiles
	if profile.SchedulerInstanceProfiles != nil {
		var schedulerInstanceProfile storage.SchedulerProfileSchedulerInstanceProfiles
		err := profile.SchedulerInstanceProfiles.AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles(&schedulerInstanceProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles() to populate field SchedulerInstanceProfiles")
		}
		destination.SchedulerInstanceProfiles = &schedulerInstanceProfile
	} else {
		destination.SchedulerInstanceProfiles = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The pod scheduler profile for the cluster.
type SchedulerProfile_STATUS struct {
	// SchedulerInstanceProfiles: Mapping of each scheduler instance to its profile.
	SchedulerInstanceProfiles *SchedulerProfileSchedulerInstanceProfiles_STATUS `json:"schedulerInstanceProfiles,omitempty"`
}

var _ genruntime.FromARMConverter = &SchedulerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SchedulerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SchedulerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SchedulerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SchedulerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SchedulerProfile_STATUS, got %T", armInput)
	}

	// Set property "SchedulerInstanceProfiles":
	if typedInput.SchedulerInstanceProfiles != nil {
		var schedulerInstanceProfiles1 SchedulerProfileSchedulerInstanceProfiles_STATUS
		err := schedulerInstanceProfiles1.PopulateFromARM(owner, *typedInput.SchedulerInstanceProfiles)
		if err != nil {
			return err
		}
		schedulerInstanceProfiles := schedulerInstanceProfiles1
		profile.SchedulerInstanceProfiles = &schedulerInstanceProfiles
	}

	// No error
	return nil
}

// AssignProperties_From_SchedulerProfile_STATUS populates our SchedulerProfile_STATUS from the provided source SchedulerProfile_STATUS
func (profile *SchedulerProfile_STATUS) AssignProperties_From_SchedulerProfile_STATUS(source *storage.SchedulerProfile_STATUS) error {

	// SchedulerInstanceProfiles
	if source.SchedulerInstanceProfiles != nil {
		var schedulerInstanceProfile SchedulerProfileSchedulerInstanceProfiles_STATUS
		err := schedulerInstanceProfile.AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles_STATUS(source.SchedulerInstanceProfiles)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles_STATUS() to populate field SchedulerInstanceProfiles")
		}
		profile.SchedulerInstanceProfiles = &schedulerInstanceProfile
	} else {
		profile.SchedulerInstanceProfiles = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SchedulerProfile_STATUS populates the provided destination SchedulerProfile_STATUS from our SchedulerProfile_STATUS
func (profile *SchedulerProfile_STATUS) AssignProperties_To_SchedulerProfile_STATUS(destination *storage.SchedulerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SchedulerInstanceProfiles
	if profile.SchedulerInstanceProfiles != nil {
		var schedulerInstanceProfile storage.SchedulerProfileSchedulerInstanceProfiles_STATUS
		err := profile.SchedulerInstanceProfiles.AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles_STATUS(&schedulerInstanceProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles_STATUS() to populate field SchedulerInstanceProfiles")
		}
		destination.SchedulerInstanceProfiles = &schedulerInstanceProfile
	} else {
		destination.SchedulerInstanceProfiles = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Service mesh profile for a managed cluster.
type ServiceMeshProfile struct {
	// Istio: Istio service mesh configuration.
	Istio *IstioServiceMesh `json:"istio,omitempty"`

	// +kubebuilder:validation:Required
	// Mode: Mode of the service mesh.
	Mode *ServiceMeshMode `json:"mode,omitempty"`
}

var _ genruntime.ARMTransformer = &ServiceMeshProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ServiceMeshProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ServiceMeshProfile{}

	// Set property "Istio":
	if profile.Istio != nil {
		istio_ARM, err := profile.Istio.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		istio := *istio_ARM.(*arm.IstioServiceMesh)
		result.Istio = &istio
	}

	// Set property "Mode":
	if profile.Mode != nil {
		var temp string
		temp = string(*profile.Mode)
		mode := arm.ServiceMeshMode(temp)
		result.Mode = &mode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ServiceMeshProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceMeshProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ServiceMeshProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceMeshProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceMeshProfile, got %T", armInput)
	}

	// Set property "Istio":
	if typedInput.Istio != nil {
		var istio1 IstioServiceMesh
		err := istio1.PopulateFromARM(owner, *typedInput.Istio)
		if err != nil {
			return err
		}
		istio := istio1
		profile.Istio = &istio
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := ServiceMeshMode(temp)
		profile.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceMeshProfile populates our ServiceMeshProfile from the provided source ServiceMeshProfile
func (profile *ServiceMeshProfile) AssignProperties_From_ServiceMeshProfile(source *storage.ServiceMeshProfile) error {

	// Istio
	if source.Istio != nil {
		var istio IstioServiceMesh
		err := istio.AssignProperties_From_IstioServiceMesh(source.Istio)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioServiceMesh() to populate field Istio")
		}
		profile.Istio = &istio
	} else {
		profile.Istio = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, serviceMeshMode_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceMeshProfile populates the provided destination ServiceMeshProfile from our ServiceMeshProfile
func (profile *ServiceMeshProfile) AssignProperties_To_ServiceMeshProfile(destination *storage.ServiceMeshProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Istio
	if profile.Istio != nil {
		var istio storage.IstioServiceMesh
		err := profile.Istio.AssignProperties_To_IstioServiceMesh(&istio)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioServiceMesh() to populate field Istio")
		}
		destination.Istio = &istio
	} else {
		destination.Istio = nil
	}

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Service mesh profile for a managed cluster.
type ServiceMeshProfile_STATUS struct {
	// Istio: Istio service mesh configuration.
	Istio *IstioServiceMesh_STATUS `json:"istio,omitempty"`

	// Mode: Mode of the service mesh.
	Mode *ServiceMeshMode_STATUS `json:"mode,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceMeshProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ServiceMeshProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceMeshProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ServiceMeshProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceMeshProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceMeshProfile_STATUS, got %T", armInput)
	}

	// Set property "Istio":
	if typedInput.Istio != nil {
		var istio1 IstioServiceMesh_STATUS
		err := istio1.PopulateFromARM(owner, *typedInput.Istio)
		if err != nil {
			return err
		}
		istio := istio1
		profile.Istio = &istio
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := ServiceMeshMode_STATUS(temp)
		profile.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceMeshProfile_STATUS populates our ServiceMeshProfile_STATUS from the provided source ServiceMeshProfile_STATUS
func (profile *ServiceMeshProfile_STATUS) AssignProperties_From_ServiceMeshProfile_STATUS(source *storage.ServiceMeshProfile_STATUS) error {

	// Istio
	if source.Istio != nil {
		var istio IstioServiceMesh_STATUS
		err := istio.AssignProperties_From_IstioServiceMesh_STATUS(source.Istio)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioServiceMesh_STATUS() to populate field Istio")
		}
		profile.Istio = &istio
	} else {
		profile.Istio = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, serviceMeshMode_STATUS_Values)
		profile.Mode = &modeTemp
	} else {
		profile.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceMeshProfile_STATUS populates the provided destination ServiceMeshProfile_STATUS from our ServiceMeshProfile_STATUS
func (profile *ServiceMeshProfile_STATUS) AssignProperties_To_ServiceMeshProfile_STATUS(destination *storage.ServiceMeshProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Istio
	if profile.Istio != nil {
		var istio storage.IstioServiceMesh_STATUS
		err := profile.Istio.AssignProperties_To_IstioServiceMesh_STATUS(&istio)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioServiceMesh_STATUS() to populate field Istio")
		}
		destination.Istio = &istio
	} else {
		destination.Istio = nil
	}

	// Mode
	if profile.Mode != nil {
		mode := string(*profile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details about a user assigned identity.
type UserAssignedIdentity struct {
	// ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty" optionalConfigMapPair:"ClientId"`

	// ClientIdFromConfig: The client ID of the user assigned identity.
	ClientIdFromConfig *genruntime.ConfigMapReference `json:"clientIdFromConfig,omitempty" optionalConfigMapPair:"ClientId"`

	// ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty" optionalConfigMapPair:"ObjectId"`

	// ObjectIdFromConfig: The object ID of the user assigned identity.
	ObjectIdFromConfig *genruntime.ConfigMapReference `json:"objectIdFromConfig,omitempty" optionalConfigMapPair:"ObjectId"`

	// ResourceReference: The resource ID of the user assigned identity.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAssignedIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *UserAssignedIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.UserAssignedIdentity{}

	// Set property "ClientId":
	if identity.ClientId != nil {
		clientId := *identity.ClientId
		result.ClientId = &clientId
	}
	if identity.ClientIdFromConfig != nil {
		clientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*identity.ClientIdFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property ClientId")
		}
		clientId := clientIdValue
		result.ClientId = &clientId
	}

	// Set property "ObjectId":
	if identity.ObjectId != nil {
		objectId := *identity.ObjectId
		result.ObjectId = &objectId
	}
	if identity.ObjectIdFromConfig != nil {
		objectIdValue, err := resolved.ResolvedConfigMaps.Lookup(*identity.ObjectIdFromConfig)
		if err != nil {
			return nil, eris.Wrap(err, "looking up configmap for property ObjectId")
		}
		objectId := objectIdValue
		result.ObjectId = &objectId
	}

	// Set property "ResourceId":
	if identity.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*identity.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// no assignment for property "ClientIdFromConfig"

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		identity.ObjectId = &objectId
	}

	// no assignment for property "ObjectIdFromConfig"

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity populates our UserAssignedIdentity from the provided source UserAssignedIdentity
func (identity *UserAssignedIdentity) AssignProperties_From_UserAssignedIdentity(source *storage.UserAssignedIdentity) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientIdFromConfig
	if source.ClientIdFromConfig != nil {
		clientIdFromConfig := source.ClientIdFromConfig.Copy()
		identity.ClientIdFromConfig = &clientIdFromConfig
	} else {
		identity.ClientIdFromConfig = nil
	}

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ObjectIdFromConfig
	if source.ObjectIdFromConfig != nil {
		objectIdFromConfig := source.ObjectIdFromConfig.Copy()
		identity.ObjectIdFromConfig = &objectIdFromConfig
	} else {
		identity.ObjectIdFromConfig = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		identity.ResourceReference = &resourceReference
	} else {
		identity.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity populates the provided destination UserAssignedIdentity from our UserAssignedIdentity
func (identity *UserAssignedIdentity) AssignProperties_To_UserAssignedIdentity(destination *storage.UserAssignedIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ClientIdFromConfig
	if identity.ClientIdFromConfig != nil {
		clientIdFromConfig := identity.ClientIdFromConfig.Copy()
		destination.ClientIdFromConfig = &clientIdFromConfig
	} else {
		destination.ClientIdFromConfig = nil
	}

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ObjectIdFromConfig
	if identity.ObjectIdFromConfig != nil {
		objectIdFromConfig := identity.ObjectIdFromConfig.Copy()
		destination.ObjectIdFromConfig = &objectIdFromConfig
	} else {
		destination.ObjectIdFromConfig = nil
	}

	// ResourceReference
	if identity.ResourceReference != nil {
		resourceReference := identity.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details about a user assigned identity.
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	// ResourceId: The resource ID of the user assigned identity.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		identity.ObjectId = &objectId
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		identity.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceId
	identity.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(identity.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see
// aka.ms/aksadvancednetworking.
type AdvancedNetworking struct {
	// Enabled: Indicates the enablement of Advanced Networking functionalities of observability and security on AKS clusters.
	// When this is set to true, all observability and security features will be set to enabled unless explicitly disabled. If
	// not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// Observability: Observability profile to enable advanced network metrics and flow logs with historical contexts.
	Observability *AdvancedNetworkingObservability `json:"observability,omitempty"`

	// Performance: Profile to enable performance-enhancing features on clusters that use Azure CNI powered by Cilium.
	Performance *AdvancedNetworkingPerformance `json:"performance,omitempty"`

	// Security: Security profile to enable security features on cilium based cluster.
	Security *AdvancedNetworkingSecurity `json:"security,omitempty"`
}

var _ genruntime.ARMTransformer = &AdvancedNetworking{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (networking *AdvancedNetworking) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if networking == nil {
		return nil, nil
	}
	result := &arm.AdvancedNetworking{}

	// Set property "Enabled":
	if networking.Enabled != nil {
		enabled := *networking.Enabled
		result.Enabled = &enabled
	}

	// Set property "Observability":
	if networking.Observability != nil {
		observability_ARM, err := networking.Observability.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		observability := *observability_ARM.(*arm.AdvancedNetworkingObservability)
		result.Observability = &observability
	}

	// Set property "Performance":
	if networking.Performance != nil {
		performance_ARM, err := networking.Performance.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		performance := *performance_ARM.(*arm.AdvancedNetworkingPerformance)
		result.Performance = &performance
	}

	// Set property "Security":
	if networking.Security != nil {
		security_ARM, err := networking.Security.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		security := *security_ARM.(*arm.AdvancedNetworkingSecurity)
		result.Security = &security
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networking *AdvancedNetworking) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworking{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networking *AdvancedNetworking) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworking)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworking, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		networking.Enabled = &enabled
	}

	// Set property "Observability":
	if typedInput.Observability != nil {
		var observability1 AdvancedNetworkingObservability
		err := observability1.PopulateFromARM(owner, *typedInput.Observability)
		if err != nil {
			return err
		}
		observability := observability1
		networking.Observability = &observability
	}

	// Set property "Performance":
	if typedInput.Performance != nil {
		var performance1 AdvancedNetworkingPerformance
		err := performance1.PopulateFromARM(owner, *typedInput.Performance)
		if err != nil {
			return err
		}
		performance := performance1
		networking.Performance = &performance
	}

	// Set property "Security":
	if typedInput.Security != nil {
		var security1 AdvancedNetworkingSecurity
		err := security1.PopulateFromARM(owner, *typedInput.Security)
		if err != nil {
			return err
		}
		security := security1
		networking.Security = &security
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworking populates our AdvancedNetworking from the provided source AdvancedNetworking
func (networking *AdvancedNetworking) AssignProperties_From_AdvancedNetworking(source *storage.AdvancedNetworking) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		networking.Enabled = &enabled
	} else {
		networking.Enabled = nil
	}

	// Observability
	if source.Observability != nil {
		var observability AdvancedNetworkingObservability
		err := observability.AssignProperties_From_AdvancedNetworkingObservability(source.Observability)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingObservability() to populate field Observability")
		}
		networking.Observability = &observability
	} else {
		networking.Observability = nil
	}

	// Performance
	if source.Performance != nil {
		var performance AdvancedNetworkingPerformance
		err := performance.AssignProperties_From_AdvancedNetworkingPerformance(source.Performance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingPerformance() to populate field Performance")
		}
		networking.Performance = &performance
	} else {
		networking.Performance = nil
	}

	// Security
	if source.Security != nil {
		var security AdvancedNetworkingSecurity
		err := security.AssignProperties_From_AdvancedNetworkingSecurity(source.Security)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingSecurity() to populate field Security")
		}
		networking.Security = &security
	} else {
		networking.Security = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworking populates the provided destination AdvancedNetworking from our AdvancedNetworking
func (networking *AdvancedNetworking) AssignProperties_To_AdvancedNetworking(destination *storage.AdvancedNetworking) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if networking.Enabled != nil {
		enabled := *networking.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Observability
	if networking.Observability != nil {
		var observability storage.AdvancedNetworkingObservability
		err := networking.Observability.AssignProperties_To_AdvancedNetworkingObservability(&observability)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingObservability() to populate field Observability")
		}
		destination.Observability = &observability
	} else {
		destination.Observability = nil
	}

	// Performance
	if networking.Performance != nil {
		var performance storage.AdvancedNetworkingPerformance
		err := networking.Performance.AssignProperties_To_AdvancedNetworkingPerformance(&performance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingPerformance() to populate field Performance")
		}
		destination.Performance = &performance
	} else {
		destination.Performance = nil
	}

	// Security
	if networking.Security != nil {
		var security storage.AdvancedNetworkingSecurity
		err := networking.Security.AssignProperties_To_AdvancedNetworkingSecurity(&security)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingSecurity() to populate field Security")
		}
		destination.Security = &security
	} else {
		destination.Security = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see
// aka.ms/aksadvancednetworking.
type AdvancedNetworking_STATUS struct {
	// Enabled: Indicates the enablement of Advanced Networking functionalities of observability and security on AKS clusters.
	// When this is set to true, all observability and security features will be set to enabled unless explicitly disabled. If
	// not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// Observability: Observability profile to enable advanced network metrics and flow logs with historical contexts.
	Observability *AdvancedNetworkingObservability_STATUS `json:"observability,omitempty"`

	// Performance: Profile to enable performance-enhancing features on clusters that use Azure CNI powered by Cilium.
	Performance *AdvancedNetworkingPerformance_STATUS `json:"performance,omitempty"`

	// Security: Security profile to enable security features on cilium based cluster.
	Security *AdvancedNetworkingSecurity_STATUS `json:"security,omitempty"`
}

var _ genruntime.FromARMConverter = &AdvancedNetworking_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (networking *AdvancedNetworking_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworking_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (networking *AdvancedNetworking_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworking_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworking_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		networking.Enabled = &enabled
	}

	// Set property "Observability":
	if typedInput.Observability != nil {
		var observability1 AdvancedNetworkingObservability_STATUS
		err := observability1.PopulateFromARM(owner, *typedInput.Observability)
		if err != nil {
			return err
		}
		observability := observability1
		networking.Observability = &observability
	}

	// Set property "Performance":
	if typedInput.Performance != nil {
		var performance1 AdvancedNetworkingPerformance_STATUS
		err := performance1.PopulateFromARM(owner, *typedInput.Performance)
		if err != nil {
			return err
		}
		performance := performance1
		networking.Performance = &performance
	}

	// Set property "Security":
	if typedInput.Security != nil {
		var security1 AdvancedNetworkingSecurity_STATUS
		err := security1.PopulateFromARM(owner, *typedInput.Security)
		if err != nil {
			return err
		}
		security := security1
		networking.Security = &security
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworking_STATUS populates our AdvancedNetworking_STATUS from the provided source AdvancedNetworking_STATUS
func (networking *AdvancedNetworking_STATUS) AssignProperties_From_AdvancedNetworking_STATUS(source *storage.AdvancedNetworking_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		networking.Enabled = &enabled
	} else {
		networking.Enabled = nil
	}

	// Observability
	if source.Observability != nil {
		var observability AdvancedNetworkingObservability_STATUS
		err := observability.AssignProperties_From_AdvancedNetworkingObservability_STATUS(source.Observability)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingObservability_STATUS() to populate field Observability")
		}
		networking.Observability = &observability
	} else {
		networking.Observability = nil
	}

	// Performance
	if source.Performance != nil {
		var performance AdvancedNetworkingPerformance_STATUS
		err := performance.AssignProperties_From_AdvancedNetworkingPerformance_STATUS(source.Performance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingPerformance_STATUS() to populate field Performance")
		}
		networking.Performance = &performance
	} else {
		networking.Performance = nil
	}

	// Security
	if source.Security != nil {
		var security AdvancedNetworkingSecurity_STATUS
		err := security.AssignProperties_From_AdvancedNetworkingSecurity_STATUS(source.Security)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingSecurity_STATUS() to populate field Security")
		}
		networking.Security = &security
	} else {
		networking.Security = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworking_STATUS populates the provided destination AdvancedNetworking_STATUS from our AdvancedNetworking_STATUS
func (networking *AdvancedNetworking_STATUS) AssignProperties_To_AdvancedNetworking_STATUS(destination *storage.AdvancedNetworking_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if networking.Enabled != nil {
		enabled := *networking.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Observability
	if networking.Observability != nil {
		var observability storage.AdvancedNetworkingObservability_STATUS
		err := networking.Observability.AssignProperties_To_AdvancedNetworkingObservability_STATUS(&observability)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingObservability_STATUS() to populate field Observability")
		}
		destination.Observability = &observability
	} else {
		destination.Observability = nil
	}

	// Performance
	if networking.Performance != nil {
		var performance storage.AdvancedNetworkingPerformance_STATUS
		err := networking.Performance.AssignProperties_To_AdvancedNetworkingPerformance_STATUS(&performance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingPerformance_STATUS() to populate field Performance")
		}
		destination.Performance = &performance
	} else {
		destination.Performance = nil
	}

	// Security
	if networking.Security != nil {
		var security storage.AdvancedNetworkingSecurity_STATUS
		err := networking.Security.AssignProperties_To_AdvancedNetworkingSecurity_STATUS(&security)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingSecurity_STATUS() to populate field Security")
		}
		destination.Security = &security
	} else {
		destination.Security = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Key Vault key management service settings for the security profile.
type AzureKeyVaultKms struct {
	// Enabled: Whether to enable Azure Key Vault key management service. The default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// KeyId: Identifier of Azure Key Vault key. See [key identifier
	// format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
	// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
	// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
	KeyId *string `json:"keyId,omitempty"`

	// KeyVaultNetworkAccess: Network access of the key vault. Network access of key vault. The possible values are `Public`
	// and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault
	// disables public access and enables private link. The default value is `Public`.
	KeyVaultNetworkAccess *AzureKeyVaultKms_KeyVaultNetworkAccess `json:"keyVaultNetworkAccess,omitempty"`

	// KeyVaultResourceReference: Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and
	// must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
	KeyVaultResourceReference *genruntime.ResourceReference `armReference:"KeyVaultResourceId" json:"keyVaultResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureKeyVaultKms{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vaultKms *AzureKeyVaultKms) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vaultKms == nil {
		return nil, nil
	}
	result := &arm.AzureKeyVaultKms{}

	// Set property "Enabled":
	if vaultKms.Enabled != nil {
		enabled := *vaultKms.Enabled
		result.Enabled = &enabled
	}

	// Set property "KeyId":
	if vaultKms.KeyId != nil {
		keyId := *vaultKms.KeyId
		result.KeyId = &keyId
	}

	// Set property "KeyVaultNetworkAccess":
	if vaultKms.KeyVaultNetworkAccess != nil {
		var temp string
		temp = string(*vaultKms.KeyVaultNetworkAccess)
		keyVaultNetworkAccess := arm.AzureKeyVaultKms_KeyVaultNetworkAccess(temp)
		result.KeyVaultNetworkAccess = &keyVaultNetworkAccess
	}

	// Set property "KeyVaultResourceId":
	if vaultKms.KeyVaultResourceReference != nil {
		keyVaultResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*vaultKms.KeyVaultResourceReference)
		if err != nil {
			return nil, err
		}
		keyVaultResourceReference := keyVaultResourceReferenceARMID
		result.KeyVaultResourceId = &keyVaultResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultKms *AzureKeyVaultKms) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureKeyVaultKms{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultKms *AzureKeyVaultKms) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureKeyVaultKms)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureKeyVaultKms, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		vaultKms.Enabled = &enabled
	}

	// Set property "KeyId":
	if typedInput.KeyId != nil {
		keyId := *typedInput.KeyId
		vaultKms.KeyId = &keyId
	}

	// Set property "KeyVaultNetworkAccess":
	if typedInput.KeyVaultNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.KeyVaultNetworkAccess)
		keyVaultNetworkAccess := AzureKeyVaultKms_KeyVaultNetworkAccess(temp)
		vaultKms.KeyVaultNetworkAccess = &keyVaultNetworkAccess
	}

	// no assignment for property "KeyVaultResourceReference"

	// No error
	return nil
}

// AssignProperties_From_AzureKeyVaultKms populates our AzureKeyVaultKms from the provided source AzureKeyVaultKms
func (vaultKms *AzureKeyVaultKms) AssignProperties_From_AzureKeyVaultKms(source *storage.AzureKeyVaultKms) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		vaultKms.Enabled = &enabled
	} else {
		vaultKms.Enabled = nil
	}

	// KeyId
	vaultKms.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeyVaultNetworkAccess
	if source.KeyVaultNetworkAccess != nil {
		keyVaultNetworkAccess := *source.KeyVaultNetworkAccess
		keyVaultNetworkAccessTemp := genruntime.ToEnum(keyVaultNetworkAccess, azureKeyVaultKms_KeyVaultNetworkAccess_Values)
		vaultKms.KeyVaultNetworkAccess = &keyVaultNetworkAccessTemp
	} else {
		vaultKms.KeyVaultNetworkAccess = nil
	}

	// KeyVaultResourceReference
	if source.KeyVaultResourceReference != nil {
		keyVaultResourceReference := source.KeyVaultResourceReference.Copy()
		vaultKms.KeyVaultResourceReference = &keyVaultResourceReference
	} else {
		vaultKms.KeyVaultResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureKeyVaultKms populates the provided destination AzureKeyVaultKms from our AzureKeyVaultKms
func (vaultKms *AzureKeyVaultKms) AssignProperties_To_AzureKeyVaultKms(destination *storage.AzureKeyVaultKms) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if vaultKms.Enabled != nil {
		enabled := *vaultKms.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(vaultKms.KeyId)

	// KeyVaultNetworkAccess
	if vaultKms.KeyVaultNetworkAccess != nil {
		keyVaultNetworkAccess := string(*vaultKms.KeyVaultNetworkAccess)
		destination.KeyVaultNetworkAccess = &keyVaultNetworkAccess
	} else {
		destination.KeyVaultNetworkAccess = nil
	}

	// KeyVaultResourceReference
	if vaultKms.KeyVaultResourceReference != nil {
		keyVaultResourceReference := vaultKms.KeyVaultResourceReference.Copy()
		destination.KeyVaultResourceReference = &keyVaultResourceReference
	} else {
		destination.KeyVaultResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Key Vault key management service settings for the security profile.
type AzureKeyVaultKms_STATUS struct {
	// Enabled: Whether to enable Azure Key Vault key management service. The default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// KeyId: Identifier of Azure Key Vault key. See [key identifier
	// format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
	// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
	// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
	KeyId *string `json:"keyId,omitempty"`

	// KeyVaultNetworkAccess: Network access of the key vault. Network access of key vault. The possible values are `Public`
	// and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault
	// disables public access and enables private link. The default value is `Public`.
	KeyVaultNetworkAccess *AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS `json:"keyVaultNetworkAccess,omitempty"`

	// KeyVaultResourceId: Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must
	// be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
	KeyVaultResourceId *string `json:"keyVaultResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureKeyVaultKms_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultKms *AzureKeyVaultKms_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureKeyVaultKms_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultKms *AzureKeyVaultKms_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureKeyVaultKms_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureKeyVaultKms_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		vaultKms.Enabled = &enabled
	}

	// Set property "KeyId":
	if typedInput.KeyId != nil {
		keyId := *typedInput.KeyId
		vaultKms.KeyId = &keyId
	}

	// Set property "KeyVaultNetworkAccess":
	if typedInput.KeyVaultNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.KeyVaultNetworkAccess)
		keyVaultNetworkAccess := AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS(temp)
		vaultKms.KeyVaultNetworkAccess = &keyVaultNetworkAccess
	}

	// Set property "KeyVaultResourceId":
	if typedInput.KeyVaultResourceId != nil {
		keyVaultResourceId := *typedInput.KeyVaultResourceId
		vaultKms.KeyVaultResourceId = &keyVaultResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_AzureKeyVaultKms_STATUS populates our AzureKeyVaultKms_STATUS from the provided source AzureKeyVaultKms_STATUS
func (vaultKms *AzureKeyVaultKms_STATUS) AssignProperties_From_AzureKeyVaultKms_STATUS(source *storage.AzureKeyVaultKms_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		vaultKms.Enabled = &enabled
	} else {
		vaultKms.Enabled = nil
	}

	// KeyId
	vaultKms.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeyVaultNetworkAccess
	if source.KeyVaultNetworkAccess != nil {
		keyVaultNetworkAccess := *source.KeyVaultNetworkAccess
		keyVaultNetworkAccessTemp := genruntime.ToEnum(keyVaultNetworkAccess, azureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Values)
		vaultKms.KeyVaultNetworkAccess = &keyVaultNetworkAccessTemp
	} else {
		vaultKms.KeyVaultNetworkAccess = nil
	}

	// KeyVaultResourceId
	vaultKms.KeyVaultResourceId = genruntime.ClonePointerToString(source.KeyVaultResourceId)

	// No error
	return nil
}

// AssignProperties_To_AzureKeyVaultKms_STATUS populates the provided destination AzureKeyVaultKms_STATUS from our AzureKeyVaultKms_STATUS
func (vaultKms *AzureKeyVaultKms_STATUS) AssignProperties_To_AzureKeyVaultKms_STATUS(destination *storage.AzureKeyVaultKms_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if vaultKms.Enabled != nil {
		enabled := *vaultKms.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(vaultKms.KeyId)

	// KeyVaultNetworkAccess
	if vaultKms.KeyVaultNetworkAccess != nil {
		keyVaultNetworkAccess := string(*vaultKms.KeyVaultNetworkAccess)
		destination.KeyVaultNetworkAccess = &keyVaultNetworkAccess
	} else {
		destination.KeyVaultNetworkAccess = nil
	}

	// KeyVaultResourceId
	destination.KeyVaultResourceId = genruntime.ClonePointerToString(vaultKms.KeyVaultResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Tells whether the cluster is Running or Stopped
type Code_STATUS string

const (
	Code_STATUS_Running = Code_STATUS("Running")
	Code_STATUS_Stopped = Code_STATUS("Stopped")
)

// Mapping from string to Code_STATUS
var code_STATUS_Values = map[string]Code_STATUS{
	"running": Code_STATUS_Running,
	"stopped": Code_STATUS_Stopped,
}

// +kubebuilder:validation:Enum={"loadBalancer","managedNATGateway","none","userAssignedNATGateway","userDefinedRouting"}
type ContainerServiceNetworkProfile_OutboundType string

const (
	ContainerServiceNetworkProfile_OutboundType_LoadBalancer           = ContainerServiceNetworkProfile_OutboundType("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_ManagedNATGateway      = ContainerServiceNetworkProfile_OutboundType("managedNATGateway")
	ContainerServiceNetworkProfile_OutboundType_None                   = ContainerServiceNetworkProfile_OutboundType("none")
	ContainerServiceNetworkProfile_OutboundType_UserAssignedNATGateway = ContainerServiceNetworkProfile_OutboundType("userAssignedNATGateway")
	ContainerServiceNetworkProfile_OutboundType_UserDefinedRouting     = ContainerServiceNetworkProfile_OutboundType("userDefinedRouting")
)

// Mapping from string to ContainerServiceNetworkProfile_OutboundType
var containerServiceNetworkProfile_OutboundType_Values = map[string]ContainerServiceNetworkProfile_OutboundType{
	"loadbalancer":           ContainerServiceNetworkProfile_OutboundType_LoadBalancer,
	"managednatgateway":      ContainerServiceNetworkProfile_OutboundType_ManagedNATGateway,
	"none":                   ContainerServiceNetworkProfile_OutboundType_None,
	"userassignednatgateway": ContainerServiceNetworkProfile_OutboundType_UserAssignedNATGateway,
	"userdefinedrouting":     ContainerServiceNetworkProfile_OutboundType_UserDefinedRouting,
}

type ContainerServiceNetworkProfile_OutboundType_STATUS string

const (
	ContainerServiceNetworkProfile_OutboundType_STATUS_LoadBalancer           = ContainerServiceNetworkProfile_OutboundType_STATUS("loadBalancer")
	ContainerServiceNetworkProfile_OutboundType_STATUS_ManagedNATGateway      = ContainerServiceNetworkProfile_OutboundType_STATUS("managedNATGateway")
	ContainerServiceNetworkProfile_OutboundType_STATUS_None                   = ContainerServiceNetworkProfile_OutboundType_STATUS("none")
	ContainerServiceNetworkProfile_OutboundType_STATUS_UserAssignedNATGateway = ContainerServiceNetworkProfile_OutboundType_STATUS("userAssignedNATGateway")
	ContainerServiceNetworkProfile_OutboundType_STATUS_UserDefinedRouting     = ContainerServiceNetworkProfile_OutboundType_STATUS("userDefinedRouting")
)

// Mapping from string to ContainerServiceNetworkProfile_OutboundType_STATUS
var containerServiceNetworkProfile_OutboundType_STATUS_Values = map[string]ContainerServiceNetworkProfile_OutboundType_STATUS{
	"loadbalancer":           ContainerServiceNetworkProfile_OutboundType_STATUS_LoadBalancer,
	"managednatgateway":      ContainerServiceNetworkProfile_OutboundType_STATUS_ManagedNATGateway,
	"none":                   ContainerServiceNetworkProfile_OutboundType_STATUS_None,
	"userassignednatgateway": ContainerServiceNetworkProfile_OutboundType_STATUS_UserAssignedNATGateway,
	"userdefinedrouting":     ContainerServiceNetworkProfile_OutboundType_STATUS_UserDefinedRouting,
}

// Holds configuration customizations for kube-proxy. Any values not defined will use the kube-proxy defaulting behavior.
// See https://v<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/ where <version> is
// represented by a <major version>-<minor version> string. Kubernetes version 1.23 would be '1-23'.
type ContainerServiceNetworkProfileKubeProxyConfig struct {
	// Enabled: Whether to enable on kube-proxy on the cluster (if no 'kubeProxyConfig' exists, kube-proxy is enabled in AKS by
	// default without these customizations).
	Enabled *bool `json:"enabled,omitempty"`

	// IpvsConfig: Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.
	IpvsConfig *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig `json:"ipvsConfig,omitempty"`

	// Mode: Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
	Mode *Mode `json:"mode,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceNetworkProfileKubeProxyConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ContainerServiceNetworkProfileKubeProxyConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceNetworkProfileKubeProxyConfig{}

	// Set property "Enabled":
	if config.Enabled != nil {
		enabled := *config.Enabled
		result.Enabled = &enabled
	}

	// Set property "IpvsConfig":
	if config.IpvsConfig != nil {
		ipvsConfig_ARM, err := config.IpvsConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ipvsConfig := *ipvsConfig_ARM.(*arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig)
		result.IpvsConfig = &ipvsConfig
	}

	// Set property "Mode":
	if config.Mode != nil {
		var temp string
		temp = string(*config.Mode)
		mode := arm.Mode(temp)
		result.Mode = &mode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ContainerServiceNetworkProfileKubeProxyConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfileKubeProxyConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ContainerServiceNetworkProfileKubeProxyConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfileKubeProxyConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfileKubeProxyConfig, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		config.Enabled = &enabled
	}

	// Set property "IpvsConfig":
	if typedInput.IpvsConfig != nil {
		var ipvsConfig1 ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig
		err := ipvsConfig1.PopulateFromARM(owner, *typedInput.IpvsConfig)
		if err != nil {
			return err
		}
		ipvsConfig := ipvsConfig1
		config.IpvsConfig = &ipvsConfig
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := Mode(temp)
		config.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig populates our ContainerServiceNetworkProfileKubeProxyConfig from the provided source ContainerServiceNetworkProfileKubeProxyConfig
func (config *ContainerServiceNetworkProfileKubeProxyConfig) AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig(source *storage.ContainerServiceNetworkProfileKubeProxyConfig) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		config.Enabled = &enabled
	} else {
		config.Enabled = nil
	}

	// IpvsConfig
	if source.IpvsConfig != nil {
		var ipvsConfig ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig
		err := ipvsConfig.AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig(source.IpvsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig() to populate field IpvsConfig")
		}
		config.IpvsConfig = &ipvsConfig
	} else {
		config.IpvsConfig = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, mode_Values)
		config.Mode = &modeTemp
	} else {
		config.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig populates the provided destination ContainerServiceNetworkProfileKubeProxyConfig from our ContainerServiceNetworkProfileKubeProxyConfig
func (config *ContainerServiceNetworkProfileKubeProxyConfig) AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig(destination *storage.ContainerServiceNetworkProfileKubeProxyConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if config.Enabled != nil {
		enabled := *config.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IpvsConfig
	if config.IpvsConfig != nil {
		var ipvsConfig storage.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig
		err := config.IpvsConfig.AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig(&ipvsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig() to populate field IpvsConfig")
		}
		destination.IpvsConfig = &ipvsConfig
	} else {
		destination.IpvsConfig = nil
	}

	// Mode
	if config.Mode != nil {
		mode := string(*config.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Holds configuration customizations for kube-proxy. Any values not defined will use the kube-proxy defaulting behavior.
// See https://v<version>.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/ where <version> is
// represented by a <major version>-<minor version> string. Kubernetes version 1.23 would be '1-23'.
type ContainerServiceNetworkProfileKubeProxyConfig_STATUS struct {
	// Enabled: Whether to enable on kube-proxy on the cluster (if no 'kubeProxyConfig' exists, kube-proxy is enabled in AKS by
	// default without these customizations).
	Enabled *bool `json:"enabled,omitempty"`

	// IpvsConfig: Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.
	IpvsConfig *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS `json:"ipvsConfig,omitempty"`

	// Mode: Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
	Mode *Mode_STATUS `json:"mode,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceNetworkProfileKubeProxyConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ContainerServiceNetworkProfileKubeProxyConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfileKubeProxyConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ContainerServiceNetworkProfileKubeProxyConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfileKubeProxyConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfileKubeProxyConfig_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		config.Enabled = &enabled
	}

	// Set property "IpvsConfig":
	if typedInput.IpvsConfig != nil {
		var ipvsConfig1 ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS
		err := ipvsConfig1.PopulateFromARM(owner, *typedInput.IpvsConfig)
		if err != nil {
			return err
		}
		ipvsConfig := ipvsConfig1
		config.IpvsConfig = &ipvsConfig
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := Mode_STATUS(temp)
		config.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig_STATUS populates our ContainerServiceNetworkProfileKubeProxyConfig_STATUS from the provided source ContainerServiceNetworkProfileKubeProxyConfig_STATUS
func (config *ContainerServiceNetworkProfileKubeProxyConfig_STATUS) AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfig_STATUS(source *storage.ContainerServiceNetworkProfileKubeProxyConfig_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		config.Enabled = &enabled
	} else {
		config.Enabled = nil
	}

	// IpvsConfig
	if source.IpvsConfig != nil {
		var ipvsConfig ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS
		err := ipvsConfig.AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS(source.IpvsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS() to populate field IpvsConfig")
		}
		config.IpvsConfig = &ipvsConfig
	} else {
		config.IpvsConfig = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, mode_STATUS_Values)
		config.Mode = &modeTemp
	} else {
		config.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig_STATUS populates the provided destination ContainerServiceNetworkProfileKubeProxyConfig_STATUS from our ContainerServiceNetworkProfileKubeProxyConfig_STATUS
func (config *ContainerServiceNetworkProfileKubeProxyConfig_STATUS) AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfig_STATUS(destination *storage.ContainerServiceNetworkProfileKubeProxyConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if config.Enabled != nil {
		enabled := *config.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IpvsConfig
	if config.IpvsConfig != nil {
		var ipvsConfig storage.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS
		err := config.IpvsConfig.AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS(&ipvsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS() to populate field IpvsConfig")
		}
		destination.IpvsConfig = &ipvsConfig
	} else {
		destination.IpvsConfig = nil
	}

	// Mode
	if config.Mode != nil {
		mode := string(*config.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SSH configuration for Linux-based VMs running on Azure.
type ContainerServiceSshConfiguration struct {
	// +kubebuilder:validation:Required
	// PublicKeys: The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
	PublicKeys []ContainerServiceSshPublicKey `json:"publicKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ContainerServiceSshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceSshConfiguration{}

	// Set property "PublicKeys":
	for _, item := range configuration.PublicKeys {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, *item_ARM.(*arm.ContainerServiceSshPublicKey))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ContainerServiceSshConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ContainerServiceSshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshConfiguration, got %T", armInput)
	}

	// Set property "PublicKeys":
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshConfiguration populates our ContainerServiceSshConfiguration from the provided source ContainerServiceSshConfiguration
func (configuration *ContainerServiceSshConfiguration) AssignProperties_From_ContainerServiceSshConfiguration(source *storage.ContainerServiceSshConfiguration) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			var publicKey ContainerServiceSshPublicKey
			err := publicKey.AssignProperties_From_ContainerServiceSshPublicKey(&publicKeyItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshConfiguration populates the provided destination ContainerServiceSshConfiguration from our ContainerServiceSshConfiguration
func (configuration *ContainerServiceSshConfiguration) AssignProperties_To_ContainerServiceSshConfiguration(destination *storage.ContainerServiceSshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]storage.ContainerServiceSshPublicKey, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			var publicKey storage.ContainerServiceSshPublicKey
			err := publicKeyItem.AssignProperties_To_ContainerServiceSshPublicKey(&publicKey)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SSH configuration for Linux-based VMs running on Azure.
type ContainerServiceSshConfiguration_STATUS struct {
	// PublicKeys: The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
	PublicKeys []ContainerServiceSshPublicKey_STATUS `json:"publicKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ContainerServiceSshConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ContainerServiceSshConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshConfiguration_STATUS, got %T", armInput)
	}

	// Set property "PublicKeys":
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshConfiguration_STATUS populates our ContainerServiceSshConfiguration_STATUS from the provided source ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignProperties_From_ContainerServiceSshConfiguration_STATUS(source *storage.ContainerServiceSshConfiguration_STATUS) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			var publicKey ContainerServiceSshPublicKey_STATUS
			err := publicKey.AssignProperties_From_ContainerServiceSshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshConfiguration_STATUS populates the provided destination ContainerServiceSshConfiguration_STATUS from our ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignProperties_To_ContainerServiceSshConfiguration_STATUS(destination *storage.ContainerServiceSshConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]storage.ContainerServiceSshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			var publicKey storage.ContainerServiceSshPublicKey_STATUS
			err := publicKeyItem.AssignProperties_To_ContainerServiceSshPublicKey_STATUS(&publicKey)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Delegated resource properties - internal use only.
type DelegatedResource struct {
	// Location: The source resource location - internal use only.
	Location *string `json:"location,omitempty"`

	// ReferralResource: The delegation id of the referral delegation (optional) - internal use only.
	ReferralResource *string `json:"referralResource,omitempty"`

	// ResourceReference: The ARM resource id of the delegated resource - internal use only.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// TenantId: The tenant id of the delegated resource - internal use only.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.ARMTransformer = &DelegatedResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *DelegatedResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.DelegatedResource{}

	// Set property "Location":
	if resource.Location != nil {
		location := *resource.Location
		result.Location = &location
	}

	// Set property "ReferralResource":
	if resource.ReferralResource != nil {
		referralResource := *resource.ReferralResource
		result.ReferralResource = &referralResource
	}

	// Set property "ResourceId":
	if resource.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*resource.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}

	// Set property "TenantId":
	if resource.TenantId != nil {
		tenantId := *resource.TenantId
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *DelegatedResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DelegatedResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *DelegatedResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DelegatedResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DelegatedResource, got %T", armInput)
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property "ReferralResource":
	if typedInput.ReferralResource != nil {
		referralResource := *typedInput.ReferralResource
		resource.ReferralResource = &referralResource
	}

	// no assignment for property "ResourceReference"

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		resource.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_DelegatedResource populates our DelegatedResource from the provided source DelegatedResource
func (resource *DelegatedResource) AssignProperties_From_DelegatedResource(source *storage.DelegatedResource) error {

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// ReferralResource
	resource.ReferralResource = genruntime.ClonePointerToString(source.ReferralResource)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		resource.ResourceReference = &resourceReference
	} else {
		resource.ResourceReference = nil
	}

	// TenantId
	resource.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_DelegatedResource populates the provided destination DelegatedResource from our DelegatedResource
func (resource *DelegatedResource) AssignProperties_To_DelegatedResource(destination *storage.DelegatedResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// ReferralResource
	destination.ReferralResource = genruntime.ClonePointerToString(resource.ReferralResource)

	// ResourceReference
	if resource.ResourceReference != nil {
		resourceReference := resource.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(resource.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Delegated resource properties - internal use only.
type DelegatedResource_STATUS struct {
	// Location: The source resource location - internal use only.
	Location *string `json:"location,omitempty"`

	// ReferralResource: The delegation id of the referral delegation (optional) - internal use only.
	ReferralResource *string `json:"referralResource,omitempty"`

	// ResourceId: The ARM resource id of the delegated resource - internal use only.
	ResourceId *string `json:"resourceId,omitempty"`

	// TenantId: The tenant id of the delegated resource - internal use only.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &DelegatedResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *DelegatedResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DelegatedResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *DelegatedResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DelegatedResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DelegatedResource_STATUS, got %T", armInput)
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property "ReferralResource":
	if typedInput.ReferralResource != nil {
		referralResource := *typedInput.ReferralResource
		resource.ReferralResource = &referralResource
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		resource.ResourceId = &resourceId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		resource.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_DelegatedResource_STATUS populates our DelegatedResource_STATUS from the provided source DelegatedResource_STATUS
func (resource *DelegatedResource_STATUS) AssignProperties_From_DelegatedResource_STATUS(source *storage.DelegatedResource_STATUS) error {

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// ReferralResource
	resource.ReferralResource = genruntime.ClonePointerToString(source.ReferralResource)

	// ResourceId
	resource.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// TenantId
	resource.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_DelegatedResource_STATUS populates the provided destination DelegatedResource_STATUS from our DelegatedResource_STATUS
func (resource *DelegatedResource_STATUS) AssignProperties_To_DelegatedResource_STATUS(destination *storage.DelegatedResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// ReferralResource
	destination.ReferralResource = genruntime.ClonePointerToString(resource.ReferralResource)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(resource.ResourceId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(resource.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The error detail.
type ErrorDetail_STATUS struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The error details.
	Details []ErrorDetail_STATUS_Unrolled `json:"details,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detail *ErrorDetail_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorDetail_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detail *ErrorDetail_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorDetail_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorDetail_STATUS, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.AdditionalInfo = append(detail.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		detail.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ErrorDetail_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.Details = append(detail.Details, item1)
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		detail.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		detail.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS populates our ErrorDetail_STATUS from the provided source ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_From_ErrorDetail_STATUS(source *storage.ErrorDetail_STATUS) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		detail.AdditionalInfo = additionalInfoList
	} else {
		detail.AdditionalInfo = nil
	}

	// Code
	detail.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ErrorDetail_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			var detailLocal ErrorDetail_STATUS_Unrolled
			err := detailLocal.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&detailItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		detail.Details = detailList
	} else {
		detail.Details = nil
	}

	// Message
	detail.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	detail.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS populates the provided destination ErrorDetail_STATUS from our ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_To_ErrorDetail_STATUS(destination *storage.ErrorDetail_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if detail.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(detail.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range detail.AdditionalInfo {
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(detail.Code)

	// Details
	if detail.Details != nil {
		detailList := make([]storage.ErrorDetail_STATUS_Unrolled, len(detail.Details))
		for detailIndex, detailItem := range detail.Details {
			var detailLocal storage.ErrorDetail_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&detailLocal)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(detail.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(detail.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The expander to use when scaling up. If not specified, the default is 'random'. See
// [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more
// information.
// +kubebuilder:validation:Enum={"least-waste","most-pods","priority","random"}
type Expander string

const (
	Expander_LeastWaste = Expander("least-waste")
	Expander_MostPods   = Expander("most-pods")
	Expander_Priority   = Expander("priority")
	Expander_Random     = Expander("random")
)

// Mapping from string to Expander
var expander_Values = map[string]Expander{
	"least-waste": Expander_LeastWaste,
	"most-pods":   Expander_MostPods,
	"priority":    Expander_Priority,
	"random":      Expander_Random,
}

// The expander to use when scaling up. If not specified, the default is 'random'. See
// [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more
// information.
type Expander_STATUS string

const (
	Expander_STATUS_LeastWaste = Expander_STATUS("least-waste")
	Expander_STATUS_MostPods   = Expander_STATUS("most-pods")
	Expander_STATUS_Priority   = Expander_STATUS("priority")
	Expander_STATUS_Random     = Expander_STATUS("random")
)

// Mapping from string to Expander_STATUS
var expander_STATUS_Values = map[string]Expander_STATUS{
	"least-waste": Expander_STATUS_LeastWaste,
	"most-pods":   Expander_STATUS_MostPods,
	"priority":    Expander_STATUS_Priority,
	"random":      Expander_STATUS_Random,
}

// The type of extendedLocation.
// +kubebuilder:validation:Enum={"EdgeZone"}
type ExtendedLocationTypes string

const ExtendedLocationTypes_EdgeZone = ExtendedLocationTypes("EdgeZone")

// Mapping from string to ExtendedLocationTypes
var extendedLocationTypes_Values = map[string]ExtendedLocationTypes{
	"edgezone": ExtendedLocationTypes_EdgeZone,
}

// The type of extendedLocation.
type ExtendedLocationTypes_STATUS string

const ExtendedLocationTypes_STATUS_EdgeZone = ExtendedLocationTypes_STATUS("EdgeZone")

// Mapping from string to ExtendedLocationTypes_STATUS
var extendedLocationTypes_STATUS_Values = map[string]ExtendedLocationTypes_STATUS{
	"edgezone": ExtendedLocationTypes_STATUS_EdgeZone,
}

// To determine if address belongs IPv4 or IPv6 family
// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type IPFamily string

const (
	IPFamily_IPv4 = IPFamily("IPv4")
	IPFamily_IPv6 = IPFamily("IPv6")
)

// Mapping from string to IPFamily
var iPFamily_Values = map[string]IPFamily{
	"ipv4": IPFamily_IPv4,
	"ipv6": IPFamily_IPv6,
}

// To determine if address belongs IPv4 or IPv6 family
type IPFamily_STATUS string

const (
	IPFamily_STATUS_IPv4 = IPFamily_STATUS("IPv4")
	IPFamily_STATUS_IPv6 = IPFamily_STATUS("IPv6")
)

// Mapping from string to IPFamily_STATUS
var iPFamily_STATUS_Values = map[string]IPFamily_STATUS{
	"ipv4": IPFamily_STATUS_IPv4,
	"ipv6": IPFamily_STATUS_IPv6,
}

// Istio service mesh configuration.
type IstioServiceMesh struct {
	// CertificateAuthority: Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin
	// certificates as described here https://aka.ms/asm-plugin-ca
	CertificateAuthority *IstioCertificateAuthority `json:"certificateAuthority,omitempty"`

	// Components: Istio components configuration.
	Components *IstioComponents `json:"components,omitempty"`

	// +kubebuilder:validation:MaxItems=2
	// Revisions: The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value.
	// When canary upgrade is in progress, this can only hold two consecutive values. For more information, see:
	// https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
	Revisions []string `json:"revisions,omitempty"`
}

var _ genruntime.ARMTransformer = &IstioServiceMesh{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mesh *IstioServiceMesh) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mesh == nil {
		return nil, nil
	}
	result := &arm.IstioServiceMesh{}

	// Set property "CertificateAuthority":
	if mesh.CertificateAuthority != nil {
		certificateAuthority_ARM, err := mesh.CertificateAuthority.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		certificateAuthority := *certificateAuthority_ARM.(*arm.IstioCertificateAuthority)
		result.CertificateAuthority = &certificateAuthority
	}

	// Set property "Components":
	if mesh.Components != nil {
		components_ARM, err := mesh.Components.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		components := *components_ARM.(*arm.IstioComponents)
		result.Components = &components
	}

	// Set property "Revisions":
	for _, item := range mesh.Revisions {
		result.Revisions = append(result.Revisions, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mesh *IstioServiceMesh) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioServiceMesh{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mesh *IstioServiceMesh) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioServiceMesh)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioServiceMesh, got %T", armInput)
	}

	// Set property "CertificateAuthority":
	if typedInput.CertificateAuthority != nil {
		var certificateAuthority1 IstioCertificateAuthority
		err := certificateAuthority1.PopulateFromARM(owner, *typedInput.CertificateAuthority)
		if err != nil {
			return err
		}
		certificateAuthority := certificateAuthority1
		mesh.CertificateAuthority = &certificateAuthority
	}

	// Set property "Components":
	if typedInput.Components != nil {
		var components1 IstioComponents
		err := components1.PopulateFromARM(owner, *typedInput.Components)
		if err != nil {
			return err
		}
		components := components1
		mesh.Components = &components
	}

	// Set property "Revisions":
	for _, item := range typedInput.Revisions {
		mesh.Revisions = append(mesh.Revisions, item)
	}

	// No error
	return nil
}

// AssignProperties_From_IstioServiceMesh populates our IstioServiceMesh from the provided source IstioServiceMesh
func (mesh *IstioServiceMesh) AssignProperties_From_IstioServiceMesh(source *storage.IstioServiceMesh) error {

	// CertificateAuthority
	if source.CertificateAuthority != nil {
		var certificateAuthority IstioCertificateAuthority
		err := certificateAuthority.AssignProperties_From_IstioCertificateAuthority(source.CertificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioCertificateAuthority() to populate field CertificateAuthority")
		}
		mesh.CertificateAuthority = &certificateAuthority
	} else {
		mesh.CertificateAuthority = nil
	}

	// Components
	if source.Components != nil {
		var component IstioComponents
		err := component.AssignProperties_From_IstioComponents(source.Components)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioComponents() to populate field Components")
		}
		mesh.Components = &component
	} else {
		mesh.Components = nil
	}

	// Revisions
	mesh.Revisions = genruntime.CloneSliceOfString(source.Revisions)

	// No error
	return nil
}

// AssignProperties_To_IstioServiceMesh populates the provided destination IstioServiceMesh from our IstioServiceMesh
func (mesh *IstioServiceMesh) AssignProperties_To_IstioServiceMesh(destination *storage.IstioServiceMesh) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateAuthority
	if mesh.CertificateAuthority != nil {
		var certificateAuthority storage.IstioCertificateAuthority
		err := mesh.CertificateAuthority.AssignProperties_To_IstioCertificateAuthority(&certificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioCertificateAuthority() to populate field CertificateAuthority")
		}
		destination.CertificateAuthority = &certificateAuthority
	} else {
		destination.CertificateAuthority = nil
	}

	// Components
	if mesh.Components != nil {
		var component storage.IstioComponents
		err := mesh.Components.AssignProperties_To_IstioComponents(&component)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioComponents() to populate field Components")
		}
		destination.Components = &component
	} else {
		destination.Components = nil
	}

	// Revisions
	destination.Revisions = genruntime.CloneSliceOfString(mesh.Revisions)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio service mesh configuration.
type IstioServiceMesh_STATUS struct {
	// CertificateAuthority: Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin
	// certificates as described here https://aka.ms/asm-plugin-ca
	CertificateAuthority *IstioCertificateAuthority_STATUS `json:"certificateAuthority,omitempty"`

	// Components: Istio components configuration.
	Components *IstioComponents_STATUS `json:"components,omitempty"`

	// Revisions: The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value.
	// When canary upgrade is in progress, this can only hold two consecutive values. For more information, see:
	// https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
	Revisions []string `json:"revisions,omitempty"`
}

var _ genruntime.FromARMConverter = &IstioServiceMesh_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mesh *IstioServiceMesh_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioServiceMesh_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mesh *IstioServiceMesh_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioServiceMesh_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioServiceMesh_STATUS, got %T", armInput)
	}

	// Set property "CertificateAuthority":
	if typedInput.CertificateAuthority != nil {
		var certificateAuthority1 IstioCertificateAuthority_STATUS
		err := certificateAuthority1.PopulateFromARM(owner, *typedInput.CertificateAuthority)
		if err != nil {
			return err
		}
		certificateAuthority := certificateAuthority1
		mesh.CertificateAuthority = &certificateAuthority
	}

	// Set property "Components":
	if typedInput.Components != nil {
		var components1 IstioComponents_STATUS
		err := components1.PopulateFromARM(owner, *typedInput.Components)
		if err != nil {
			return err
		}
		components := components1
		mesh.Components = &components
	}

	// Set property "Revisions":
	for _, item := range typedInput.Revisions {
		mesh.Revisions = append(mesh.Revisions, item)
	}

	// No error
	return nil
}

// AssignProperties_From_IstioServiceMesh_STATUS populates our IstioServiceMesh_STATUS from the provided source IstioServiceMesh_STATUS
func (mesh *IstioServiceMesh_STATUS) AssignProperties_From_IstioServiceMesh_STATUS(source *storage.IstioServiceMesh_STATUS) error {

	// CertificateAuthority
	if source.CertificateAuthority != nil {
		var certificateAuthority IstioCertificateAuthority_STATUS
		err := certificateAuthority.AssignProperties_From_IstioCertificateAuthority_STATUS(source.CertificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioCertificateAuthority_STATUS() to populate field CertificateAuthority")
		}
		mesh.CertificateAuthority = &certificateAuthority
	} else {
		mesh.CertificateAuthority = nil
	}

	// Components
	if source.Components != nil {
		var component IstioComponents_STATUS
		err := component.AssignProperties_From_IstioComponents_STATUS(source.Components)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioComponents_STATUS() to populate field Components")
		}
		mesh.Components = &component
	} else {
		mesh.Components = nil
	}

	// Revisions
	mesh.Revisions = genruntime.CloneSliceOfString(source.Revisions)

	// No error
	return nil
}

// AssignProperties_To_IstioServiceMesh_STATUS populates the provided destination IstioServiceMesh_STATUS from our IstioServiceMesh_STATUS
func (mesh *IstioServiceMesh_STATUS) AssignProperties_To_IstioServiceMesh_STATUS(destination *storage.IstioServiceMesh_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateAuthority
	if mesh.CertificateAuthority != nil {
		var certificateAuthority storage.IstioCertificateAuthority_STATUS
		err := mesh.CertificateAuthority.AssignProperties_To_IstioCertificateAuthority_STATUS(&certificateAuthority)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioCertificateAuthority_STATUS() to populate field CertificateAuthority")
		}
		destination.CertificateAuthority = &certificateAuthority
	} else {
		destination.CertificateAuthority = nil
	}

	// Components
	if mesh.Components != nil {
		var component storage.IstioComponents_STATUS
		err := mesh.Components.AssignProperties_To_IstioComponents_STATUS(&component)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioComponents_STATUS() to populate field Components")
		}
		destination.Components = &component
	} else {
		destination.Components = nil
	}

	// Revisions
	destination.Revisions = genruntime.CloneSliceOfString(mesh.Revisions)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Encryption at rest of Kubernetes resource objects using service-managed keys. More information on this can be found
// under https://aka.ms/aks/kubernetesResourceObjectEncryption.
type KubernetesResourceObjectEncryptionProfile struct {
	// InfrastructureEncryption: Whether to enable encryption at rest of Kubernetes resource objects using service-managed
	// keys. More information on this can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption.
	InfrastructureEncryption *KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption `json:"infrastructureEncryption,omitempty"`
}

var _ genruntime.ARMTransformer = &KubernetesResourceObjectEncryptionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *KubernetesResourceObjectEncryptionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.KubernetesResourceObjectEncryptionProfile{}

	// Set property "InfrastructureEncryption":
	if profile.InfrastructureEncryption != nil {
		var temp string
		temp = string(*profile.InfrastructureEncryption)
		infrastructureEncryption := arm.KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption(temp)
		result.InfrastructureEncryption = &infrastructureEncryption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *KubernetesResourceObjectEncryptionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesResourceObjectEncryptionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *KubernetesResourceObjectEncryptionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesResourceObjectEncryptionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesResourceObjectEncryptionProfile, got %T", armInput)
	}

	// Set property "InfrastructureEncryption":
	if typedInput.InfrastructureEncryption != nil {
		var temp string
		temp = string(*typedInput.InfrastructureEncryption)
		infrastructureEncryption := KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption(temp)
		profile.InfrastructureEncryption = &infrastructureEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesResourceObjectEncryptionProfile populates our KubernetesResourceObjectEncryptionProfile from the provided source KubernetesResourceObjectEncryptionProfile
func (profile *KubernetesResourceObjectEncryptionProfile) AssignProperties_From_KubernetesResourceObjectEncryptionProfile(source *storage.KubernetesResourceObjectEncryptionProfile) error {

	// InfrastructureEncryption
	if source.InfrastructureEncryption != nil {
		infrastructureEncryption := *source.InfrastructureEncryption
		infrastructureEncryptionTemp := genruntime.ToEnum(infrastructureEncryption, kubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_Values)
		profile.InfrastructureEncryption = &infrastructureEncryptionTemp
	} else {
		profile.InfrastructureEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KubernetesResourceObjectEncryptionProfile populates the provided destination KubernetesResourceObjectEncryptionProfile from our KubernetesResourceObjectEncryptionProfile
func (profile *KubernetesResourceObjectEncryptionProfile) AssignProperties_To_KubernetesResourceObjectEncryptionProfile(destination *storage.KubernetesResourceObjectEncryptionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// InfrastructureEncryption
	if profile.InfrastructureEncryption != nil {
		infrastructureEncryption := string(*profile.InfrastructureEncryption)
		destination.InfrastructureEncryption = &infrastructureEncryption
	} else {
		destination.InfrastructureEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Encryption at rest of Kubernetes resource objects using service-managed keys. More information on this can be found
// under https://aka.ms/aks/kubernetesResourceObjectEncryption.
type KubernetesResourceObjectEncryptionProfile_STATUS struct {
	// InfrastructureEncryption: Whether to enable encryption at rest of Kubernetes resource objects using service-managed
	// keys. More information on this can be found under https://aka.ms/aks/kubernetesResourceObjectEncryption.
	InfrastructureEncryption *KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS `json:"infrastructureEncryption,omitempty"`
}

var _ genruntime.FromARMConverter = &KubernetesResourceObjectEncryptionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *KubernetesResourceObjectEncryptionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesResourceObjectEncryptionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *KubernetesResourceObjectEncryptionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesResourceObjectEncryptionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesResourceObjectEncryptionProfile_STATUS, got %T", armInput)
	}

	// Set property "InfrastructureEncryption":
	if typedInput.InfrastructureEncryption != nil {
		var temp string
		temp = string(*typedInput.InfrastructureEncryption)
		infrastructureEncryption := KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS(temp)
		profile.InfrastructureEncryption = &infrastructureEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesResourceObjectEncryptionProfile_STATUS populates our KubernetesResourceObjectEncryptionProfile_STATUS from the provided source KubernetesResourceObjectEncryptionProfile_STATUS
func (profile *KubernetesResourceObjectEncryptionProfile_STATUS) AssignProperties_From_KubernetesResourceObjectEncryptionProfile_STATUS(source *storage.KubernetesResourceObjectEncryptionProfile_STATUS) error {

	// InfrastructureEncryption
	if source.InfrastructureEncryption != nil {
		infrastructureEncryption := *source.InfrastructureEncryption
		infrastructureEncryptionTemp := genruntime.ToEnum(infrastructureEncryption, kubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Values)
		profile.InfrastructureEncryption = &infrastructureEncryptionTemp
	} else {
		profile.InfrastructureEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KubernetesResourceObjectEncryptionProfile_STATUS populates the provided destination KubernetesResourceObjectEncryptionProfile_STATUS from our KubernetesResourceObjectEncryptionProfile_STATUS
func (profile *KubernetesResourceObjectEncryptionProfile_STATUS) AssignProperties_To_KubernetesResourceObjectEncryptionProfile_STATUS(destination *storage.KubernetesResourceObjectEncryptionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// InfrastructureEncryption
	if profile.InfrastructureEncryption != nil {
		infrastructureEncryption := string(*profile.InfrastructureEncryption)
		destination.InfrastructureEncryption = &infrastructureEncryption
	} else {
		destination.InfrastructureEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The license type to use for Windows VMs. See [Azure Hybrid User
// Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
// +kubebuilder:validation:Enum={"None","Windows_Server"}
type LicenseType string

const (
	LicenseType_None           = LicenseType("None")
	LicenseType_Windows_Server = LicenseType("Windows_Server")
)

// Mapping from string to LicenseType
var licenseType_Values = map[string]LicenseType{
	"none":           LicenseType_None,
	"windows_server": LicenseType_Windows_Server,
}

// The license type to use for Windows VMs. See [Azure Hybrid User
// Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
type LicenseType_STATUS string

const (
	LicenseType_STATUS_None           = LicenseType_STATUS("None")
	LicenseType_STATUS_Windows_Server = LicenseType_STATUS("Windows_Server")
)

// Mapping from string to LicenseType_STATUS
var licenseType_STATUS_Values = map[string]LicenseType_STATUS{
	"none":           LicenseType_STATUS_None,
	"windows_server": LicenseType_STATUS_Windows_Server,
}

// The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer
// SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load
// balancer SKUs.
// +kubebuilder:validation:Enum={"basic","standard"}
type LoadBalancerSku string

const (
	LoadBalancerSku_Basic    = LoadBalancerSku("basic")
	LoadBalancerSku_Standard = LoadBalancerSku("standard")
)

// Mapping from string to LoadBalancerSku
var loadBalancerSku_Values = map[string]LoadBalancerSku{
	"basic":    LoadBalancerSku_Basic,
	"standard": LoadBalancerSku_Standard,
}

// The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer
// SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load
// balancer SKUs.
type LoadBalancerSku_STATUS string

const (
	LoadBalancerSku_STATUS_Basic    = LoadBalancerSku_STATUS("basic")
	LoadBalancerSku_STATUS_Standard = LoadBalancerSku_STATUS("standard")
)

// Mapping from string to LoadBalancerSku_STATUS
var loadBalancerSku_STATUS_Values = map[string]LoadBalancerSku_STATUS{
	"basic":    LoadBalancerSku_STATUS_Basic,
	"standard": LoadBalancerSku_STATUS_Standard,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ManagedClusterAgentPoolProfile_OsType string

const (
	ManagedClusterAgentPoolProfile_OsType_Linux   = ManagedClusterAgentPoolProfile_OsType("Linux")
	ManagedClusterAgentPoolProfile_OsType_Windows = ManagedClusterAgentPoolProfile_OsType("Windows")
)

// Mapping from string to ManagedClusterAgentPoolProfile_OsType
var managedClusterAgentPoolProfile_OsType_Values = map[string]ManagedClusterAgentPoolProfile_OsType{
	"linux":   ManagedClusterAgentPoolProfile_OsType_Linux,
	"windows": ManagedClusterAgentPoolProfile_OsType_Windows,
}

type ManagedClusterAgentPoolProfile_OsType_STATUS string

const (
	ManagedClusterAgentPoolProfile_OsType_STATUS_Linux   = ManagedClusterAgentPoolProfile_OsType_STATUS("Linux")
	ManagedClusterAgentPoolProfile_OsType_STATUS_Windows = ManagedClusterAgentPoolProfile_OsType_STATUS("Windows")
)

// Mapping from string to ManagedClusterAgentPoolProfile_OsType_STATUS
var managedClusterAgentPoolProfile_OsType_STATUS_Values = map[string]ManagedClusterAgentPoolProfile_OsType_STATUS{
	"linux":   ManagedClusterAgentPoolProfile_OsType_STATUS_Linux,
	"windows": ManagedClusterAgentPoolProfile_OsType_STATUS_Windows,
}

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy string

const (
	ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Deallocate = ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy("Deallocate")
	ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Delete     = ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy("Delete")
)

// Mapping from string to ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy
var managedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Values = map[string]ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy{
	"deallocate": ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Deallocate,
	"delete":     ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Delete,
}

type ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS string

const (
	ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Deallocate = ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS("Deallocate")
	ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Delete     = ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS("Delete")
)

// Mapping from string to ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS
var managedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Values = map[string]ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS{
	"deallocate": ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Deallocate,
	"delete":     ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_STATUS_Delete,
}

// +kubebuilder:validation:Enum={"Regular","Spot"}
type ManagedClusterAgentPoolProfile_ScaleSetPriority string

const (
	ManagedClusterAgentPoolProfile_ScaleSetPriority_Regular = ManagedClusterAgentPoolProfile_ScaleSetPriority("Regular")
	ManagedClusterAgentPoolProfile_ScaleSetPriority_Spot    = ManagedClusterAgentPoolProfile_ScaleSetPriority("Spot")
)

// Mapping from string to ManagedClusterAgentPoolProfile_ScaleSetPriority
var managedClusterAgentPoolProfile_ScaleSetPriority_Values = map[string]ManagedClusterAgentPoolProfile_ScaleSetPriority{
	"regular": ManagedClusterAgentPoolProfile_ScaleSetPriority_Regular,
	"spot":    ManagedClusterAgentPoolProfile_ScaleSetPriority_Spot,
}

type ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS string

const (
	ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Regular = ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS("Regular")
	ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Spot    = ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS("Spot")
)

// Mapping from string to ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS
var managedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Values = map[string]ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS{
	"regular": ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Regular,
	"spot":    ManagedClusterAgentPoolProfile_ScaleSetPriority_STATUS_Spot,
}

// Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics and traces
// through auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoring struct {
	// AutoInstrumentation: Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook
	// to auto-instrument Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the
	// application. See aka.ms/AzureMonitorApplicationMonitoring for an overview.
	AutoInstrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation `json:"autoInstrumentation,omitempty"`

	// OpenTelemetryLogs: Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and
	// Traces. Collects OpenTelemetry logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	OpenTelemetryLogs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs `json:"openTelemetryLogs,omitempty"`

	// OpenTelemetryMetrics: Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container
	// Metrics. Collects OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	OpenTelemetryMetrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics `json:"openTelemetryMetrics,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileAppMonitoring{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if monitoring == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileAppMonitoring{}

	// Set property "AutoInstrumentation":
	if monitoring.AutoInstrumentation != nil {
		autoInstrumentation_ARM, err := monitoring.AutoInstrumentation.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoInstrumentation := *autoInstrumentation_ARM.(*arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation)
		result.AutoInstrumentation = &autoInstrumentation
	}

	// Set property "OpenTelemetryLogs":
	if monitoring.OpenTelemetryLogs != nil {
		openTelemetryLogs_ARM, err := monitoring.OpenTelemetryLogs.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		openTelemetryLogs := *openTelemetryLogs_ARM.(*arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs)
		result.OpenTelemetryLogs = &openTelemetryLogs
	}

	// Set property "OpenTelemetryMetrics":
	if monitoring.OpenTelemetryMetrics != nil {
		openTelemetryMetrics_ARM, err := monitoring.OpenTelemetryMetrics.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		openTelemetryMetrics := *openTelemetryMetrics_ARM.(*arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics)
		result.OpenTelemetryMetrics = &openTelemetryMetrics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoring{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoring)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoring, got %T", armInput)
	}

	// Set property "AutoInstrumentation":
	if typedInput.AutoInstrumentation != nil {
		var autoInstrumentation1 ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation
		err := autoInstrumentation1.PopulateFromARM(owner, *typedInput.AutoInstrumentation)
		if err != nil {
			return err
		}
		autoInstrumentation := autoInstrumentation1
		monitoring.AutoInstrumentation = &autoInstrumentation
	}

	// Set property "OpenTelemetryLogs":
	if typedInput.OpenTelemetryLogs != nil {
		var openTelemetryLogs1 ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs
		err := openTelemetryLogs1.PopulateFromARM(owner, *typedInput.OpenTelemetryLogs)
		if err != nil {
			return err
		}
		openTelemetryLogs := openTelemetryLogs1
		monitoring.OpenTelemetryLogs = &openTelemetryLogs
	}

	// Set property "OpenTelemetryMetrics":
	if typedInput.OpenTelemetryMetrics != nil {
		var openTelemetryMetrics1 ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics
		err := openTelemetryMetrics1.PopulateFromARM(owner, *typedInput.OpenTelemetryMetrics)
		if err != nil {
			return err
		}
		openTelemetryMetrics := openTelemetryMetrics1
		monitoring.OpenTelemetryMetrics = &openTelemetryMetrics
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring populates our ManagedClusterAzureMonitorProfileAppMonitoring from the provided source ManagedClusterAzureMonitorProfileAppMonitoring
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring(source *storage.ManagedClusterAzureMonitorProfileAppMonitoring) error {

	// AutoInstrumentation
	if source.AutoInstrumentation != nil {
		var autoInstrumentation ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation
		err := autoInstrumentation.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation(source.AutoInstrumentation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation() to populate field AutoInstrumentation")
		}
		monitoring.AutoInstrumentation = &autoInstrumentation
	} else {
		monitoring.AutoInstrumentation = nil
	}

	// OpenTelemetryLogs
	if source.OpenTelemetryLogs != nil {
		var openTelemetryLog ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs
		err := openTelemetryLog.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs(source.OpenTelemetryLogs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs() to populate field OpenTelemetryLogs")
		}
		monitoring.OpenTelemetryLogs = &openTelemetryLog
	} else {
		monitoring.OpenTelemetryLogs = nil
	}

	// OpenTelemetryMetrics
	if source.OpenTelemetryMetrics != nil {
		var openTelemetryMetric ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics
		err := openTelemetryMetric.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics(source.OpenTelemetryMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics() to populate field OpenTelemetryMetrics")
		}
		monitoring.OpenTelemetryMetrics = &openTelemetryMetric
	} else {
		monitoring.OpenTelemetryMetrics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoring from our ManagedClusterAzureMonitorProfileAppMonitoring
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoring) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoInstrumentation
	if monitoring.AutoInstrumentation != nil {
		var autoInstrumentation storage.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation
		err := monitoring.AutoInstrumentation.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation(&autoInstrumentation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation() to populate field AutoInstrumentation")
		}
		destination.AutoInstrumentation = &autoInstrumentation
	} else {
		destination.AutoInstrumentation = nil
	}

	// OpenTelemetryLogs
	if monitoring.OpenTelemetryLogs != nil {
		var openTelemetryLog storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs
		err := monitoring.OpenTelemetryLogs.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs(&openTelemetryLog)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs() to populate field OpenTelemetryLogs")
		}
		destination.OpenTelemetryLogs = &openTelemetryLog
	} else {
		destination.OpenTelemetryLogs = nil
	}

	// OpenTelemetryMetrics
	if monitoring.OpenTelemetryMetrics != nil {
		var openTelemetryMetric storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics
		err := monitoring.OpenTelemetryMetrics.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics(&openTelemetryMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics() to populate field OpenTelemetryMetrics")
		}
		destination.OpenTelemetryMetrics = &openTelemetryMetric
	} else {
		destination.OpenTelemetryMetrics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics and traces
// through auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoring_STATUS struct {
	// AutoInstrumentation: Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook
	// to auto-instrument Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the
	// application. See aka.ms/AzureMonitorApplicationMonitoring for an overview.
	AutoInstrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS `json:"autoInstrumentation,omitempty"`

	// OpenTelemetryLogs: Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and
	// Traces. Collects OpenTelemetry logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	OpenTelemetryLogs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS `json:"openTelemetryLogs,omitempty"`

	// OpenTelemetryMetrics: Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container
	// Metrics. Collects OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry based SDKs. See
	// aka.ms/AzureMonitorApplicationMonitoring for an overview.
	OpenTelemetryMetrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS `json:"openTelemetryMetrics,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileAppMonitoring_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoring_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoring_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoring_STATUS, got %T", armInput)
	}

	// Set property "AutoInstrumentation":
	if typedInput.AutoInstrumentation != nil {
		var autoInstrumentation1 ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS
		err := autoInstrumentation1.PopulateFromARM(owner, *typedInput.AutoInstrumentation)
		if err != nil {
			return err
		}
		autoInstrumentation := autoInstrumentation1
		monitoring.AutoInstrumentation = &autoInstrumentation
	}

	// Set property "OpenTelemetryLogs":
	if typedInput.OpenTelemetryLogs != nil {
		var openTelemetryLogs1 ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS
		err := openTelemetryLogs1.PopulateFromARM(owner, *typedInput.OpenTelemetryLogs)
		if err != nil {
			return err
		}
		openTelemetryLogs := openTelemetryLogs1
		monitoring.OpenTelemetryLogs = &openTelemetryLogs
	}

	// Set property "OpenTelemetryMetrics":
	if typedInput.OpenTelemetryMetrics != nil {
		var openTelemetryMetrics1 ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS
		err := openTelemetryMetrics1.PopulateFromARM(owner, *typedInput.OpenTelemetryMetrics)
		if err != nil {
			return err
		}
		openTelemetryMetrics := openTelemetryMetrics1
		monitoring.OpenTelemetryMetrics = &openTelemetryMetrics
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS populates our ManagedClusterAzureMonitorProfileAppMonitoring_STATUS from the provided source ManagedClusterAzureMonitorProfileAppMonitoring_STATUS
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS(source *storage.ManagedClusterAzureMonitorProfileAppMonitoring_STATUS) error {

	// AutoInstrumentation
	if source.AutoInstrumentation != nil {
		var autoInstrumentation ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS
		err := autoInstrumentation.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS(source.AutoInstrumentation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS() to populate field AutoInstrumentation")
		}
		monitoring.AutoInstrumentation = &autoInstrumentation
	} else {
		monitoring.AutoInstrumentation = nil
	}

	// OpenTelemetryLogs
	if source.OpenTelemetryLogs != nil {
		var openTelemetryLog ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS
		err := openTelemetryLog.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS(source.OpenTelemetryLogs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS() to populate field OpenTelemetryLogs")
		}
		monitoring.OpenTelemetryLogs = &openTelemetryLog
	} else {
		monitoring.OpenTelemetryLogs = nil
	}

	// OpenTelemetryMetrics
	if source.OpenTelemetryMetrics != nil {
		var openTelemetryMetric ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS
		err := openTelemetryMetric.AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS(source.OpenTelemetryMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS() to populate field OpenTelemetryMetrics")
		}
		monitoring.OpenTelemetryMetrics = &openTelemetryMetric
	} else {
		monitoring.OpenTelemetryMetrics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoring_STATUS from our ManagedClusterAzureMonitorProfileAppMonitoring_STATUS
func (monitoring *ManagedClusterAzureMonitorProfileAppMonitoring_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoring_STATUS(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoring_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoInstrumentation
	if monitoring.AutoInstrumentation != nil {
		var autoInstrumentation storage.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS
		err := monitoring.AutoInstrumentation.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS(&autoInstrumentation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS() to populate field AutoInstrumentation")
		}
		destination.AutoInstrumentation = &autoInstrumentation
	} else {
		destination.AutoInstrumentation = nil
	}

	// OpenTelemetryLogs
	if monitoring.OpenTelemetryLogs != nil {
		var openTelemetryLog storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS
		err := monitoring.OpenTelemetryLogs.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS(&openTelemetryLog)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS() to populate field OpenTelemetryLogs")
		}
		destination.OpenTelemetryLogs = &openTelemetryLog
	} else {
		destination.OpenTelemetryLogs = nil
	}

	// OpenTelemetryMetrics
	if monitoring.OpenTelemetryMetrics != nil {
		var openTelemetryMetric storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS
		err := monitoring.OpenTelemetryMetrics.AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS(&openTelemetryMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS() to populate field OpenTelemetryMetrics")
		}
		destination.OpenTelemetryMetrics = &openTelemetryMetric
	} else {
		destination.OpenTelemetryMetrics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout & stderr logs etc. See
// aka.ms/AzureMonitorContainerInsights for an overview.
type ManagedClusterAzureMonitorProfileContainerInsights struct {
	// DisableCustomMetrics: Indicates whether custom metrics collection has to be disabled or not. If not specified the
	// default is false. No custom metrics will be emitted if this field is false but the container insights enabled field is
	// false
	DisableCustomMetrics *bool `json:"disableCustomMetrics,omitempty"`

	// DisablePrometheusMetricsScraping: Indicates whether prometheus metrics scraping is disabled or not. If not specified the
	// default is false. No prometheus metrics will be emitted if this field is false but the container insights enabled field
	// is false
	DisablePrometheusMetricsScraping *bool `json:"disablePrometheusMetricsScraping,omitempty"`

	// Enabled: Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// LogAnalyticsWorkspaceResourceReference: Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing
	// Azure Monitor Container Insights Logs.
	LogAnalyticsWorkspaceResourceReference *genruntime.ResourceReference `armReference:"LogAnalyticsWorkspaceResourceId" json:"logAnalyticsWorkspaceResourceReference,omitempty"`

	// SyslogPort: The syslog host port. If not specified, the default port is 28330.
	SyslogPort *int `json:"syslogPort,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileContainerInsights{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (insights *ManagedClusterAzureMonitorProfileContainerInsights) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if insights == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileContainerInsights{}

	// Set property "DisableCustomMetrics":
	if insights.DisableCustomMetrics != nil {
		disableCustomMetrics := *insights.DisableCustomMetrics
		result.DisableCustomMetrics = &disableCustomMetrics
	}

	// Set property "DisablePrometheusMetricsScraping":
	if insights.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *insights.DisablePrometheusMetricsScraping
		result.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	}

	// Set property "Enabled":
	if insights.Enabled != nil {
		enabled := *insights.Enabled
		result.Enabled = &enabled
	}

	// Set property "LogAnalyticsWorkspaceResourceId":
	if insights.LogAnalyticsWorkspaceResourceReference != nil {
		logAnalyticsWorkspaceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*insights.LogAnalyticsWorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		logAnalyticsWorkspaceResourceReference := logAnalyticsWorkspaceResourceReferenceARMID
		result.LogAnalyticsWorkspaceResourceId = &logAnalyticsWorkspaceResourceReference
	}

	// Set property "SyslogPort":
	if insights.SyslogPort != nil {
		syslogPort := *insights.SyslogPort
		result.SyslogPort = &syslogPort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insights *ManagedClusterAzureMonitorProfileContainerInsights) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileContainerInsights{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insights *ManagedClusterAzureMonitorProfileContainerInsights) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileContainerInsights)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileContainerInsights, got %T", armInput)
	}

	// Set property "DisableCustomMetrics":
	if typedInput.DisableCustomMetrics != nil {
		disableCustomMetrics := *typedInput.DisableCustomMetrics
		insights.DisableCustomMetrics = &disableCustomMetrics
	}

	// Set property "DisablePrometheusMetricsScraping":
	if typedInput.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *typedInput.DisablePrometheusMetricsScraping
		insights.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		insights.Enabled = &enabled
	}

	// no assignment for property "LogAnalyticsWorkspaceResourceReference"

	// Set property "SyslogPort":
	if typedInput.SyslogPort != nil {
		syslogPort := *typedInput.SyslogPort
		insights.SyslogPort = &syslogPort
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights populates our ManagedClusterAzureMonitorProfileContainerInsights from the provided source ManagedClusterAzureMonitorProfileContainerInsights
func (insights *ManagedClusterAzureMonitorProfileContainerInsights) AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights(source *storage.ManagedClusterAzureMonitorProfileContainerInsights) error {

	// DisableCustomMetrics
	if source.DisableCustomMetrics != nil {
		disableCustomMetric := *source.DisableCustomMetrics
		insights.DisableCustomMetrics = &disableCustomMetric
	} else {
		insights.DisableCustomMetrics = nil
	}

	// DisablePrometheusMetricsScraping
	if source.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *source.DisablePrometheusMetricsScraping
		insights.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	} else {
		insights.DisablePrometheusMetricsScraping = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		insights.Enabled = &enabled
	} else {
		insights.Enabled = nil
	}

	// LogAnalyticsWorkspaceResourceReference
	if source.LogAnalyticsWorkspaceResourceReference != nil {
		logAnalyticsWorkspaceResourceReference := source.LogAnalyticsWorkspaceResourceReference.Copy()
		insights.LogAnalyticsWorkspaceResourceReference = &logAnalyticsWorkspaceResourceReference
	} else {
		insights.LogAnalyticsWorkspaceResourceReference = nil
	}

	// SyslogPort
	insights.SyslogPort = genruntime.ClonePointerToInt(source.SyslogPort)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights populates the provided destination ManagedClusterAzureMonitorProfileContainerInsights from our ManagedClusterAzureMonitorProfileContainerInsights
func (insights *ManagedClusterAzureMonitorProfileContainerInsights) AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights(destination *storage.ManagedClusterAzureMonitorProfileContainerInsights) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableCustomMetrics
	if insights.DisableCustomMetrics != nil {
		disableCustomMetric := *insights.DisableCustomMetrics
		destination.DisableCustomMetrics = &disableCustomMetric
	} else {
		destination.DisableCustomMetrics = nil
	}

	// DisablePrometheusMetricsScraping
	if insights.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *insights.DisablePrometheusMetricsScraping
		destination.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	} else {
		destination.DisablePrometheusMetricsScraping = nil
	}

	// Enabled
	if insights.Enabled != nil {
		enabled := *insights.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// LogAnalyticsWorkspaceResourceReference
	if insights.LogAnalyticsWorkspaceResourceReference != nil {
		logAnalyticsWorkspaceResourceReference := insights.LogAnalyticsWorkspaceResourceReference.Copy()
		destination.LogAnalyticsWorkspaceResourceReference = &logAnalyticsWorkspaceResourceReference
	} else {
		destination.LogAnalyticsWorkspaceResourceReference = nil
	}

	// SyslogPort
	destination.SyslogPort = genruntime.ClonePointerToInt(insights.SyslogPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout & stderr logs etc. See
// aka.ms/AzureMonitorContainerInsights for an overview.
type ManagedClusterAzureMonitorProfileContainerInsights_STATUS struct {
	// DisableCustomMetrics: Indicates whether custom metrics collection has to be disabled or not. If not specified the
	// default is false. No custom metrics will be emitted if this field is false but the container insights enabled field is
	// false
	DisableCustomMetrics *bool `json:"disableCustomMetrics,omitempty"`

	// DisablePrometheusMetricsScraping: Indicates whether prometheus metrics scraping is disabled or not. If not specified the
	// default is false. No prometheus metrics will be emitted if this field is false but the container insights enabled field
	// is false
	DisablePrometheusMetricsScraping *bool `json:"disablePrometheusMetricsScraping,omitempty"`

	// Enabled: Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// LogAnalyticsWorkspaceResourceId: Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure
	// Monitor Container Insights Logs.
	LogAnalyticsWorkspaceResourceId *string `json:"logAnalyticsWorkspaceResourceId,omitempty"`

	// SyslogPort: The syslog host port. If not specified, the default port is 28330.
	SyslogPort *int `json:"syslogPort,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileContainerInsights_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insights *ManagedClusterAzureMonitorProfileContainerInsights_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileContainerInsights_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insights *ManagedClusterAzureMonitorProfileContainerInsights_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileContainerInsights_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileContainerInsights_STATUS, got %T", armInput)
	}

	// Set property "DisableCustomMetrics":
	if typedInput.DisableCustomMetrics != nil {
		disableCustomMetrics := *typedInput.DisableCustomMetrics
		insights.DisableCustomMetrics = &disableCustomMetrics
	}

	// Set property "DisablePrometheusMetricsScraping":
	if typedInput.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *typedInput.DisablePrometheusMetricsScraping
		insights.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		insights.Enabled = &enabled
	}

	// Set property "LogAnalyticsWorkspaceResourceId":
	if typedInput.LogAnalyticsWorkspaceResourceId != nil {
		logAnalyticsWorkspaceResourceId := *typedInput.LogAnalyticsWorkspaceResourceId
		insights.LogAnalyticsWorkspaceResourceId = &logAnalyticsWorkspaceResourceId
	}

	// Set property "SyslogPort":
	if typedInput.SyslogPort != nil {
		syslogPort := *typedInput.SyslogPort
		insights.SyslogPort = &syslogPort
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights_STATUS populates our ManagedClusterAzureMonitorProfileContainerInsights_STATUS from the provided source ManagedClusterAzureMonitorProfileContainerInsights_STATUS
func (insights *ManagedClusterAzureMonitorProfileContainerInsights_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileContainerInsights_STATUS(source *storage.ManagedClusterAzureMonitorProfileContainerInsights_STATUS) error {

	// DisableCustomMetrics
	if source.DisableCustomMetrics != nil {
		disableCustomMetric := *source.DisableCustomMetrics
		insights.DisableCustomMetrics = &disableCustomMetric
	} else {
		insights.DisableCustomMetrics = nil
	}

	// DisablePrometheusMetricsScraping
	if source.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *source.DisablePrometheusMetricsScraping
		insights.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	} else {
		insights.DisablePrometheusMetricsScraping = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		insights.Enabled = &enabled
	} else {
		insights.Enabled = nil
	}

	// LogAnalyticsWorkspaceResourceId
	insights.LogAnalyticsWorkspaceResourceId = genruntime.ClonePointerToString(source.LogAnalyticsWorkspaceResourceId)

	// SyslogPort
	insights.SyslogPort = genruntime.ClonePointerToInt(source.SyslogPort)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights_STATUS populates the provided destination ManagedClusterAzureMonitorProfileContainerInsights_STATUS from our ManagedClusterAzureMonitorProfileContainerInsights_STATUS
func (insights *ManagedClusterAzureMonitorProfileContainerInsights_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileContainerInsights_STATUS(destination *storage.ManagedClusterAzureMonitorProfileContainerInsights_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableCustomMetrics
	if insights.DisableCustomMetrics != nil {
		disableCustomMetric := *insights.DisableCustomMetrics
		destination.DisableCustomMetrics = &disableCustomMetric
	} else {
		destination.DisableCustomMetrics = nil
	}

	// DisablePrometheusMetricsScraping
	if insights.DisablePrometheusMetricsScraping != nil {
		disablePrometheusMetricsScraping := *insights.DisablePrometheusMetricsScraping
		destination.DisablePrometheusMetricsScraping = &disablePrometheusMetricsScraping
	} else {
		destination.DisablePrometheusMetricsScraping = nil
	}

	// Enabled
	if insights.Enabled != nil {
		enabled := *insights.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// LogAnalyticsWorkspaceResourceId
	destination.LogAnalyticsWorkspaceResourceId = genruntime.ClonePointerToString(insights.LogAnalyticsWorkspaceResourceId)

	// SyslogPort
	destination.SyslogPort = genruntime.ClonePointerToInt(insights.SyslogPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes
// infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See
// aka.ms/AzureManagedPrometheus for an overview.
type ManagedClusterAzureMonitorProfileMetrics struct {
	// +kubebuilder:validation:Required
	// Enabled: Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See
	// aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.
	Enabled *bool `json:"enabled,omitempty"`

	// KubeStateMetrics: Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the
	// kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for
	// details.
	KubeStateMetrics *ManagedClusterAzureMonitorProfileKubeStateMetrics `json:"kubeStateMetrics,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileMetrics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (metrics *ManagedClusterAzureMonitorProfileMetrics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if metrics == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileMetrics{}

	// Set property "Enabled":
	if metrics.Enabled != nil {
		enabled := *metrics.Enabled
		result.Enabled = &enabled
	}

	// Set property "KubeStateMetrics":
	if metrics.KubeStateMetrics != nil {
		kubeStateMetrics_ARM, err := metrics.KubeStateMetrics.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubeStateMetrics := *kubeStateMetrics_ARM.(*arm.ManagedClusterAzureMonitorProfileKubeStateMetrics)
		result.KubeStateMetrics = &kubeStateMetrics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metrics *ManagedClusterAzureMonitorProfileMetrics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileMetrics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metrics *ManagedClusterAzureMonitorProfileMetrics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileMetrics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileMetrics, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		metrics.Enabled = &enabled
	}

	// Set property "KubeStateMetrics":
	if typedInput.KubeStateMetrics != nil {
		var kubeStateMetrics1 ManagedClusterAzureMonitorProfileKubeStateMetrics
		err := kubeStateMetrics1.PopulateFromARM(owner, *typedInput.KubeStateMetrics)
		if err != nil {
			return err
		}
		kubeStateMetrics := kubeStateMetrics1
		metrics.KubeStateMetrics = &kubeStateMetrics
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics populates our ManagedClusterAzureMonitorProfileMetrics from the provided source ManagedClusterAzureMonitorProfileMetrics
func (metrics *ManagedClusterAzureMonitorProfileMetrics) AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics(source *storage.ManagedClusterAzureMonitorProfileMetrics) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		metrics.Enabled = &enabled
	} else {
		metrics.Enabled = nil
	}

	// KubeStateMetrics
	if source.KubeStateMetrics != nil {
		var kubeStateMetric ManagedClusterAzureMonitorProfileKubeStateMetrics
		err := kubeStateMetric.AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics(source.KubeStateMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics() to populate field KubeStateMetrics")
		}
		metrics.KubeStateMetrics = &kubeStateMetric
	} else {
		metrics.KubeStateMetrics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics populates the provided destination ManagedClusterAzureMonitorProfileMetrics from our ManagedClusterAzureMonitorProfileMetrics
func (metrics *ManagedClusterAzureMonitorProfileMetrics) AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics(destination *storage.ManagedClusterAzureMonitorProfileMetrics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if metrics.Enabled != nil {
		enabled := *metrics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KubeStateMetrics
	if metrics.KubeStateMetrics != nil {
		var kubeStateMetric storage.ManagedClusterAzureMonitorProfileKubeStateMetrics
		err := metrics.KubeStateMetrics.AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics(&kubeStateMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics() to populate field KubeStateMetrics")
		}
		destination.KubeStateMetrics = &kubeStateMetric
	} else {
		destination.KubeStateMetrics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes
// infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See
// aka.ms/AzureManagedPrometheus for an overview.
type ManagedClusterAzureMonitorProfileMetrics_STATUS struct {
	// Enabled: Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See
	// aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.
	Enabled *bool `json:"enabled,omitempty"`

	// KubeStateMetrics: Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the
	// kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for
	// details.
	KubeStateMetrics *ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS `json:"kubeStateMetrics,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileMetrics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metrics *ManagedClusterAzureMonitorProfileMetrics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileMetrics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metrics *ManagedClusterAzureMonitorProfileMetrics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileMetrics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileMetrics_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		metrics.Enabled = &enabled
	}

	// Set property "KubeStateMetrics":
	if typedInput.KubeStateMetrics != nil {
		var kubeStateMetrics1 ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS
		err := kubeStateMetrics1.PopulateFromARM(owner, *typedInput.KubeStateMetrics)
		if err != nil {
			return err
		}
		kubeStateMetrics := kubeStateMetrics1
		metrics.KubeStateMetrics = &kubeStateMetrics
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics_STATUS populates our ManagedClusterAzureMonitorProfileMetrics_STATUS from the provided source ManagedClusterAzureMonitorProfileMetrics_STATUS
func (metrics *ManagedClusterAzureMonitorProfileMetrics_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileMetrics_STATUS(source *storage.ManagedClusterAzureMonitorProfileMetrics_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		metrics.Enabled = &enabled
	} else {
		metrics.Enabled = nil
	}

	// KubeStateMetrics
	if source.KubeStateMetrics != nil {
		var kubeStateMetric ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS
		err := kubeStateMetric.AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS(source.KubeStateMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS() to populate field KubeStateMetrics")
		}
		metrics.KubeStateMetrics = &kubeStateMetric
	} else {
		metrics.KubeStateMetrics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics_STATUS populates the provided destination ManagedClusterAzureMonitorProfileMetrics_STATUS from our ManagedClusterAzureMonitorProfileMetrics_STATUS
func (metrics *ManagedClusterAzureMonitorProfileMetrics_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileMetrics_STATUS(destination *storage.ManagedClusterAzureMonitorProfileMetrics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if metrics.Enabled != nil {
		enabled := *metrics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KubeStateMetrics
	if metrics.KubeStateMetrics != nil {
		var kubeStateMetric storage.ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS
		err := metrics.KubeStateMetrics.AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS(&kubeStateMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS() to populate field KubeStateMetrics")
		}
		destination.KubeStateMetrics = &kubeStateMetric
	} else {
		destination.KubeStateMetrics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Cache","Direct"}
type ManagedClusterBootstrapProfile_ArtifactSource string

const (
	ManagedClusterBootstrapProfile_ArtifactSource_Cache  = ManagedClusterBootstrapProfile_ArtifactSource("Cache")
	ManagedClusterBootstrapProfile_ArtifactSource_Direct = ManagedClusterBootstrapProfile_ArtifactSource("Direct")
)

// Mapping from string to ManagedClusterBootstrapProfile_ArtifactSource
var managedClusterBootstrapProfile_ArtifactSource_Values = map[string]ManagedClusterBootstrapProfile_ArtifactSource{
	"cache":  ManagedClusterBootstrapProfile_ArtifactSource_Cache,
	"direct": ManagedClusterBootstrapProfile_ArtifactSource_Direct,
}

type ManagedClusterBootstrapProfile_ArtifactSource_STATUS string

const (
	ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Cache  = ManagedClusterBootstrapProfile_ArtifactSource_STATUS("Cache")
	ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Direct = ManagedClusterBootstrapProfile_ArtifactSource_STATUS("Direct")
)

// Mapping from string to ManagedClusterBootstrapProfile_ArtifactSource_STATUS
var managedClusterBootstrapProfile_ArtifactSource_STATUS_Values = map[string]ManagedClusterBootstrapProfile_ArtifactSource_STATUS{
	"cache":  ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Cache,
	"direct": ManagedClusterBootstrapProfile_ArtifactSource_STATUS_Direct,
}

// The cost analysis configuration for the cluster
type ManagedClusterCostAnalysis struct {
	// Enabled: Whether to enable cost analysis. The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable
	// this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure
	// portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterCostAnalysis{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analysis *ManagedClusterCostAnalysis) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analysis == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterCostAnalysis{}

	// Set property "Enabled":
	if analysis.Enabled != nil {
		enabled := *analysis.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analysis *ManagedClusterCostAnalysis) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterCostAnalysis{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analysis *ManagedClusterCostAnalysis) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterCostAnalysis)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterCostAnalysis, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		analysis.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterCostAnalysis populates our ManagedClusterCostAnalysis from the provided source ManagedClusterCostAnalysis
func (analysis *ManagedClusterCostAnalysis) AssignProperties_From_ManagedClusterCostAnalysis(source *storage.ManagedClusterCostAnalysis) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		analysis.Enabled = &enabled
	} else {
		analysis.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterCostAnalysis populates the provided destination ManagedClusterCostAnalysis from our ManagedClusterCostAnalysis
func (analysis *ManagedClusterCostAnalysis) AssignProperties_To_ManagedClusterCostAnalysis(destination *storage.ManagedClusterCostAnalysis) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if analysis.Enabled != nil {
		enabled := *analysis.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The cost analysis configuration for the cluster
type ManagedClusterCostAnalysis_STATUS struct {
	// Enabled: Whether to enable cost analysis. The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable
	// this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure
	// portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterCostAnalysis_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analysis *ManagedClusterCostAnalysis_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterCostAnalysis_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analysis *ManagedClusterCostAnalysis_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterCostAnalysis_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterCostAnalysis_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		analysis.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterCostAnalysis_STATUS populates our ManagedClusterCostAnalysis_STATUS from the provided source ManagedClusterCostAnalysis_STATUS
func (analysis *ManagedClusterCostAnalysis_STATUS) AssignProperties_From_ManagedClusterCostAnalysis_STATUS(source *storage.ManagedClusterCostAnalysis_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		analysis.Enabled = &enabled
	} else {
		analysis.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterCostAnalysis_STATUS populates the provided destination ManagedClusterCostAnalysis_STATUS from our ManagedClusterCostAnalysis_STATUS
func (analysis *ManagedClusterCostAnalysis_STATUS) AssignProperties_To_ManagedClusterCostAnalysis_STATUS(destination *storage.ManagedClusterCostAnalysis_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if analysis.Enabled != nil {
		enabled := *analysis.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Load Balancer settings for the ingress profile.
type ManagedClusterIngressProfileApplicationLoadBalancer struct {
	// Enabled: Whether to enable Application Load Balancer.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIngressProfileApplicationLoadBalancer{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if balancer == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIngressProfileApplicationLoadBalancer{}

	// Set property "Enabled":
	if balancer.Enabled != nil {
		enabled := *balancer.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileApplicationLoadBalancer{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileApplicationLoadBalancer)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileApplicationLoadBalancer, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		balancer.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer populates our ManagedClusterIngressProfileApplicationLoadBalancer from the provided source ManagedClusterIngressProfileApplicationLoadBalancer
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer) AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer(source *storage.ManagedClusterIngressProfileApplicationLoadBalancer) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		balancer.Enabled = &enabled
	} else {
		balancer.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer populates the provided destination ManagedClusterIngressProfileApplicationLoadBalancer from our ManagedClusterIngressProfileApplicationLoadBalancer
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer) AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer(destination *storage.ManagedClusterIngressProfileApplicationLoadBalancer) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if balancer.Enabled != nil {
		enabled := *balancer.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Load Balancer settings for the ingress profile.
type ManagedClusterIngressProfileApplicationLoadBalancer_STATUS struct {
	// Enabled: Whether to enable Application Load Balancer.
	Enabled *bool `json:"enabled,omitempty"`

	// Identity: Managed identity of the Application Load Balancer add-on. This is the identity that should be granted
	// permissions to manage the associated Application Gateway for Containers resource.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIngressProfileApplicationLoadBalancer_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileApplicationLoadBalancer_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileApplicationLoadBalancer_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileApplicationLoadBalancer_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		balancer.Enabled = &enabled
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 UserAssignedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		balancer.Identity = &identity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS populates our ManagedClusterIngressProfileApplicationLoadBalancer_STATUS from the provided source ManagedClusterIngressProfileApplicationLoadBalancer_STATUS
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer_STATUS) AssignProperties_From_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS(source *storage.ManagedClusterIngressProfileApplicationLoadBalancer_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		balancer.Enabled = &enabled
	} else {
		balancer.Enabled = nil
	}

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity_STATUS
		err := identity.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		balancer.Identity = &identity
	} else {
		balancer.Identity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS populates the provided destination ManagedClusterIngressProfileApplicationLoadBalancer_STATUS from our ManagedClusterIngressProfileApplicationLoadBalancer_STATUS
func (balancer *ManagedClusterIngressProfileApplicationLoadBalancer_STATUS) AssignProperties_To_ManagedClusterIngressProfileApplicationLoadBalancer_STATUS(destination *storage.ManagedClusterIngressProfileApplicationLoadBalancer_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if balancer.Enabled != nil {
		enabled := *balancer.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Identity
	if balancer.Identity != nil {
		var identity storage.UserAssignedIdentity_STATUS
		err := balancer.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIngressProfileGatewayConfiguration struct {
	// Installation: Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'. See
	// https://aka.ms/k8s-gateway-api for more details.
	Installation *ManagedGatewayType `json:"installation,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIngressProfileGatewayConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ManagedClusterIngressProfileGatewayConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIngressProfileGatewayConfiguration{}

	// Set property "Installation":
	if configuration.Installation != nil {
		var temp string
		temp = string(*configuration.Installation)
		installation := arm.ManagedGatewayType(temp)
		result.Installation = &installation
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ManagedClusterIngressProfileGatewayConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileGatewayConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ManagedClusterIngressProfileGatewayConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileGatewayConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileGatewayConfiguration, got %T", armInput)
	}

	// Set property "Installation":
	if typedInput.Installation != nil {
		var temp string
		temp = string(*typedInput.Installation)
		installation := ManagedGatewayType(temp)
		configuration.Installation = &installation
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration populates our ManagedClusterIngressProfileGatewayConfiguration from the provided source ManagedClusterIngressProfileGatewayConfiguration
func (configuration *ManagedClusterIngressProfileGatewayConfiguration) AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration(source *storage.ManagedClusterIngressProfileGatewayConfiguration) error {

	// Installation
	if source.Installation != nil {
		installation := *source.Installation
		installationTemp := genruntime.ToEnum(installation, managedGatewayType_Values)
		configuration.Installation = &installationTemp
	} else {
		configuration.Installation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration populates the provided destination ManagedClusterIngressProfileGatewayConfiguration from our ManagedClusterIngressProfileGatewayConfiguration
func (configuration *ManagedClusterIngressProfileGatewayConfiguration) AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration(destination *storage.ManagedClusterIngressProfileGatewayConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Installation
	if configuration.Installation != nil {
		installation := string(*configuration.Installation)
		destination.Installation = &installation
	} else {
		destination.Installation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIngressProfileGatewayConfiguration_STATUS struct {
	// Installation: Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'. See
	// https://aka.ms/k8s-gateway-api for more details.
	Installation *ManagedGatewayType_STATUS `json:"installation,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIngressProfileGatewayConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ManagedClusterIngressProfileGatewayConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileGatewayConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ManagedClusterIngressProfileGatewayConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileGatewayConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileGatewayConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Installation":
	if typedInput.Installation != nil {
		var temp string
		temp = string(*typedInput.Installation)
		installation := ManagedGatewayType_STATUS(temp)
		configuration.Installation = &installation
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration_STATUS populates our ManagedClusterIngressProfileGatewayConfiguration_STATUS from the provided source ManagedClusterIngressProfileGatewayConfiguration_STATUS
func (configuration *ManagedClusterIngressProfileGatewayConfiguration_STATUS) AssignProperties_From_ManagedClusterIngressProfileGatewayConfiguration_STATUS(source *storage.ManagedClusterIngressProfileGatewayConfiguration_STATUS) error {

	// Installation
	if source.Installation != nil {
		installation := *source.Installation
		installationTemp := genruntime.ToEnum(installation, managedGatewayType_STATUS_Values)
		configuration.Installation = &installationTemp
	} else {
		configuration.Installation = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration_STATUS populates the provided destination ManagedClusterIngressProfileGatewayConfiguration_STATUS from our ManagedClusterIngressProfileGatewayConfiguration_STATUS
func (configuration *ManagedClusterIngressProfileGatewayConfiguration_STATUS) AssignProperties_To_ManagedClusterIngressProfileGatewayConfiguration_STATUS(destination *storage.ManagedClusterIngressProfileGatewayConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Installation
	if configuration.Installation != nil {
		installation := string(*configuration.Installation)
		destination.Installation = &installation
	} else {
		destination.Installation = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Routing add-on settings for the ingress profile.
type ManagedClusterIngressProfileWebAppRouting struct {
	// DefaultDomain: Configuration for the Default Domain. This is a unique, autogenerated domain that comes with a signed TLS
	// Certificate allowing for secure HTTPS. See [the Default Domain documentation](https://aka.ms/aks/defaultdomain) for more
	// instructions.
	DefaultDomain *ManagedClusterIngressDefaultDomainProfile `json:"defaultDomain,omitempty"`

	// DnsZoneResourceReferences: Resource IDs of the DNS zones to be associated with the Application Routing add-on. Used only
	// when Application Routing add-on is enabled. Public and private DNS zones can be in different resource groups, but all
	// public DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.
	DnsZoneResourceReferences []genruntime.ResourceReference `armReference:"DnsZoneResourceIds" json:"dnsZoneResourceReferences,omitempty"`

	// Enabled: Whether to enable the Application Routing add-on.
	Enabled *bool `json:"enabled,omitempty"`

	// Nginx: Configuration for the default NginxIngressController. See more at
	// https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller.
	Nginx *ManagedClusterIngressProfileNginx `json:"nginx,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIngressProfileWebAppRouting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (routing *ManagedClusterIngressProfileWebAppRouting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if routing == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIngressProfileWebAppRouting{}

	// Set property "DefaultDomain":
	if routing.DefaultDomain != nil {
		defaultDomain_ARM, err := routing.DefaultDomain.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultDomain := *defaultDomain_ARM.(*arm.ManagedClusterIngressDefaultDomainProfile)
		result.DefaultDomain = &defaultDomain
	}

	// Set property "DnsZoneResourceIds":
	for _, item := range routing.DnsZoneResourceReferences {
		itemARMID, err := resolved.ResolvedReferences.Lookup(item)
		if err != nil {
			return nil, err
		}
		result.DnsZoneResourceIds = append(result.DnsZoneResourceIds, itemARMID)
	}

	// Set property "Enabled":
	if routing.Enabled != nil {
		enabled := *routing.Enabled
		result.Enabled = &enabled
	}

	// Set property "Nginx":
	if routing.Nginx != nil {
		nginx_ARM, err := routing.Nginx.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nginx := *nginx_ARM.(*arm.ManagedClusterIngressProfileNginx)
		result.Nginx = &nginx
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routing *ManagedClusterIngressProfileWebAppRouting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileWebAppRouting{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routing *ManagedClusterIngressProfileWebAppRouting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileWebAppRouting)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileWebAppRouting, got %T", armInput)
	}

	// Set property "DefaultDomain":
	if typedInput.DefaultDomain != nil {
		var defaultDomain1 ManagedClusterIngressDefaultDomainProfile
		err := defaultDomain1.PopulateFromARM(owner, *typedInput.DefaultDomain)
		if err != nil {
			return err
		}
		defaultDomain := defaultDomain1
		routing.DefaultDomain = &defaultDomain
	}

	// no assignment for property "DnsZoneResourceReferences"

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		routing.Enabled = &enabled
	}

	// Set property "Nginx":
	if typedInput.Nginx != nil {
		var nginx1 ManagedClusterIngressProfileNginx
		err := nginx1.PopulateFromARM(owner, *typedInput.Nginx)
		if err != nil {
			return err
		}
		nginx := nginx1
		routing.Nginx = &nginx
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileWebAppRouting populates our ManagedClusterIngressProfileWebAppRouting from the provided source ManagedClusterIngressProfileWebAppRouting
func (routing *ManagedClusterIngressProfileWebAppRouting) AssignProperties_From_ManagedClusterIngressProfileWebAppRouting(source *storage.ManagedClusterIngressProfileWebAppRouting) error {

	// DefaultDomain
	if source.DefaultDomain != nil {
		var defaultDomain ManagedClusterIngressDefaultDomainProfile
		err := defaultDomain.AssignProperties_From_ManagedClusterIngressDefaultDomainProfile(source.DefaultDomain)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressDefaultDomainProfile() to populate field DefaultDomain")
		}
		routing.DefaultDomain = &defaultDomain
	} else {
		routing.DefaultDomain = nil
	}

	// DnsZoneResourceReferences
	if source.DnsZoneResourceReferences != nil {
		dnsZoneResourceReferenceList := make([]genruntime.ResourceReference, len(source.DnsZoneResourceReferences))
		for dnsZoneResourceReferenceIndex, dnsZoneResourceReferenceItem := range source.DnsZoneResourceReferences {
			dnsZoneResourceReferenceList[dnsZoneResourceReferenceIndex] = dnsZoneResourceReferenceItem.Copy()
		}
		routing.DnsZoneResourceReferences = dnsZoneResourceReferenceList
	} else {
		routing.DnsZoneResourceReferences = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		routing.Enabled = &enabled
	} else {
		routing.Enabled = nil
	}

	// Nginx
	if source.Nginx != nil {
		var nginx ManagedClusterIngressProfileNginx
		err := nginx.AssignProperties_From_ManagedClusterIngressProfileNginx(source.Nginx)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileNginx() to populate field Nginx")
		}
		routing.Nginx = &nginx
	} else {
		routing.Nginx = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileWebAppRouting populates the provided destination ManagedClusterIngressProfileWebAppRouting from our ManagedClusterIngressProfileWebAppRouting
func (routing *ManagedClusterIngressProfileWebAppRouting) AssignProperties_To_ManagedClusterIngressProfileWebAppRouting(destination *storage.ManagedClusterIngressProfileWebAppRouting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultDomain
	if routing.DefaultDomain != nil {
		var defaultDomain storage.ManagedClusterIngressDefaultDomainProfile
		err := routing.DefaultDomain.AssignProperties_To_ManagedClusterIngressDefaultDomainProfile(&defaultDomain)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressDefaultDomainProfile() to populate field DefaultDomain")
		}
		destination.DefaultDomain = &defaultDomain
	} else {
		destination.DefaultDomain = nil
	}

	// DnsZoneResourceReferences
	if routing.DnsZoneResourceReferences != nil {
		dnsZoneResourceReferenceList := make([]genruntime.ResourceReference, len(routing.DnsZoneResourceReferences))
		for dnsZoneResourceReferenceIndex, dnsZoneResourceReferenceItem := range routing.DnsZoneResourceReferences {
			dnsZoneResourceReferenceList[dnsZoneResourceReferenceIndex] = dnsZoneResourceReferenceItem.Copy()
		}
		destination.DnsZoneResourceReferences = dnsZoneResourceReferenceList
	} else {
		destination.DnsZoneResourceReferences = nil
	}

	// Enabled
	if routing.Enabled != nil {
		enabled := *routing.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Nginx
	if routing.Nginx != nil {
		var nginx storage.ManagedClusterIngressProfileNginx
		err := routing.Nginx.AssignProperties_To_ManagedClusterIngressProfileNginx(&nginx)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileNginx() to populate field Nginx")
		}
		destination.Nginx = &nginx
	} else {
		destination.Nginx = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Routing add-on settings for the ingress profile.
type ManagedClusterIngressProfileWebAppRouting_STATUS struct {
	// DefaultDomain: Configuration for the Default Domain. This is a unique, autogenerated domain that comes with a signed TLS
	// Certificate allowing for secure HTTPS. See [the Default Domain documentation](https://aka.ms/aks/defaultdomain) for more
	// instructions.
	DefaultDomain *ManagedClusterIngressDefaultDomainProfile_STATUS `json:"defaultDomain,omitempty"`

	// DnsZoneResourceIds: Resource IDs of the DNS zones to be associated with the Application Routing add-on. Used only when
	// Application Routing add-on is enabled. Public and private DNS zones can be in different resource groups, but all public
	// DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.
	DnsZoneResourceIds []string `json:"dnsZoneResourceIds,omitempty"`

	// Enabled: Whether to enable the Application Routing add-on.
	Enabled *bool `json:"enabled,omitempty"`

	// Identity: Managed identity of the Application Routing add-on. This is the identity that should be granted permissions,
	// for example, to manage the associated Azure DNS resource and get certificates from Azure Key Vault. See [this overview
	// of the add-on](https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm) for more instructions.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`

	// Nginx: Configuration for the default NginxIngressController. See more at
	// https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller.
	Nginx *ManagedClusterIngressProfileNginx_STATUS `json:"nginx,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIngressProfileWebAppRouting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (routing *ManagedClusterIngressProfileWebAppRouting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileWebAppRouting_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (routing *ManagedClusterIngressProfileWebAppRouting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileWebAppRouting_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileWebAppRouting_STATUS, got %T", armInput)
	}

	// Set property "DefaultDomain":
	if typedInput.DefaultDomain != nil {
		var defaultDomain1 ManagedClusterIngressDefaultDomainProfile_STATUS
		err := defaultDomain1.PopulateFromARM(owner, *typedInput.DefaultDomain)
		if err != nil {
			return err
		}
		defaultDomain := defaultDomain1
		routing.DefaultDomain = &defaultDomain
	}

	// Set property "DnsZoneResourceIds":
	for _, item := range typedInput.DnsZoneResourceIds {
		routing.DnsZoneResourceIds = append(routing.DnsZoneResourceIds, item)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		routing.Enabled = &enabled
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 UserAssignedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		routing.Identity = &identity
	}

	// Set property "Nginx":
	if typedInput.Nginx != nil {
		var nginx1 ManagedClusterIngressProfileNginx_STATUS
		err := nginx1.PopulateFromARM(owner, *typedInput.Nginx)
		if err != nil {
			return err
		}
		nginx := nginx1
		routing.Nginx = &nginx
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileWebAppRouting_STATUS populates our ManagedClusterIngressProfileWebAppRouting_STATUS from the provided source ManagedClusterIngressProfileWebAppRouting_STATUS
func (routing *ManagedClusterIngressProfileWebAppRouting_STATUS) AssignProperties_From_ManagedClusterIngressProfileWebAppRouting_STATUS(source *storage.ManagedClusterIngressProfileWebAppRouting_STATUS) error {

	// DefaultDomain
	if source.DefaultDomain != nil {
		var defaultDomain ManagedClusterIngressDefaultDomainProfile_STATUS
		err := defaultDomain.AssignProperties_From_ManagedClusterIngressDefaultDomainProfile_STATUS(source.DefaultDomain)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressDefaultDomainProfile_STATUS() to populate field DefaultDomain")
		}
		routing.DefaultDomain = &defaultDomain
	} else {
		routing.DefaultDomain = nil
	}

	// DnsZoneResourceIds
	routing.DnsZoneResourceIds = genruntime.CloneSliceOfString(source.DnsZoneResourceIds)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		routing.Enabled = &enabled
	} else {
		routing.Enabled = nil
	}

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity_STATUS
		err := identity.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		routing.Identity = &identity
	} else {
		routing.Identity = nil
	}

	// Nginx
	if source.Nginx != nil {
		var nginx ManagedClusterIngressProfileNginx_STATUS
		err := nginx.AssignProperties_From_ManagedClusterIngressProfileNginx_STATUS(source.Nginx)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterIngressProfileNginx_STATUS() to populate field Nginx")
		}
		routing.Nginx = &nginx
	} else {
		routing.Nginx = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileWebAppRouting_STATUS populates the provided destination ManagedClusterIngressProfileWebAppRouting_STATUS from our ManagedClusterIngressProfileWebAppRouting_STATUS
func (routing *ManagedClusterIngressProfileWebAppRouting_STATUS) AssignProperties_To_ManagedClusterIngressProfileWebAppRouting_STATUS(destination *storage.ManagedClusterIngressProfileWebAppRouting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultDomain
	if routing.DefaultDomain != nil {
		var defaultDomain storage.ManagedClusterIngressDefaultDomainProfile_STATUS
		err := routing.DefaultDomain.AssignProperties_To_ManagedClusterIngressDefaultDomainProfile_STATUS(&defaultDomain)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressDefaultDomainProfile_STATUS() to populate field DefaultDomain")
		}
		destination.DefaultDomain = &defaultDomain
	} else {
		destination.DefaultDomain = nil
	}

	// DnsZoneResourceIds
	destination.DnsZoneResourceIds = genruntime.CloneSliceOfString(routing.DnsZoneResourceIds)

	// Enabled
	if routing.Enabled != nil {
		enabled := *routing.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Identity
	if routing.Identity != nil {
		var identity storage.UserAssignedIdentity_STATUS
		err := routing.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Nginx
	if routing.Nginx != nil {
		var nginx storage.ManagedClusterIngressProfileNginx_STATUS
		err := routing.Nginx.AssignProperties_To_ManagedClusterIngressProfileNginx_STATUS(&nginx)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterIngressProfileNginx_STATUS() to populate field Nginx")
		}
		destination.Nginx = &nginx
	} else {
		destination.Nginx = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of the managed cluster load balancer.
type ManagedClusterLoadBalancerProfile struct {
	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	// AllocatedOutboundPorts: The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000
	// (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	// BackendPoolType: The type of the managed inbound Load Balancer BackendPool.
	BackendPoolType *ManagedClusterLoadBalancerProfile_BackendPoolType `json:"backendPoolType,omitempty"`

	// ClusterServiceLoadBalancerHealthProbeMode: The health probing behavior for External Traffic Policy Cluster services.
	ClusterServiceLoadBalancerHealthProbeMode *ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode `json:"clusterServiceLoadBalancerHealthProbeMode,omitempty"`

	// EnableMultipleStandardLoadBalancers: Enable multiple standard load balancers per AKS cluster or not.
	EnableMultipleStandardLoadBalancers *bool `json:"enableMultipleStandardLoadBalancers,omitempty"`

	// +kubebuilder:validation:Maximum=120
	// +kubebuilder:validation:Minimum=4
	// IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
	// (inclusive). The default value is 30 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs `json:"managedOutboundIPs,omitempty"`

	// OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes `json:"outboundIPPrefixes,omitempty"`

	// OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs `json:"outboundIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterLoadBalancerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfile{}

	// Set property "AllocatedOutboundPorts":
	if profile.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *profile.AllocatedOutboundPorts
		result.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property "BackendPoolType":
	if profile.BackendPoolType != nil {
		var temp string
		temp = string(*profile.BackendPoolType)
		backendPoolType := arm.ManagedClusterLoadBalancerProfile_BackendPoolType(temp)
		result.BackendPoolType = &backendPoolType
	}

	// Set property "ClusterServiceLoadBalancerHealthProbeMode":
	if profile.ClusterServiceLoadBalancerHealthProbeMode != nil {
		var temp string
		temp = string(*profile.ClusterServiceLoadBalancerHealthProbeMode)
		clusterServiceLoadBalancerHealthProbeMode := arm.ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode(temp)
		result.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeMode
	}

	// Set property "EnableMultipleStandardLoadBalancers":
	if profile.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancers := *profile.EnableMultipleStandardLoadBalancers
		result.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancers
	}

	// Set property "IdleTimeoutInMinutes":
	if profile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *profile.IdleTimeoutInMinutes
		result.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPs":
	if profile.ManagedOutboundIPs != nil {
		managedOutboundIPs_ARM, err := profile.ManagedOutboundIPs.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedOutboundIPs := *managedOutboundIPs_ARM.(*arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs)
		result.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property "OutboundIPPrefixes":
	if profile.OutboundIPPrefixes != nil {
		outboundIPPrefixes_ARM, err := profile.OutboundIPPrefixes.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPPrefixes := *outboundIPPrefixes_ARM.(*arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes)
		result.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property "OutboundIPs":
	if profile.OutboundIPs != nil {
		outboundIPs_ARM, err := profile.OutboundIPs.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPs := *outboundIPs_ARM.(*arm.ManagedClusterLoadBalancerProfileOutboundIPs)
		result.OutboundIPs = &outboundIPs
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterLoadBalancerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterLoadBalancerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile, got %T", armInput)
	}

	// Set property "AllocatedOutboundPorts":
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property "BackendPoolType":
	if typedInput.BackendPoolType != nil {
		var temp string
		temp = string(*typedInput.BackendPoolType)
		backendPoolType := ManagedClusterLoadBalancerProfile_BackendPoolType(temp)
		profile.BackendPoolType = &backendPoolType
	}

	// Set property "ClusterServiceLoadBalancerHealthProbeMode":
	if typedInput.ClusterServiceLoadBalancerHealthProbeMode != nil {
		var temp string
		temp = string(*typedInput.ClusterServiceLoadBalancerHealthProbeMode)
		clusterServiceLoadBalancerHealthProbeMode := ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode(temp)
		profile.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeMode
	}

	// Set property "EnableMultipleStandardLoadBalancers":
	if typedInput.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancers := *typedInput.EnableMultipleStandardLoadBalancers
		profile.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancers
	}

	// Set property "IdleTimeoutInMinutes":
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPs":
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		profile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property "OutboundIPPrefixes":
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		profile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property "OutboundIPs":
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfileOutboundIPs
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		profile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile populates our ManagedClusterLoadBalancerProfile from the provided source ManagedClusterLoadBalancerProfile
func (profile *ManagedClusterLoadBalancerProfile) AssignProperties_From_ManagedClusterLoadBalancerProfile(source *storage.ManagedClusterLoadBalancerProfile) error {

	// AllocatedOutboundPorts
	profile.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendPoolType
	if source.BackendPoolType != nil {
		backendPoolType := *source.BackendPoolType
		backendPoolTypeTemp := genruntime.ToEnum(backendPoolType, managedClusterLoadBalancerProfile_BackendPoolType_Values)
		profile.BackendPoolType = &backendPoolTypeTemp
	} else {
		profile.BackendPoolType = nil
	}

	// ClusterServiceLoadBalancerHealthProbeMode
	if source.ClusterServiceLoadBalancerHealthProbeMode != nil {
		clusterServiceLoadBalancerHealthProbeMode := *source.ClusterServiceLoadBalancerHealthProbeMode
		clusterServiceLoadBalancerHealthProbeModeTemp := genruntime.ToEnum(clusterServiceLoadBalancerHealthProbeMode, managedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_Values)
		profile.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeModeTemp
	} else {
		profile.ClusterServiceLoadBalancerHealthProbeMode = nil
	}

	// EnableMultipleStandardLoadBalancers
	if source.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancer := *source.EnableMultipleStandardLoadBalancers
		profile.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancer
	} else {
		profile.EnableMultipleStandardLoadBalancers = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := managedOutboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs() to populate field ManagedOutboundIPs")
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := outboundIPPrefix.AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes() to populate field OutboundIPPrefixes")
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfileOutboundIPs
		err := outboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs(source.OutboundIPs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs() to populate field OutboundIPs")
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile populates the provided destination ManagedClusterLoadBalancerProfile from our ManagedClusterLoadBalancerProfile
func (profile *ManagedClusterLoadBalancerProfile) AssignProperties_To_ManagedClusterLoadBalancerProfile(destination *storage.ManagedClusterLoadBalancerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(profile.AllocatedOutboundPorts)

	// BackendPoolType
	if profile.BackendPoolType != nil {
		backendPoolType := string(*profile.BackendPoolType)
		destination.BackendPoolType = &backendPoolType
	} else {
		destination.BackendPoolType = nil
	}

	// ClusterServiceLoadBalancerHealthProbeMode
	if profile.ClusterServiceLoadBalancerHealthProbeMode != nil {
		clusterServiceLoadBalancerHealthProbeMode := string(*profile.ClusterServiceLoadBalancerHealthProbeMode)
		destination.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeMode
	} else {
		destination.ClusterServiceLoadBalancerHealthProbeMode = nil
	}

	// EnableMultipleStandardLoadBalancers
	if profile.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancer := *profile.EnableMultipleStandardLoadBalancers
		destination.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancer
	} else {
		destination.EnableMultipleStandardLoadBalancers = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
		var managedOutboundIP storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := profile.ManagedOutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs() to populate field ManagedOutboundIPs")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
		var outboundIPPrefix storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := profile.OutboundIPPrefixes.AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes() to populate field OutboundIPPrefixes")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
		var outboundIP storage.ManagedClusterLoadBalancerProfileOutboundIPs
		err := profile.OutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs(&outboundIP)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs() to populate field OutboundIPs")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of the managed cluster load balancer.
type ManagedClusterLoadBalancerProfile_STATUS struct {
	// AllocatedOutboundPorts: The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000
	// (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	// BackendPoolType: The type of the managed inbound Load Balancer BackendPool.
	BackendPoolType *ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS `json:"backendPoolType,omitempty"`

	// ClusterServiceLoadBalancerHealthProbeMode: The health probing behavior for External Traffic Policy Cluster services.
	ClusterServiceLoadBalancerHealthProbeMode *ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS `json:"clusterServiceLoadBalancerHealthProbeMode,omitempty"`

	// EffectiveOutboundIPs: The effective outbound IP resources of the cluster load balancer.
	EffectiveOutboundIPs []ResourceReference_STATUS `json:"effectiveOutboundIPs,omitempty"`

	// EnableMultipleStandardLoadBalancers: Enable multiple standard load balancers per AKS cluster or not.
	EnableMultipleStandardLoadBalancers *bool `json:"enableMultipleStandardLoadBalancers,omitempty"`

	// IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
	// (inclusive). The default value is 30 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS `json:"managedOutboundIPs,omitempty"`

	// OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS `json:"outboundIPPrefixes,omitempty"`

	// OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs_STATUS `json:"outboundIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterLoadBalancerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterLoadBalancerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfile_STATUS, got %T", armInput)
	}

	// Set property "AllocatedOutboundPorts":
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		profile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property "BackendPoolType":
	if typedInput.BackendPoolType != nil {
		var temp string
		temp = string(*typedInput.BackendPoolType)
		backendPoolType := ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS(temp)
		profile.BackendPoolType = &backendPoolType
	}

	// Set property "ClusterServiceLoadBalancerHealthProbeMode":
	if typedInput.ClusterServiceLoadBalancerHealthProbeMode != nil {
		var temp string
		temp = string(*typedInput.ClusterServiceLoadBalancerHealthProbeMode)
		clusterServiceLoadBalancerHealthProbeMode := ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS(temp)
		profile.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeMode
	}

	// Set property "EffectiveOutboundIPs":
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.EffectiveOutboundIPs = append(profile.EffectiveOutboundIPs, item1)
	}

	// Set property "EnableMultipleStandardLoadBalancers":
	if typedInput.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancers := *typedInput.EnableMultipleStandardLoadBalancers
		profile.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancers
	}

	// Set property "IdleTimeoutInMinutes":
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPs":
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		profile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property "OutboundIPPrefixes":
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		profile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property "OutboundIPs":
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfileOutboundIPs_STATUS
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		profile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS populates our ManagedClusterLoadBalancerProfile_STATUS from the provided source ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS(source *storage.ManagedClusterLoadBalancerProfile_STATUS) error {

	// AllocatedOutboundPorts
	profile.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// BackendPoolType
	if source.BackendPoolType != nil {
		backendPoolType := *source.BackendPoolType
		backendPoolTypeTemp := genruntime.ToEnum(backendPoolType, managedClusterLoadBalancerProfile_BackendPoolType_STATUS_Values)
		profile.BackendPoolType = &backendPoolTypeTemp
	} else {
		profile.BackendPoolType = nil
	}

	// ClusterServiceLoadBalancerHealthProbeMode
	if source.ClusterServiceLoadBalancerHealthProbeMode != nil {
		clusterServiceLoadBalancerHealthProbeMode := *source.ClusterServiceLoadBalancerHealthProbeMode
		clusterServiceLoadBalancerHealthProbeModeTemp := genruntime.ToEnum(clusterServiceLoadBalancerHealthProbeMode, managedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Values)
		profile.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeModeTemp
	} else {
		profile.ClusterServiceLoadBalancerHealthProbeMode = nil
	}

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference_STATUS, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			var effectiveOutboundIP ResourceReference_STATUS
			err := effectiveOutboundIP.AssignProperties_From_ResourceReference_STATUS(&effectiveOutboundIPItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// EnableMultipleStandardLoadBalancers
	if source.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancer := *source.EnableMultipleStandardLoadBalancers
		profile.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancer
	} else {
		profile.EnableMultipleStandardLoadBalancers = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS
		err := managedOutboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS(source.ManagedOutboundIPs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS() to populate field ManagedOutboundIPs")
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS
		err := outboundIPPrefix.AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS(source.OutboundIPPrefixes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS() to populate field OutboundIPPrefixes")
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfileOutboundIPs_STATUS
		err := outboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS(source.OutboundIPs)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS() to populate field OutboundIPs")
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_STATUS from our ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS(destination *storage.ManagedClusterLoadBalancerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(profile.AllocatedOutboundPorts)

	// BackendPoolType
	if profile.BackendPoolType != nil {
		backendPoolType := string(*profile.BackendPoolType)
		destination.BackendPoolType = &backendPoolType
	} else {
		destination.BackendPoolType = nil
	}

	// ClusterServiceLoadBalancerHealthProbeMode
	if profile.ClusterServiceLoadBalancerHealthProbeMode != nil {
		clusterServiceLoadBalancerHealthProbeMode := string(*profile.ClusterServiceLoadBalancerHealthProbeMode)
		destination.ClusterServiceLoadBalancerHealthProbeMode = &clusterServiceLoadBalancerHealthProbeMode
	} else {
		destination.ClusterServiceLoadBalancerHealthProbeMode = nil
	}

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]storage.ResourceReference_STATUS, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			var effectiveOutboundIP storage.ResourceReference_STATUS
			err := effectiveOutboundIPItem.AssignProperties_To_ResourceReference_STATUS(&effectiveOutboundIP)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// EnableMultipleStandardLoadBalancers
	if profile.EnableMultipleStandardLoadBalancers != nil {
		enableMultipleStandardLoadBalancer := *profile.EnableMultipleStandardLoadBalancers
		destination.EnableMultipleStandardLoadBalancers = &enableMultipleStandardLoadBalancer
	} else {
		destination.EnableMultipleStandardLoadBalancers = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
		var managedOutboundIP storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS
		err := profile.ManagedOutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS(&managedOutboundIP)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS() to populate field ManagedOutboundIPs")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
		var outboundIPPrefix storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS
		err := profile.OutboundIPPrefixes.AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS(&outboundIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS() to populate field OutboundIPPrefixes")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
		var outboundIP storage.ManagedClusterLoadBalancerProfileOutboundIPs_STATUS
		err := profile.OutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS(&outboundIP)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS() to populate field OutboundIPs")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of the managed cluster NAT gateway.
type ManagedClusterNATGatewayProfile struct {
	// +kubebuilder:validation:Maximum=120
	// +kubebuilder:validation:Minimum=4
	// IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
	// (inclusive). The default value is 4 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// ManagedOutboundIPProfile: Profile of the managed outbound IP resources of the cluster NAT gateway.
	ManagedOutboundIPProfile *ManagedClusterManagedOutboundIPProfile `json:"managedOutboundIPProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterNATGatewayProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterNATGatewayProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterNATGatewayProfile{}

	// Set property "IdleTimeoutInMinutes":
	if profile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *profile.IdleTimeoutInMinutes
		result.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPProfile":
	if profile.ManagedOutboundIPProfile != nil {
		managedOutboundIPProfile_ARM, err := profile.ManagedOutboundIPProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedOutboundIPProfile := *managedOutboundIPProfile_ARM.(*arm.ManagedClusterManagedOutboundIPProfile)
		result.ManagedOutboundIPProfile = &managedOutboundIPProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterNATGatewayProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterNATGatewayProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterNATGatewayProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterNATGatewayProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterNATGatewayProfile, got %T", armInput)
	}

	// Set property "IdleTimeoutInMinutes":
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPProfile":
	if typedInput.ManagedOutboundIPProfile != nil {
		var managedOutboundIPProfile1 ManagedClusterManagedOutboundIPProfile
		err := managedOutboundIPProfile1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPProfile)
		if err != nil {
			return err
		}
		managedOutboundIPProfile := managedOutboundIPProfile1
		profile.ManagedOutboundIPProfile = &managedOutboundIPProfile
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterNATGatewayProfile populates our ManagedClusterNATGatewayProfile from the provided source ManagedClusterNATGatewayProfile
func (profile *ManagedClusterNATGatewayProfile) AssignProperties_From_ManagedClusterNATGatewayProfile(source *storage.ManagedClusterNATGatewayProfile) error {

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPProfile
	if source.ManagedOutboundIPProfile != nil {
		var managedOutboundIPProfile ManagedClusterManagedOutboundIPProfile
		err := managedOutboundIPProfile.AssignProperties_From_ManagedClusterManagedOutboundIPProfile(source.ManagedOutboundIPProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterManagedOutboundIPProfile() to populate field ManagedOutboundIPProfile")
		}
		profile.ManagedOutboundIPProfile = &managedOutboundIPProfile
	} else {
		profile.ManagedOutboundIPProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterNATGatewayProfile populates the provided destination ManagedClusterNATGatewayProfile from our ManagedClusterNATGatewayProfile
func (profile *ManagedClusterNATGatewayProfile) AssignProperties_To_ManagedClusterNATGatewayProfile(destination *storage.ManagedClusterNATGatewayProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPProfile
	if profile.ManagedOutboundIPProfile != nil {
		var managedOutboundIPProfile storage.ManagedClusterManagedOutboundIPProfile
		err := profile.ManagedOutboundIPProfile.AssignProperties_To_ManagedClusterManagedOutboundIPProfile(&managedOutboundIPProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterManagedOutboundIPProfile() to populate field ManagedOutboundIPProfile")
		}
		destination.ManagedOutboundIPProfile = &managedOutboundIPProfile
	} else {
		destination.ManagedOutboundIPProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of the managed cluster NAT gateway.
type ManagedClusterNATGatewayProfile_STATUS struct {
	// EffectiveOutboundIPs: The effective outbound IP resources of the cluster NAT gateway.
	EffectiveOutboundIPs []ResourceReference_STATUS `json:"effectiveOutboundIPs,omitempty"`

	// IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120
	// (inclusive). The default value is 4 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// ManagedOutboundIPProfile: Profile of the managed outbound IP resources of the cluster NAT gateway.
	ManagedOutboundIPProfile *ManagedClusterManagedOutboundIPProfile_STATUS `json:"managedOutboundIPProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterNATGatewayProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterNATGatewayProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterNATGatewayProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterNATGatewayProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterNATGatewayProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterNATGatewayProfile_STATUS, got %T", armInput)
	}

	// Set property "EffectiveOutboundIPs":
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.EffectiveOutboundIPs = append(profile.EffectiveOutboundIPs, item1)
	}

	// Set property "IdleTimeoutInMinutes":
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		profile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property "ManagedOutboundIPProfile":
	if typedInput.ManagedOutboundIPProfile != nil {
		var managedOutboundIPProfile1 ManagedClusterManagedOutboundIPProfile_STATUS
		err := managedOutboundIPProfile1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPProfile)
		if err != nil {
			return err
		}
		managedOutboundIPProfile := managedOutboundIPProfile1
		profile.ManagedOutboundIPProfile = &managedOutboundIPProfile
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterNATGatewayProfile_STATUS populates our ManagedClusterNATGatewayProfile_STATUS from the provided source ManagedClusterNATGatewayProfile_STATUS
func (profile *ManagedClusterNATGatewayProfile_STATUS) AssignProperties_From_ManagedClusterNATGatewayProfile_STATUS(source *storage.ManagedClusterNATGatewayProfile_STATUS) error {

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference_STATUS, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			var effectiveOutboundIP ResourceReference_STATUS
			err := effectiveOutboundIP.AssignProperties_From_ResourceReference_STATUS(&effectiveOutboundIPItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPProfile
	if source.ManagedOutboundIPProfile != nil {
		var managedOutboundIPProfile ManagedClusterManagedOutboundIPProfile_STATUS
		err := managedOutboundIPProfile.AssignProperties_From_ManagedClusterManagedOutboundIPProfile_STATUS(source.ManagedOutboundIPProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterManagedOutboundIPProfile_STATUS() to populate field ManagedOutboundIPProfile")
		}
		profile.ManagedOutboundIPProfile = &managedOutboundIPProfile
	} else {
		profile.ManagedOutboundIPProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterNATGatewayProfile_STATUS populates the provided destination ManagedClusterNATGatewayProfile_STATUS from our ManagedClusterNATGatewayProfile_STATUS
func (profile *ManagedClusterNATGatewayProfile_STATUS) AssignProperties_To_ManagedClusterNATGatewayProfile_STATUS(destination *storage.ManagedClusterNATGatewayProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]storage.ResourceReference_STATUS, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			var effectiveOutboundIP storage.ResourceReference_STATUS
			err := effectiveOutboundIPItem.AssignProperties_To_ResourceReference_STATUS(&effectiveOutboundIP)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPProfile
	if profile.ManagedOutboundIPProfile != nil {
		var managedOutboundIPProfile storage.ManagedClusterManagedOutboundIPProfile_STATUS
		err := profile.ManagedOutboundIPProfile.AssignProperties_To_ManagedClusterManagedOutboundIPProfile_STATUS(&managedOutboundIPProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterManagedOutboundIPProfile_STATUS() to populate field ManagedOutboundIPProfile")
		}
		destination.ManagedOutboundIPProfile = &managedOutboundIPProfile
	} else {
		destination.ManagedOutboundIPProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Auto","None"}
type ManagedClusterNodeProvisioningProfile_DefaultNodePools string

const (
	ManagedClusterNodeProvisioningProfile_DefaultNodePools_Auto = ManagedClusterNodeProvisioningProfile_DefaultNodePools("Auto")
	ManagedClusterNodeProvisioningProfile_DefaultNodePools_None = ManagedClusterNodeProvisioningProfile_DefaultNodePools("None")
)

// Mapping from string to ManagedClusterNodeProvisioningProfile_DefaultNodePools
var managedClusterNodeProvisioningProfile_DefaultNodePools_Values = map[string]ManagedClusterNodeProvisioningProfile_DefaultNodePools{
	"auto": ManagedClusterNodeProvisioningProfile_DefaultNodePools_Auto,
	"none": ManagedClusterNodeProvisioningProfile_DefaultNodePools_None,
}

type ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS string

const (
	ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Auto = ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS("Auto")
	ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_None = ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS("None")
)

// Mapping from string to ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS
var managedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Values = map[string]ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS{
	"auto": ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_Auto,
	"none": ManagedClusterNodeProvisioningProfile_DefaultNodePools_STATUS_None,
}

type ManagedClusterOperatorConfigMaps struct {
	// OIDCIssuerProfile: indicates where the OIDCIssuerProfile config map should be placed. If omitted, no config map will be
	// created.
	OIDCIssuerProfile *genruntime.ConfigMapDestination `json:"oidcIssuerProfile,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorConfigMaps populates our ManagedClusterOperatorConfigMaps from the provided source ManagedClusterOperatorConfigMaps
func (maps *ManagedClusterOperatorConfigMaps) AssignProperties_From_ManagedClusterOperatorConfigMaps(source *storage.ManagedClusterOperatorConfigMaps) error {

	// OIDCIssuerProfile
	if source.OIDCIssuerProfile != nil {
		oidcIssuerProfile := source.OIDCIssuerProfile.Copy()
		maps.OIDCIssuerProfile = &oidcIssuerProfile
	} else {
		maps.OIDCIssuerProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorConfigMaps populates the provided destination ManagedClusterOperatorConfigMaps from our ManagedClusterOperatorConfigMaps
func (maps *ManagedClusterOperatorConfigMaps) AssignProperties_To_ManagedClusterOperatorConfigMaps(destination *storage.ManagedClusterOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OIDCIssuerProfile
	if maps.OIDCIssuerProfile != nil {
		oidcIssuerProfile := maps.OIDCIssuerProfile.Copy()
		destination.OIDCIssuerProfile = &oidcIssuerProfile
	} else {
		destination.OIDCIssuerProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterOperatorSecrets struct {
	// AdminCredentials: indicates where the AdminCredentials secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	AdminCredentials *genruntime.SecretDestination `json:"adminCredentials,omitempty"`

	// UserCredentials: indicates where the UserCredentials secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	UserCredentials *genruntime.SecretDestination `json:"userCredentials,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorSecrets populates our ManagedClusterOperatorSecrets from the provided source ManagedClusterOperatorSecrets
func (secrets *ManagedClusterOperatorSecrets) AssignProperties_From_ManagedClusterOperatorSecrets(source *storage.ManagedClusterOperatorSecrets) error {

	// AdminCredentials
	if source.AdminCredentials != nil {
		adminCredential := source.AdminCredentials.Copy()
		secrets.AdminCredentials = &adminCredential
	} else {
		secrets.AdminCredentials = nil
	}

	// UserCredentials
	if source.UserCredentials != nil {
		userCredential := source.UserCredentials.Copy()
		secrets.UserCredentials = &userCredential
	} else {
		secrets.UserCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorSecrets populates the provided destination ManagedClusterOperatorSecrets from our ManagedClusterOperatorSecrets
func (secrets *ManagedClusterOperatorSecrets) AssignProperties_To_ManagedClusterOperatorSecrets(destination *storage.ManagedClusterOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminCredentials
	if secrets.AdminCredentials != nil {
		adminCredential := secrets.AdminCredentials.Copy()
		destination.AdminCredentials = &adminCredential
	} else {
		destination.AdminCredentials = nil
	}

	// UserCredentials
	if secrets.UserCredentials != nil {
		userCredential := secrets.UserCredentials.Copy()
		destination.UserCredentials = &userCredential
	} else {
		destination.UserCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details about the pod identity assigned to the Managed Cluster.
type ManagedClusterPodIdentity struct {
	// BindingSelector: The binding selector to use for the AzureIdentityBinding resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// +kubebuilder:validation:Required
	// Identity: The user assigned identity details.
	Identity *UserAssignedIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the pod identity.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Namespace: The namespace of the pod identity.
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterPodIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPodIdentity{}

	// Set property "BindingSelector":
	if identity.BindingSelector != nil {
		bindingSelector := *identity.BindingSelector
		result.BindingSelector = &bindingSelector
	}

	// Set property "Identity":
	if identity.Identity != nil {
		identity_ARM, err := identity.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity1 := *identity_ARM.(*arm.UserAssignedIdentity)
		result.Identity = &identity1
	}

	// Set property "Name":
	if identity.Name != nil {
		name := *identity.Name
		result.Name = &name
	}

	// Set property "Namespace":
	if identity.Namespace != nil {
		namespace := *identity.Namespace
		result.Namespace = &namespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterPodIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterPodIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentity, got %T", armInput)
	}

	// Set property "BindingSelector":
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		identity.BindingSelector = &bindingSelector
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity2 UserAssignedIdentity
		err := identity2.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity1 := identity2
		identity.Identity = &identity1
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		identity.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		identity.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentity populates our ManagedClusterPodIdentity from the provided source ManagedClusterPodIdentity
func (identity *ManagedClusterPodIdentity) AssignProperties_From_ManagedClusterPodIdentity(source *storage.ManagedClusterPodIdentity) error {

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity
		err := identityLocal.AssignProperties_From_UserAssignedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity() to populate field Identity")
		}
		identity.Identity = &identityLocal
	} else {
		identity.Identity = nil
	}

	// Name
	identity.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	identity.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentity populates the provided destination ManagedClusterPodIdentity from our ManagedClusterPodIdentity
func (identity *ManagedClusterPodIdentity) AssignProperties_To_ManagedClusterPodIdentity(destination *storage.ManagedClusterPodIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	if identity.Identity != nil {
		var identityLocal storage.UserAssignedIdentity
		err := identity.Identity.AssignProperties_To_UserAssignedIdentity(&identityLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity() to populate field Identity")
		}
		destination.Identity = &identityLocal
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(identity.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(identity.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details about the pod identity assigned to the Managed Cluster.
type ManagedClusterPodIdentity_STATUS struct {
	// BindingSelector: The binding selector to use for the AzureIdentityBinding resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// Identity: The user assigned identity details.
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`

	// Name: The name of the pod identity.
	Name *string `json:"name,omitempty"`

	// Namespace: The namespace of the pod identity.
	Namespace        *string                                           `json:"namespace,omitempty"`
	ProvisioningInfo *ManagedClusterPodIdentityProvisioningInfo_STATUS `json:"provisioningInfo,omitempty"`

	// ProvisioningState: The current provisioning state of the pod identity.
	ProvisioningState *ManagedClusterPodIdentityProvisioningState_STATUS `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterPodIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterPodIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentity_STATUS, got %T", armInput)
	}

	// Set property "BindingSelector":
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		identity.BindingSelector = &bindingSelector
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity2 UserAssignedIdentity_STATUS
		err := identity2.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity1 := identity2
		identity.Identity = &identity1
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		identity.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		identity.Namespace = &namespace
	}

	// Set property "ProvisioningInfo":
	if typedInput.ProvisioningInfo != nil {
		var provisioningInfo1 ManagedClusterPodIdentityProvisioningInfo_STATUS
		err := provisioningInfo1.PopulateFromARM(owner, *typedInput.ProvisioningInfo)
		if err != nil {
			return err
		}
		provisioningInfo := provisioningInfo1
		identity.ProvisioningInfo = &provisioningInfo
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := ManagedClusterPodIdentityProvisioningState_STATUS(temp)
		identity.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentity_STATUS populates our ManagedClusterPodIdentity_STATUS from the provided source ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignProperties_From_ManagedClusterPodIdentity_STATUS(source *storage.ManagedClusterPodIdentity_STATUS) error {

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity_STATUS
		err := identityLocal.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		identity.Identity = &identityLocal
	} else {
		identity.Identity = nil
	}

	// Name
	identity.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	identity.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// ProvisioningInfo
	if source.ProvisioningInfo != nil {
		var provisioningInfo ManagedClusterPodIdentityProvisioningInfo_STATUS
		err := provisioningInfo.AssignProperties_From_ManagedClusterPodIdentityProvisioningInfo_STATUS(source.ProvisioningInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningInfo_STATUS() to populate field ProvisioningInfo")
		}
		identity.ProvisioningInfo = &provisioningInfo
	} else {
		identity.ProvisioningInfo = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, managedClusterPodIdentityProvisioningState_STATUS_Values)
		identity.ProvisioningState = &provisioningStateTemp
	} else {
		identity.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentity_STATUS populates the provided destination ManagedClusterPodIdentity_STATUS from our ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignProperties_To_ManagedClusterPodIdentity_STATUS(destination *storage.ManagedClusterPodIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	if identity.Identity != nil {
		var identityLocal storage.UserAssignedIdentity_STATUS
		err := identity.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identityLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identityLocal
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(identity.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(identity.Namespace)

	// ProvisioningInfo
	if identity.ProvisioningInfo != nil {
		var provisioningInfo storage.ManagedClusterPodIdentityProvisioningInfo_STATUS
		err := identity.ProvisioningInfo.AssignProperties_To_ManagedClusterPodIdentityProvisioningInfo_STATUS(&provisioningInfo)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningInfo_STATUS() to populate field ProvisioningInfo")
		}
		destination.ProvisioningInfo = &provisioningInfo
	} else {
		destination.ProvisioningInfo = nil
	}

	// ProvisioningState
	if identity.ProvisioningState != nil {
		provisioningState := string(*identity.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A pod identity exception, which allows pods with certain labels to access the Azure Instance Metadata Service (IMDS)
// endpoint without being intercepted by the node-managed identity (NMI) server. See [disable AAD Pod Identity for a
// specific Pod/Application](https://azure.github.io/aad-pod-identity/docs/configure/application_exception/) for more
// details.
type ManagedClusterPodIdentityException struct {
	// +kubebuilder:validation:Required
	// Name: The name of the pod identity exception.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Namespace: The namespace of the pod identity exception.
	Namespace *string `json:"namespace,omitempty"`

	// +kubebuilder:validation:Required
	// PodLabels: The pod labels to match.
	PodLabels map[string]string `json:"podLabels,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityException{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (exception *ManagedClusterPodIdentityException) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if exception == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterPodIdentityException{}

	// Set property "Name":
	if exception.Name != nil {
		name := *exception.Name
		result.Name = &name
	}

	// Set property "Namespace":
	if exception.Namespace != nil {
		namespace := *exception.Namespace
		result.Namespace = &namespace
	}

	// Set property "PodLabels":
	if exception.PodLabels != nil {
		result.PodLabels = make(map[string]string, len(exception.PodLabels))
		for key, value := range exception.PodLabels {
			result.PodLabels[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exception *ManagedClusterPodIdentityException) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityException{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exception *ManagedClusterPodIdentityException) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityException)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityException, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		exception.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		exception.Namespace = &namespace
	}

	// Set property "PodLabels":
	if typedInput.PodLabels != nil {
		exception.PodLabels = make(map[string]string, len(typedInput.PodLabels))
		for key, value := range typedInput.PodLabels {
			exception.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityException populates our ManagedClusterPodIdentityException from the provided source ManagedClusterPodIdentityException
func (exception *ManagedClusterPodIdentityException) AssignProperties_From_ManagedClusterPodIdentityException(source *storage.ManagedClusterPodIdentityException) error {

	// Name
	exception.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	exception.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityException populates the provided destination ManagedClusterPodIdentityException from our ManagedClusterPodIdentityException
func (exception *ManagedClusterPodIdentityException) AssignProperties_To_ManagedClusterPodIdentityException(destination *storage.ManagedClusterPodIdentityException) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(exception.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(exception.Namespace)

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A pod identity exception, which allows pods with certain labels to access the Azure Instance Metadata Service (IMDS)
// endpoint without being intercepted by the node-managed identity (NMI) server. See [disable AAD Pod Identity for a
// specific Pod/Application](https://azure.github.io/aad-pod-identity/docs/configure/application_exception/) for more
// details.
type ManagedClusterPodIdentityException_STATUS struct {
	// Name: The name of the pod identity exception.
	Name *string `json:"name,omitempty"`

	// Namespace: The namespace of the pod identity exception.
	Namespace *string `json:"namespace,omitempty"`

	// PodLabels: The pod labels to match.
	PodLabels map[string]string `json:"podLabels,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityException_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (exception *ManagedClusterPodIdentityException_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityException_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (exception *ManagedClusterPodIdentityException_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityException_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityException_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		exception.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		exception.Namespace = &namespace
	}

	// Set property "PodLabels":
	if typedInput.PodLabels != nil {
		exception.PodLabels = make(map[string]string, len(typedInput.PodLabels))
		for key, value := range typedInput.PodLabels {
			exception.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityException_STATUS populates our ManagedClusterPodIdentityException_STATUS from the provided source ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignProperties_From_ManagedClusterPodIdentityException_STATUS(source *storage.ManagedClusterPodIdentityException_STATUS) error {

	// Name
	exception.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	exception.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityException_STATUS populates the provided destination ManagedClusterPodIdentityException_STATUS from our ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignProperties_To_ManagedClusterPodIdentityException_STATUS(destination *storage.ManagedClusterPodIdentityException_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(exception.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(exception.Namespace)

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Microsoft Defender settings for the security profile.
type ManagedClusterSecurityProfileDefender struct {
	// LogAnalyticsWorkspaceResourceReference: Resource ID of the Log Analytics workspace to be associated with Microsoft
	// Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When
	// Microsoft Defender is disabled, leave the field empty.
	LogAnalyticsWorkspaceResourceReference *genruntime.ResourceReference `armReference:"LogAnalyticsWorkspaceResourceId" json:"logAnalyticsWorkspaceResourceReference,omitempty"`

	// SecurityGating: Microsoft Defender settings for security gating, validates container images eligibility for deployment
	// based on Defender for Containers security findings. Using Admission Controller, it either audits or prevents the
	// deployment of images that do not meet security standards.
	SecurityGating *ManagedClusterSecurityProfileDefenderSecurityGating `json:"securityGating,omitempty"`

	// SecurityMonitoring: Microsoft Defender threat detection for Cloud settings for the security profile.
	SecurityMonitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring `json:"securityMonitoring,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileDefender{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (defender *ManagedClusterSecurityProfileDefender) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if defender == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileDefender{}

	// Set property "LogAnalyticsWorkspaceResourceId":
	if defender.LogAnalyticsWorkspaceResourceReference != nil {
		logAnalyticsWorkspaceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*defender.LogAnalyticsWorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		logAnalyticsWorkspaceResourceReference := logAnalyticsWorkspaceResourceReferenceARMID
		result.LogAnalyticsWorkspaceResourceId = &logAnalyticsWorkspaceResourceReference
	}

	// Set property "SecurityGating":
	if defender.SecurityGating != nil {
		securityGating_ARM, err := defender.SecurityGating.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityGating := *securityGating_ARM.(*arm.ManagedClusterSecurityProfileDefenderSecurityGating)
		result.SecurityGating = &securityGating
	}

	// Set property "SecurityMonitoring":
	if defender.SecurityMonitoring != nil {
		securityMonitoring_ARM, err := defender.SecurityMonitoring.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityMonitoring := *securityMonitoring_ARM.(*arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring)
		result.SecurityMonitoring = &securityMonitoring
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (defender *ManagedClusterSecurityProfileDefender) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefender{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (defender *ManagedClusterSecurityProfileDefender) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefender)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefender, got %T", armInput)
	}

	// no assignment for property "LogAnalyticsWorkspaceResourceReference"

	// Set property "SecurityGating":
	if typedInput.SecurityGating != nil {
		var securityGating1 ManagedClusterSecurityProfileDefenderSecurityGating
		err := securityGating1.PopulateFromARM(owner, *typedInput.SecurityGating)
		if err != nil {
			return err
		}
		securityGating := securityGating1
		defender.SecurityGating = &securityGating
	}

	// Set property "SecurityMonitoring":
	if typedInput.SecurityMonitoring != nil {
		var securityMonitoring1 ManagedClusterSecurityProfileDefenderSecurityMonitoring
		err := securityMonitoring1.PopulateFromARM(owner, *typedInput.SecurityMonitoring)
		if err != nil {
			return err
		}
		securityMonitoring := securityMonitoring1
		defender.SecurityMonitoring = &securityMonitoring
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefender populates our ManagedClusterSecurityProfileDefender from the provided source ManagedClusterSecurityProfileDefender
func (defender *ManagedClusterSecurityProfileDefender) AssignProperties_From_ManagedClusterSecurityProfileDefender(source *storage.ManagedClusterSecurityProfileDefender) error {

	// LogAnalyticsWorkspaceResourceReference
	if source.LogAnalyticsWorkspaceResourceReference != nil {
		logAnalyticsWorkspaceResourceReference := source.LogAnalyticsWorkspaceResourceReference.Copy()
		defender.LogAnalyticsWorkspaceResourceReference = &logAnalyticsWorkspaceResourceReference
	} else {
		defender.LogAnalyticsWorkspaceResourceReference = nil
	}

	// SecurityGating
	if source.SecurityGating != nil {
		var securityGating ManagedClusterSecurityProfileDefenderSecurityGating
		err := securityGating.AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating(source.SecurityGating)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating() to populate field SecurityGating")
		}
		defender.SecurityGating = &securityGating
	} else {
		defender.SecurityGating = nil
	}

	// SecurityMonitoring
	if source.SecurityMonitoring != nil {
		var securityMonitoring ManagedClusterSecurityProfileDefenderSecurityMonitoring
		err := securityMonitoring.AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring(source.SecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring() to populate field SecurityMonitoring")
		}
		defender.SecurityMonitoring = &securityMonitoring
	} else {
		defender.SecurityMonitoring = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefender populates the provided destination ManagedClusterSecurityProfileDefender from our ManagedClusterSecurityProfileDefender
func (defender *ManagedClusterSecurityProfileDefender) AssignProperties_To_ManagedClusterSecurityProfileDefender(destination *storage.ManagedClusterSecurityProfileDefender) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalyticsWorkspaceResourceReference
	if defender.LogAnalyticsWorkspaceResourceReference != nil {
		logAnalyticsWorkspaceResourceReference := defender.LogAnalyticsWorkspaceResourceReference.Copy()
		destination.LogAnalyticsWorkspaceResourceReference = &logAnalyticsWorkspaceResourceReference
	} else {
		destination.LogAnalyticsWorkspaceResourceReference = nil
	}

	// SecurityGating
	if defender.SecurityGating != nil {
		var securityGating storage.ManagedClusterSecurityProfileDefenderSecurityGating
		err := defender.SecurityGating.AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating(&securityGating)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating() to populate field SecurityGating")
		}
		destination.SecurityGating = &securityGating
	} else {
		destination.SecurityGating = nil
	}

	// SecurityMonitoring
	if defender.SecurityMonitoring != nil {
		var securityMonitoring storage.ManagedClusterSecurityProfileDefenderSecurityMonitoring
		err := defender.SecurityMonitoring.AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring(&securityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring() to populate field SecurityMonitoring")
		}
		destination.SecurityMonitoring = &securityMonitoring
	} else {
		destination.SecurityMonitoring = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Microsoft Defender settings for the security profile.
type ManagedClusterSecurityProfileDefender_STATUS struct {
	// LogAnalyticsWorkspaceResourceId: Resource ID of the Log Analytics workspace to be associated with Microsoft Defender.
	// When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft
	// Defender is disabled, leave the field empty.
	LogAnalyticsWorkspaceResourceId *string `json:"logAnalyticsWorkspaceResourceId,omitempty"`

	// SecurityGating: Microsoft Defender settings for security gating, validates container images eligibility for deployment
	// based on Defender for Containers security findings. Using Admission Controller, it either audits or prevents the
	// deployment of images that do not meet security standards.
	SecurityGating *ManagedClusterSecurityProfileDefenderSecurityGating_STATUS `json:"securityGating,omitempty"`

	// SecurityMonitoring: Microsoft Defender threat detection for Cloud settings for the security profile.
	SecurityMonitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS `json:"securityMonitoring,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileDefender_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (defender *ManagedClusterSecurityProfileDefender_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefender_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (defender *ManagedClusterSecurityProfileDefender_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefender_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefender_STATUS, got %T", armInput)
	}

	// Set property "LogAnalyticsWorkspaceResourceId":
	if typedInput.LogAnalyticsWorkspaceResourceId != nil {
		logAnalyticsWorkspaceResourceId := *typedInput.LogAnalyticsWorkspaceResourceId
		defender.LogAnalyticsWorkspaceResourceId = &logAnalyticsWorkspaceResourceId
	}

	// Set property "SecurityGating":
	if typedInput.SecurityGating != nil {
		var securityGating1 ManagedClusterSecurityProfileDefenderSecurityGating_STATUS
		err := securityGating1.PopulateFromARM(owner, *typedInput.SecurityGating)
		if err != nil {
			return err
		}
		securityGating := securityGating1
		defender.SecurityGating = &securityGating
	}

	// Set property "SecurityMonitoring":
	if typedInput.SecurityMonitoring != nil {
		var securityMonitoring1 ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS
		err := securityMonitoring1.PopulateFromARM(owner, *typedInput.SecurityMonitoring)
		if err != nil {
			return err
		}
		securityMonitoring := securityMonitoring1
		defender.SecurityMonitoring = &securityMonitoring
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefender_STATUS populates our ManagedClusterSecurityProfileDefender_STATUS from the provided source ManagedClusterSecurityProfileDefender_STATUS
func (defender *ManagedClusterSecurityProfileDefender_STATUS) AssignProperties_From_ManagedClusterSecurityProfileDefender_STATUS(source *storage.ManagedClusterSecurityProfileDefender_STATUS) error {

	// LogAnalyticsWorkspaceResourceId
	defender.LogAnalyticsWorkspaceResourceId = genruntime.ClonePointerToString(source.LogAnalyticsWorkspaceResourceId)

	// SecurityGating
	if source.SecurityGating != nil {
		var securityGating ManagedClusterSecurityProfileDefenderSecurityGating_STATUS
		err := securityGating.AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS(source.SecurityGating)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS() to populate field SecurityGating")
		}
		defender.SecurityGating = &securityGating
	} else {
		defender.SecurityGating = nil
	}

	// SecurityMonitoring
	if source.SecurityMonitoring != nil {
		var securityMonitoring ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS
		err := securityMonitoring.AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS(source.SecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS() to populate field SecurityMonitoring")
		}
		defender.SecurityMonitoring = &securityMonitoring
	} else {
		defender.SecurityMonitoring = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefender_STATUS populates the provided destination ManagedClusterSecurityProfileDefender_STATUS from our ManagedClusterSecurityProfileDefender_STATUS
func (defender *ManagedClusterSecurityProfileDefender_STATUS) AssignProperties_To_ManagedClusterSecurityProfileDefender_STATUS(destination *storage.ManagedClusterSecurityProfileDefender_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogAnalyticsWorkspaceResourceId
	destination.LogAnalyticsWorkspaceResourceId = genruntime.ClonePointerToString(defender.LogAnalyticsWorkspaceResourceId)

	// SecurityGating
	if defender.SecurityGating != nil {
		var securityGating storage.ManagedClusterSecurityProfileDefenderSecurityGating_STATUS
		err := defender.SecurityGating.AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS(&securityGating)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS() to populate field SecurityGating")
		}
		destination.SecurityGating = &securityGating
	} else {
		destination.SecurityGating = nil
	}

	// SecurityMonitoring
	if defender.SecurityMonitoring != nil {
		var securityMonitoring storage.ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS
		err := defender.SecurityMonitoring.AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS(&securityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS() to populate field SecurityMonitoring")
		}
		destination.SecurityMonitoring = &securityMonitoring
	} else {
		destination.SecurityMonitoring = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Image Cleaner removes unused images from nodes, freeing up disk space and helping to reduce attack surface area. Here
// are settings for the security profile.
type ManagedClusterSecurityProfileImageCleaner struct {
	// Enabled: Whether to enable Image Cleaner on AKS cluster.
	Enabled *bool `json:"enabled,omitempty"`

	// IntervalHours: Image Cleaner scanning interval in hours.
	IntervalHours *int `json:"intervalHours,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileImageCleaner{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cleaner *ManagedClusterSecurityProfileImageCleaner) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cleaner == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileImageCleaner{}

	// Set property "Enabled":
	if cleaner.Enabled != nil {
		enabled := *cleaner.Enabled
		result.Enabled = &enabled
	}

	// Set property "IntervalHours":
	if cleaner.IntervalHours != nil {
		intervalHours := *cleaner.IntervalHours
		result.IntervalHours = &intervalHours
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cleaner *ManagedClusterSecurityProfileImageCleaner) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileImageCleaner{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cleaner *ManagedClusterSecurityProfileImageCleaner) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileImageCleaner)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileImageCleaner, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		cleaner.Enabled = &enabled
	}

	// Set property "IntervalHours":
	if typedInput.IntervalHours != nil {
		intervalHours := *typedInput.IntervalHours
		cleaner.IntervalHours = &intervalHours
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileImageCleaner populates our ManagedClusterSecurityProfileImageCleaner from the provided source ManagedClusterSecurityProfileImageCleaner
func (cleaner *ManagedClusterSecurityProfileImageCleaner) AssignProperties_From_ManagedClusterSecurityProfileImageCleaner(source *storage.ManagedClusterSecurityProfileImageCleaner) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		cleaner.Enabled = &enabled
	} else {
		cleaner.Enabled = nil
	}

	// IntervalHours
	cleaner.IntervalHours = genruntime.ClonePointerToInt(source.IntervalHours)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileImageCleaner populates the provided destination ManagedClusterSecurityProfileImageCleaner from our ManagedClusterSecurityProfileImageCleaner
func (cleaner *ManagedClusterSecurityProfileImageCleaner) AssignProperties_To_ManagedClusterSecurityProfileImageCleaner(destination *storage.ManagedClusterSecurityProfileImageCleaner) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if cleaner.Enabled != nil {
		enabled := *cleaner.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IntervalHours
	destination.IntervalHours = genruntime.ClonePointerToInt(cleaner.IntervalHours)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Image Cleaner removes unused images from nodes, freeing up disk space and helping to reduce attack surface area. Here
// are settings for the security profile.
type ManagedClusterSecurityProfileImageCleaner_STATUS struct {
	// Enabled: Whether to enable Image Cleaner on AKS cluster.
	Enabled *bool `json:"enabled,omitempty"`

	// IntervalHours: Image Cleaner scanning interval in hours.
	IntervalHours *int `json:"intervalHours,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileImageCleaner_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cleaner *ManagedClusterSecurityProfileImageCleaner_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileImageCleaner_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cleaner *ManagedClusterSecurityProfileImageCleaner_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileImageCleaner_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileImageCleaner_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		cleaner.Enabled = &enabled
	}

	// Set property "IntervalHours":
	if typedInput.IntervalHours != nil {
		intervalHours := *typedInput.IntervalHours
		cleaner.IntervalHours = &intervalHours
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileImageCleaner_STATUS populates our ManagedClusterSecurityProfileImageCleaner_STATUS from the provided source ManagedClusterSecurityProfileImageCleaner_STATUS
func (cleaner *ManagedClusterSecurityProfileImageCleaner_STATUS) AssignProperties_From_ManagedClusterSecurityProfileImageCleaner_STATUS(source *storage.ManagedClusterSecurityProfileImageCleaner_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		cleaner.Enabled = &enabled
	} else {
		cleaner.Enabled = nil
	}

	// IntervalHours
	cleaner.IntervalHours = genruntime.ClonePointerToInt(source.IntervalHours)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileImageCleaner_STATUS populates the provided destination ManagedClusterSecurityProfileImageCleaner_STATUS from our ManagedClusterSecurityProfileImageCleaner_STATUS
func (cleaner *ManagedClusterSecurityProfileImageCleaner_STATUS) AssignProperties_To_ManagedClusterSecurityProfileImageCleaner_STATUS(destination *storage.ManagedClusterSecurityProfileImageCleaner_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if cleaner.Enabled != nil {
		enabled := *cleaner.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// IntervalHours
	destination.IntervalHours = genruntime.ClonePointerToInt(cleaner.IntervalHours)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Image integrity related settings for the security profile.
type ManagedClusterSecurityProfileImageIntegrity struct {
	// Enabled: Whether to enable image integrity. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileImageIntegrity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (integrity *ManagedClusterSecurityProfileImageIntegrity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if integrity == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileImageIntegrity{}

	// Set property "Enabled":
	if integrity.Enabled != nil {
		enabled := *integrity.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (integrity *ManagedClusterSecurityProfileImageIntegrity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileImageIntegrity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (integrity *ManagedClusterSecurityProfileImageIntegrity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileImageIntegrity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileImageIntegrity, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		integrity.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity populates our ManagedClusterSecurityProfileImageIntegrity from the provided source ManagedClusterSecurityProfileImageIntegrity
func (integrity *ManagedClusterSecurityProfileImageIntegrity) AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity(source *storage.ManagedClusterSecurityProfileImageIntegrity) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		integrity.Enabled = &enabled
	} else {
		integrity.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity populates the provided destination ManagedClusterSecurityProfileImageIntegrity from our ManagedClusterSecurityProfileImageIntegrity
func (integrity *ManagedClusterSecurityProfileImageIntegrity) AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity(destination *storage.ManagedClusterSecurityProfileImageIntegrity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if integrity.Enabled != nil {
		enabled := *integrity.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Image integrity related settings for the security profile.
type ManagedClusterSecurityProfileImageIntegrity_STATUS struct {
	// Enabled: Whether to enable image integrity. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileImageIntegrity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (integrity *ManagedClusterSecurityProfileImageIntegrity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileImageIntegrity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (integrity *ManagedClusterSecurityProfileImageIntegrity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileImageIntegrity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileImageIntegrity_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		integrity.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity_STATUS populates our ManagedClusterSecurityProfileImageIntegrity_STATUS from the provided source ManagedClusterSecurityProfileImageIntegrity_STATUS
func (integrity *ManagedClusterSecurityProfileImageIntegrity_STATUS) AssignProperties_From_ManagedClusterSecurityProfileImageIntegrity_STATUS(source *storage.ManagedClusterSecurityProfileImageIntegrity_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		integrity.Enabled = &enabled
	} else {
		integrity.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity_STATUS populates the provided destination ManagedClusterSecurityProfileImageIntegrity_STATUS from our ManagedClusterSecurityProfileImageIntegrity_STATUS
func (integrity *ManagedClusterSecurityProfileImageIntegrity_STATUS) AssignProperties_To_ManagedClusterSecurityProfileImageIntegrity_STATUS(destination *storage.ManagedClusterSecurityProfileImageIntegrity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if integrity.Enabled != nil {
		enabled := *integrity.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Node Restriction settings for the security profile.
type ManagedClusterSecurityProfileNodeRestriction struct {
	// Enabled: Whether to enable Node Restriction
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileNodeRestriction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restriction *ManagedClusterSecurityProfileNodeRestriction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if restriction == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileNodeRestriction{}

	// Set property "Enabled":
	if restriction.Enabled != nil {
		enabled := *restriction.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *ManagedClusterSecurityProfileNodeRestriction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileNodeRestriction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *ManagedClusterSecurityProfileNodeRestriction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileNodeRestriction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileNodeRestriction, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		restriction.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction populates our ManagedClusterSecurityProfileNodeRestriction from the provided source ManagedClusterSecurityProfileNodeRestriction
func (restriction *ManagedClusterSecurityProfileNodeRestriction) AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction(source *storage.ManagedClusterSecurityProfileNodeRestriction) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		restriction.Enabled = &enabled
	} else {
		restriction.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction populates the provided destination ManagedClusterSecurityProfileNodeRestriction from our ManagedClusterSecurityProfileNodeRestriction
func (restriction *ManagedClusterSecurityProfileNodeRestriction) AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction(destination *storage.ManagedClusterSecurityProfileNodeRestriction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if restriction.Enabled != nil {
		enabled := *restriction.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Node Restriction settings for the security profile.
type ManagedClusterSecurityProfileNodeRestriction_STATUS struct {
	// Enabled: Whether to enable Node Restriction
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileNodeRestriction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *ManagedClusterSecurityProfileNodeRestriction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileNodeRestriction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *ManagedClusterSecurityProfileNodeRestriction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileNodeRestriction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileNodeRestriction_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		restriction.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction_STATUS populates our ManagedClusterSecurityProfileNodeRestriction_STATUS from the provided source ManagedClusterSecurityProfileNodeRestriction_STATUS
func (restriction *ManagedClusterSecurityProfileNodeRestriction_STATUS) AssignProperties_From_ManagedClusterSecurityProfileNodeRestriction_STATUS(source *storage.ManagedClusterSecurityProfileNodeRestriction_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		restriction.Enabled = &enabled
	} else {
		restriction.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction_STATUS populates the provided destination ManagedClusterSecurityProfileNodeRestriction_STATUS from our ManagedClusterSecurityProfileNodeRestriction_STATUS
func (restriction *ManagedClusterSecurityProfileNodeRestriction_STATUS) AssignProperties_To_ManagedClusterSecurityProfileNodeRestriction_STATUS(destination *storage.ManagedClusterSecurityProfileNodeRestriction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if restriction.Enabled != nil {
		enabled := *restriction.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Workload identity settings for the security profile.
type ManagedClusterSecurityProfileWorkloadIdentity struct {
	// Enabled: Whether to enable workload identity.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileWorkloadIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedClusterSecurityProfileWorkloadIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileWorkloadIdentity{}

	// Set property "Enabled":
	if identity.Enabled != nil {
		enabled := *identity.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterSecurityProfileWorkloadIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileWorkloadIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterSecurityProfileWorkloadIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileWorkloadIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileWorkloadIdentity, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		identity.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity populates our ManagedClusterSecurityProfileWorkloadIdentity from the provided source ManagedClusterSecurityProfileWorkloadIdentity
func (identity *ManagedClusterSecurityProfileWorkloadIdentity) AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity(source *storage.ManagedClusterSecurityProfileWorkloadIdentity) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		identity.Enabled = &enabled
	} else {
		identity.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity populates the provided destination ManagedClusterSecurityProfileWorkloadIdentity from our ManagedClusterSecurityProfileWorkloadIdentity
func (identity *ManagedClusterSecurityProfileWorkloadIdentity) AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity(destination *storage.ManagedClusterSecurityProfileWorkloadIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if identity.Enabled != nil {
		enabled := *identity.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Workload identity settings for the security profile.
type ManagedClusterSecurityProfileWorkloadIdentity_STATUS struct {
	// Enabled: Whether to enable workload identity.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileWorkloadIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedClusterSecurityProfileWorkloadIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileWorkloadIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedClusterSecurityProfileWorkloadIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileWorkloadIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileWorkloadIdentity_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		identity.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity_STATUS populates our ManagedClusterSecurityProfileWorkloadIdentity_STATUS from the provided source ManagedClusterSecurityProfileWorkloadIdentity_STATUS
func (identity *ManagedClusterSecurityProfileWorkloadIdentity_STATUS) AssignProperties_From_ManagedClusterSecurityProfileWorkloadIdentity_STATUS(source *storage.ManagedClusterSecurityProfileWorkloadIdentity_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		identity.Enabled = &enabled
	} else {
		identity.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity_STATUS populates the provided destination ManagedClusterSecurityProfileWorkloadIdentity_STATUS from our ManagedClusterSecurityProfileWorkloadIdentity_STATUS
func (identity *ManagedClusterSecurityProfileWorkloadIdentity_STATUS) AssignProperties_To_ManagedClusterSecurityProfileWorkloadIdentity_STATUS(destination *storage.ManagedClusterSecurityProfileWorkloadIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if identity.Enabled != nil {
		enabled := *identity.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The name of a managed cluster SKU.
// +kubebuilder:validation:Enum={"Automatic","Base"}
type ManagedClusterSKUName string

const (
	ManagedClusterSKUName_Automatic = ManagedClusterSKUName("Automatic")
	ManagedClusterSKUName_Base      = ManagedClusterSKUName("Base")
)

// Mapping from string to ManagedClusterSKUName
var managedClusterSKUName_Values = map[string]ManagedClusterSKUName{
	"automatic": ManagedClusterSKUName_Automatic,
	"base":      ManagedClusterSKUName_Base,
}

// The name of a managed cluster SKU.
type ManagedClusterSKUName_STATUS string

const (
	ManagedClusterSKUName_STATUS_Automatic = ManagedClusterSKUName_STATUS("Automatic")
	ManagedClusterSKUName_STATUS_Base      = ManagedClusterSKUName_STATUS("Base")
)

// Mapping from string to ManagedClusterSKUName_STATUS
var managedClusterSKUName_STATUS_Values = map[string]ManagedClusterSKUName_STATUS{
	"automatic": ManagedClusterSKUName_STATUS_Automatic,
	"base":      ManagedClusterSKUName_STATUS_Base,
}

// The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing
// Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
// +kubebuilder:validation:Enum={"Free","Premium","Standard"}
type ManagedClusterSKUTier string

const (
	ManagedClusterSKUTier_Free     = ManagedClusterSKUTier("Free")
	ManagedClusterSKUTier_Premium  = ManagedClusterSKUTier("Premium")
	ManagedClusterSKUTier_Standard = ManagedClusterSKUTier("Standard")
)

// Mapping from string to ManagedClusterSKUTier
var managedClusterSKUTier_Values = map[string]ManagedClusterSKUTier{
	"free":     ManagedClusterSKUTier_Free,
	"premium":  ManagedClusterSKUTier_Premium,
	"standard": ManagedClusterSKUTier_Standard,
}

// The tier of a managed cluster SKU. If not specified, the default is 'Free'. See [AKS Pricing
// Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
type ManagedClusterSKUTier_STATUS string

const (
	ManagedClusterSKUTier_STATUS_Free     = ManagedClusterSKUTier_STATUS("Free")
	ManagedClusterSKUTier_STATUS_Premium  = ManagedClusterSKUTier_STATUS("Premium")
	ManagedClusterSKUTier_STATUS_Standard = ManagedClusterSKUTier_STATUS("Standard")
)

// Mapping from string to ManagedClusterSKUTier_STATUS
var managedClusterSKUTier_STATUS_Values = map[string]ManagedClusterSKUTier_STATUS{
	"free":     ManagedClusterSKUTier_STATUS_Free,
	"premium":  ManagedClusterSKUTier_STATUS_Premium,
	"standard": ManagedClusterSKUTier_STATUS_Standard,
}

// The Static Egress Gateway addon configuration for the cluster.
type ManagedClusterStaticEgressGatewayProfile struct {
	// Enabled: Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterStaticEgressGatewayProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterStaticEgressGatewayProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterStaticEgressGatewayProfile{}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterStaticEgressGatewayProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStaticEgressGatewayProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterStaticEgressGatewayProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStaticEgressGatewayProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStaticEgressGatewayProfile, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStaticEgressGatewayProfile populates our ManagedClusterStaticEgressGatewayProfile from the provided source ManagedClusterStaticEgressGatewayProfile
func (profile *ManagedClusterStaticEgressGatewayProfile) AssignProperties_From_ManagedClusterStaticEgressGatewayProfile(source *storage.ManagedClusterStaticEgressGatewayProfile) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStaticEgressGatewayProfile populates the provided destination ManagedClusterStaticEgressGatewayProfile from our ManagedClusterStaticEgressGatewayProfile
func (profile *ManagedClusterStaticEgressGatewayProfile) AssignProperties_To_ManagedClusterStaticEgressGatewayProfile(destination *storage.ManagedClusterStaticEgressGatewayProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Static Egress Gateway addon configuration for the cluster.
type ManagedClusterStaticEgressGatewayProfile_STATUS struct {
	// Enabled: Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStaticEgressGatewayProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterStaticEgressGatewayProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStaticEgressGatewayProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterStaticEgressGatewayProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStaticEgressGatewayProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStaticEgressGatewayProfile_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStaticEgressGatewayProfile_STATUS populates our ManagedClusterStaticEgressGatewayProfile_STATUS from the provided source ManagedClusterStaticEgressGatewayProfile_STATUS
func (profile *ManagedClusterStaticEgressGatewayProfile_STATUS) AssignProperties_From_ManagedClusterStaticEgressGatewayProfile_STATUS(source *storage.ManagedClusterStaticEgressGatewayProfile_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStaticEgressGatewayProfile_STATUS populates the provided destination ManagedClusterStaticEgressGatewayProfile_STATUS from our ManagedClusterStaticEgressGatewayProfile_STATUS
func (profile *ManagedClusterStaticEgressGatewayProfile_STATUS) AssignProperties_To_ManagedClusterStaticEgressGatewayProfile_STATUS(destination *storage.ManagedClusterStaticEgressGatewayProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureBlob CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileBlobCSIDriver struct {
	// Enabled: Whether to enable AzureBlob CSI Driver. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterStorageProfileBlobCSIDriver{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (driver *ManagedClusterStorageProfileBlobCSIDriver) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if driver == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterStorageProfileBlobCSIDriver{}

	// Set property "Enabled":
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (driver *ManagedClusterStorageProfileBlobCSIDriver) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileBlobCSIDriver{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (driver *ManagedClusterStorageProfileBlobCSIDriver) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileBlobCSIDriver)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileBlobCSIDriver, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		driver.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver populates our ManagedClusterStorageProfileBlobCSIDriver from the provided source ManagedClusterStorageProfileBlobCSIDriver
func (driver *ManagedClusterStorageProfileBlobCSIDriver) AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver(source *storage.ManagedClusterStorageProfileBlobCSIDriver) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		driver.Enabled = &enabled
	} else {
		driver.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver populates the provided destination ManagedClusterStorageProfileBlobCSIDriver from our ManagedClusterStorageProfileBlobCSIDriver
func (driver *ManagedClusterStorageProfileBlobCSIDriver) AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver(destination *storage.ManagedClusterStorageProfileBlobCSIDriver) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureBlob CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileBlobCSIDriver_STATUS struct {
	// Enabled: Whether to enable AzureBlob CSI Driver. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStorageProfileBlobCSIDriver_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (driver *ManagedClusterStorageProfileBlobCSIDriver_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileBlobCSIDriver_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (driver *ManagedClusterStorageProfileBlobCSIDriver_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileBlobCSIDriver_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileBlobCSIDriver_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		driver.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver_STATUS populates our ManagedClusterStorageProfileBlobCSIDriver_STATUS from the provided source ManagedClusterStorageProfileBlobCSIDriver_STATUS
func (driver *ManagedClusterStorageProfileBlobCSIDriver_STATUS) AssignProperties_From_ManagedClusterStorageProfileBlobCSIDriver_STATUS(source *storage.ManagedClusterStorageProfileBlobCSIDriver_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		driver.Enabled = &enabled
	} else {
		driver.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver_STATUS populates the provided destination ManagedClusterStorageProfileBlobCSIDriver_STATUS from our ManagedClusterStorageProfileBlobCSIDriver_STATUS
func (driver *ManagedClusterStorageProfileBlobCSIDriver_STATUS) AssignProperties_To_ManagedClusterStorageProfileBlobCSIDriver_STATUS(destination *storage.ManagedClusterStorageProfileBlobCSIDriver_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureDisk CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileDiskCSIDriver struct {
	// Enabled: Whether to enable AzureDisk CSI Driver. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`

	// Version: The version of AzureDisk CSI Driver. The default value is v1.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterStorageProfileDiskCSIDriver{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (driver *ManagedClusterStorageProfileDiskCSIDriver) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if driver == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterStorageProfileDiskCSIDriver{}

	// Set property "Enabled":
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		result.Enabled = &enabled
	}

	// Set property "Version":
	if driver.Version != nil {
		version := *driver.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (driver *ManagedClusterStorageProfileDiskCSIDriver) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileDiskCSIDriver{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (driver *ManagedClusterStorageProfileDiskCSIDriver) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileDiskCSIDriver)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileDiskCSIDriver, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		driver.Enabled = &enabled
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		driver.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver populates our ManagedClusterStorageProfileDiskCSIDriver from the provided source ManagedClusterStorageProfileDiskCSIDriver
func (driver *ManagedClusterStorageProfileDiskCSIDriver) AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver(source *storage.ManagedClusterStorageProfileDiskCSIDriver) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		driver.Enabled = &enabled
	} else {
		driver.Enabled = nil
	}

	// Version
	driver.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver populates the provided destination ManagedClusterStorageProfileDiskCSIDriver from our ManagedClusterStorageProfileDiskCSIDriver
func (driver *ManagedClusterStorageProfileDiskCSIDriver) AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver(destination *storage.ManagedClusterStorageProfileDiskCSIDriver) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToString(driver.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureDisk CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileDiskCSIDriver_STATUS struct {
	// Enabled: Whether to enable AzureDisk CSI Driver. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`

	// Version: The version of AzureDisk CSI Driver. The default value is v1.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStorageProfileDiskCSIDriver_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (driver *ManagedClusterStorageProfileDiskCSIDriver_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileDiskCSIDriver_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (driver *ManagedClusterStorageProfileDiskCSIDriver_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileDiskCSIDriver_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileDiskCSIDriver_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		driver.Enabled = &enabled
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		driver.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver_STATUS populates our ManagedClusterStorageProfileDiskCSIDriver_STATUS from the provided source ManagedClusterStorageProfileDiskCSIDriver_STATUS
func (driver *ManagedClusterStorageProfileDiskCSIDriver_STATUS) AssignProperties_From_ManagedClusterStorageProfileDiskCSIDriver_STATUS(source *storage.ManagedClusterStorageProfileDiskCSIDriver_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		driver.Enabled = &enabled
	} else {
		driver.Enabled = nil
	}

	// Version
	driver.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver_STATUS populates the provided destination ManagedClusterStorageProfileDiskCSIDriver_STATUS from our ManagedClusterStorageProfileDiskCSIDriver_STATUS
func (driver *ManagedClusterStorageProfileDiskCSIDriver_STATUS) AssignProperties_To_ManagedClusterStorageProfileDiskCSIDriver_STATUS(destination *storage.ManagedClusterStorageProfileDiskCSIDriver_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToString(driver.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureFile CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileFileCSIDriver struct {
	// Enabled: Whether to enable AzureFile CSI Driver. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterStorageProfileFileCSIDriver{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (driver *ManagedClusterStorageProfileFileCSIDriver) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if driver == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterStorageProfileFileCSIDriver{}

	// Set property "Enabled":
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (driver *ManagedClusterStorageProfileFileCSIDriver) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileFileCSIDriver{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (driver *ManagedClusterStorageProfileFileCSIDriver) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileFileCSIDriver)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileFileCSIDriver, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		driver.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver populates our ManagedClusterStorageProfileFileCSIDriver from the provided source ManagedClusterStorageProfileFileCSIDriver
func (driver *ManagedClusterStorageProfileFileCSIDriver) AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver(source *storage.ManagedClusterStorageProfileFileCSIDriver) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		driver.Enabled = &enabled
	} else {
		driver.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver populates the provided destination ManagedClusterStorageProfileFileCSIDriver from our ManagedClusterStorageProfileFileCSIDriver
func (driver *ManagedClusterStorageProfileFileCSIDriver) AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver(destination *storage.ManagedClusterStorageProfileFileCSIDriver) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AzureFile CSI Driver settings for the storage profile.
type ManagedClusterStorageProfileFileCSIDriver_STATUS struct {
	// Enabled: Whether to enable AzureFile CSI Driver. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStorageProfileFileCSIDriver_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (driver *ManagedClusterStorageProfileFileCSIDriver_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileFileCSIDriver_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (driver *ManagedClusterStorageProfileFileCSIDriver_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileFileCSIDriver_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileFileCSIDriver_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		driver.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver_STATUS populates our ManagedClusterStorageProfileFileCSIDriver_STATUS from the provided source ManagedClusterStorageProfileFileCSIDriver_STATUS
func (driver *ManagedClusterStorageProfileFileCSIDriver_STATUS) AssignProperties_From_ManagedClusterStorageProfileFileCSIDriver_STATUS(source *storage.ManagedClusterStorageProfileFileCSIDriver_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		driver.Enabled = &enabled
	} else {
		driver.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver_STATUS populates the provided destination ManagedClusterStorageProfileFileCSIDriver_STATUS from our ManagedClusterStorageProfileFileCSIDriver_STATUS
func (driver *ManagedClusterStorageProfileFileCSIDriver_STATUS) AssignProperties_To_ManagedClusterStorageProfileFileCSIDriver_STATUS(destination *storage.ManagedClusterStorageProfileFileCSIDriver_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if driver.Enabled != nil {
		enabled := *driver.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Snapshot Controller settings for the storage profile.
type ManagedClusterStorageProfileSnapshotController struct {
	// Enabled: Whether to enable Snapshot Controller. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterStorageProfileSnapshotController{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (controller *ManagedClusterStorageProfileSnapshotController) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if controller == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterStorageProfileSnapshotController{}

	// Set property "Enabled":
	if controller.Enabled != nil {
		enabled := *controller.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (controller *ManagedClusterStorageProfileSnapshotController) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileSnapshotController{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (controller *ManagedClusterStorageProfileSnapshotController) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileSnapshotController)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileSnapshotController, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		controller.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileSnapshotController populates our ManagedClusterStorageProfileSnapshotController from the provided source ManagedClusterStorageProfileSnapshotController
func (controller *ManagedClusterStorageProfileSnapshotController) AssignProperties_From_ManagedClusterStorageProfileSnapshotController(source *storage.ManagedClusterStorageProfileSnapshotController) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		controller.Enabled = &enabled
	} else {
		controller.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileSnapshotController populates the provided destination ManagedClusterStorageProfileSnapshotController from our ManagedClusterStorageProfileSnapshotController
func (controller *ManagedClusterStorageProfileSnapshotController) AssignProperties_To_ManagedClusterStorageProfileSnapshotController(destination *storage.ManagedClusterStorageProfileSnapshotController) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if controller.Enabled != nil {
		enabled := *controller.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Snapshot Controller settings for the storage profile.
type ManagedClusterStorageProfileSnapshotController_STATUS struct {
	// Enabled: Whether to enable Snapshot Controller. The default value is true.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterStorageProfileSnapshotController_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (controller *ManagedClusterStorageProfileSnapshotController_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterStorageProfileSnapshotController_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (controller *ManagedClusterStorageProfileSnapshotController_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterStorageProfileSnapshotController_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterStorageProfileSnapshotController_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		controller.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterStorageProfileSnapshotController_STATUS populates our ManagedClusterStorageProfileSnapshotController_STATUS from the provided source ManagedClusterStorageProfileSnapshotController_STATUS
func (controller *ManagedClusterStorageProfileSnapshotController_STATUS) AssignProperties_From_ManagedClusterStorageProfileSnapshotController_STATUS(source *storage.ManagedClusterStorageProfileSnapshotController_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		controller.Enabled = &enabled
	} else {
		controller.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterStorageProfileSnapshotController_STATUS populates the provided destination ManagedClusterStorageProfileSnapshotController_STATUS from our ManagedClusterStorageProfileSnapshotController_STATUS
func (controller *ManagedClusterStorageProfileSnapshotController_STATUS) AssignProperties_To_ManagedClusterStorageProfileSnapshotController_STATUS(destination *storage.ManagedClusterStorageProfileSnapshotController_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if controller.Enabled != nil {
		enabled := *controller.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
type ManagedClusterWorkloadAutoScalerProfileKeda struct {
	// +kubebuilder:validation:Required
	// Enabled: Whether to enable KEDA.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWorkloadAutoScalerProfileKeda{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if keda == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterWorkloadAutoScalerProfileKeda{}

	// Set property "Enabled":
	if keda.Enabled != nil {
		enabled := *keda.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWorkloadAutoScalerProfileKeda{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWorkloadAutoScalerProfileKeda)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWorkloadAutoScalerProfileKeda, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		keda.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda populates our ManagedClusterWorkloadAutoScalerProfileKeda from the provided source ManagedClusterWorkloadAutoScalerProfileKeda
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda) AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda(source *storage.ManagedClusterWorkloadAutoScalerProfileKeda) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		keda.Enabled = &enabled
	} else {
		keda.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda populates the provided destination ManagedClusterWorkloadAutoScalerProfileKeda from our ManagedClusterWorkloadAutoScalerProfileKeda
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda) AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda(destination *storage.ManagedClusterWorkloadAutoScalerProfileKeda) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if keda.Enabled != nil {
		enabled := *keda.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
type ManagedClusterWorkloadAutoScalerProfileKeda_STATUS struct {
	// Enabled: Whether to enable KEDA.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWorkloadAutoScalerProfileKeda_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWorkloadAutoScalerProfileKeda_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWorkloadAutoScalerProfileKeda_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWorkloadAutoScalerProfileKeda_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		keda.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS populates our ManagedClusterWorkloadAutoScalerProfileKeda_STATUS from the provided source ManagedClusterWorkloadAutoScalerProfileKeda_STATUS
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda_STATUS) AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS(source *storage.ManagedClusterWorkloadAutoScalerProfileKeda_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		keda.Enabled = &enabled
	} else {
		keda.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS populates the provided destination ManagedClusterWorkloadAutoScalerProfileKeda_STATUS from our ManagedClusterWorkloadAutoScalerProfileKeda_STATUS
func (keda *ManagedClusterWorkloadAutoScalerProfileKeda_STATUS) AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileKeda_STATUS(destination *storage.ManagedClusterWorkloadAutoScalerProfileKeda_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if keda.Enabled != nil {
		enabled := *keda.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
type ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler struct {
	// AddonAutoscaling: Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.
	AddonAutoscaling *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling `json:"addonAutoscaling,omitempty"`

	// +kubebuilder:validation:Required
	// Enabled: Whether to enable VPA. Default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if autoscaler == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler{}

	// Set property "AddonAutoscaling":
	if autoscaler.AddonAutoscaling != nil {
		var temp string
		temp = string(*autoscaler.AddonAutoscaling)
		addonAutoscaling := arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling(temp)
		result.AddonAutoscaling = &addonAutoscaling
	}

	// Set property "Enabled":
	if autoscaler.Enabled != nil {
		enabled := *autoscaler.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler, got %T", armInput)
	}

	// Set property "AddonAutoscaling":
	if typedInput.AddonAutoscaling != nil {
		var temp string
		temp = string(*typedInput.AddonAutoscaling)
		addonAutoscaling := ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling(temp)
		autoscaler.AddonAutoscaling = &addonAutoscaling
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		autoscaler.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler populates our ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler from the provided source ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler(source *storage.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) error {

	// AddonAutoscaling
	if source.AddonAutoscaling != nil {
		addonAutoscaling := *source.AddonAutoscaling
		addonAutoscalingTemp := genruntime.ToEnum(addonAutoscaling, managedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_Values)
		autoscaler.AddonAutoscaling = &addonAutoscalingTemp
	} else {
		autoscaler.AddonAutoscaling = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		autoscaler.Enabled = &enabled
	} else {
		autoscaler.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler populates the provided destination ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler from our ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler(destination *storage.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AddonAutoscaling
	if autoscaler.AddonAutoscaling != nil {
		addonAutoscaling := string(*autoscaler.AddonAutoscaling)
		destination.AddonAutoscaling = &addonAutoscaling
	} else {
		destination.AddonAutoscaling = nil
	}

	// Enabled
	if autoscaler.Enabled != nil {
		enabled := *autoscaler.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
type ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS struct {
	// AddonAutoscaling: Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.
	AddonAutoscaling *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS `json:"addonAutoscaling,omitempty"`

	// Enabled: Whether to enable VPA. Default value is false.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS, got %T", armInput)
	}

	// Set property "AddonAutoscaling":
	if typedInput.AddonAutoscaling != nil {
		var temp string
		temp = string(*typedInput.AddonAutoscaling)
		addonAutoscaling := ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS(temp)
		autoscaler.AddonAutoscaling = &addonAutoscaling
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		autoscaler.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS populates our ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS from the provided source ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS) AssignProperties_From_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS(source *storage.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS) error {

	// AddonAutoscaling
	if source.AddonAutoscaling != nil {
		addonAutoscaling := *source.AddonAutoscaling
		addonAutoscalingTemp := genruntime.ToEnum(addonAutoscaling, managedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Values)
		autoscaler.AddonAutoscaling = &addonAutoscalingTemp
	} else {
		autoscaler.AddonAutoscaling = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		autoscaler.Enabled = &enabled
	} else {
		autoscaler.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS populates the provided destination ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS from our ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS
func (autoscaler *ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS) AssignProperties_To_ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS(destination *storage.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AddonAutoscaling
	if autoscaler.AddonAutoscaling != nil {
		addonAutoscaling := string(*autoscaler.AddonAutoscaling)
		destination.AddonAutoscaling = &addonAutoscaling
	} else {
		destination.AddonAutoscaling = nil
	}

	// Enabled
	if autoscaler.Enabled != nil {
		enabled := *autoscaler.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (value *ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (value *ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		value.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		value.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS populates our ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS from the provided source ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS
func (value *ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS) AssignProperties_From_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS(source *storage.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS) error {

	// ClientId
	value.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	value.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS populates the provided destination ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS from our ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS
func (value *ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS) AssignProperties_To_ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS(destination *storage.ManagedServiceIdentityUserAssignedIdentitiesValue_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(value.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(value.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network dataplane used in the Kubernetes cluster.
// +kubebuilder:validation:Enum={"azure","cilium"}
type NetworkDataplane string

const (
	NetworkDataplane_Azure  = NetworkDataplane("azure")
	NetworkDataplane_Cilium = NetworkDataplane("cilium")
)

// Mapping from string to NetworkDataplane
var networkDataplane_Values = map[string]NetworkDataplane{
	"azure":  NetworkDataplane_Azure,
	"cilium": NetworkDataplane_Cilium,
}

// Network dataplane used in the Kubernetes cluster.
type NetworkDataplane_STATUS string

const (
	NetworkDataplane_STATUS_Azure  = NetworkDataplane_STATUS("azure")
	NetworkDataplane_STATUS_Cilium = NetworkDataplane_STATUS("cilium")
)

// Mapping from string to NetworkDataplane_STATUS
var networkDataplane_STATUS_Values = map[string]NetworkDataplane_STATUS{
	"azure":  NetworkDataplane_STATUS_Azure,
	"cilium": NetworkDataplane_STATUS_Cilium,
}

// The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other than 'azure'.
// +kubebuilder:validation:Enum={"bridge","transparent"}
type NetworkMode string

const (
	NetworkMode_Bridge      = NetworkMode("bridge")
	NetworkMode_Transparent = NetworkMode("transparent")
)

// Mapping from string to NetworkMode
var networkMode_Values = map[string]NetworkMode{
	"bridge":      NetworkMode_Bridge,
	"transparent": NetworkMode_Transparent,
}

// The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other than 'azure'.
type NetworkMode_STATUS string

const (
	NetworkMode_STATUS_Bridge      = NetworkMode_STATUS("bridge")
	NetworkMode_STATUS_Transparent = NetworkMode_STATUS("transparent")
)

// Mapping from string to NetworkMode_STATUS
var networkMode_STATUS_Values = map[string]NetworkMode_STATUS{
	"bridge":      NetworkMode_STATUS_Bridge,
	"transparent": NetworkMode_STATUS_Transparent,
}

// Network plugin used for building the Kubernetes network.
// +kubebuilder:validation:Enum={"azure","kubenet","none"}
type NetworkPlugin string

const (
	NetworkPlugin_Azure   = NetworkPlugin("azure")
	NetworkPlugin_Kubenet = NetworkPlugin("kubenet")
	NetworkPlugin_None    = NetworkPlugin("none")
)

// Mapping from string to NetworkPlugin
var networkPlugin_Values = map[string]NetworkPlugin{
	"azure":   NetworkPlugin_Azure,
	"kubenet": NetworkPlugin_Kubenet,
	"none":    NetworkPlugin_None,
}

// Network plugin used for building the Kubernetes network.
type NetworkPlugin_STATUS string

const (
	NetworkPlugin_STATUS_Azure   = NetworkPlugin_STATUS("azure")
	NetworkPlugin_STATUS_Kubenet = NetworkPlugin_STATUS("kubenet")
	NetworkPlugin_STATUS_None    = NetworkPlugin_STATUS("none")
)

// Mapping from string to NetworkPlugin_STATUS
var networkPlugin_STATUS_Values = map[string]NetworkPlugin_STATUS{
	"azure":   NetworkPlugin_STATUS_Azure,
	"kubenet": NetworkPlugin_STATUS_Kubenet,
	"none":    NetworkPlugin_STATUS_None,
}

// The mode the network plugin should use.
// +kubebuilder:validation:Enum={"overlay"}
type NetworkPluginMode string

const NetworkPluginMode_Overlay = NetworkPluginMode("overlay")

// Mapping from string to NetworkPluginMode
var networkPluginMode_Values = map[string]NetworkPluginMode{
	"overlay": NetworkPluginMode_Overlay,
}

// The mode the network plugin should use.
type NetworkPluginMode_STATUS string

const NetworkPluginMode_STATUS_Overlay = NetworkPluginMode_STATUS("overlay")

// Mapping from string to NetworkPluginMode_STATUS
var networkPluginMode_STATUS_Values = map[string]NetworkPluginMode_STATUS{
	"overlay": NetworkPluginMode_STATUS_Overlay,
}

// Network policy used for building the Kubernetes network.
// +kubebuilder:validation:Enum={"azure","calico","cilium","none"}
type NetworkPolicy string

const (
	NetworkPolicy_Azure  = NetworkPolicy("azure")
	NetworkPolicy_Calico = NetworkPolicy("calico")
	NetworkPolicy_Cilium = NetworkPolicy("cilium")
	NetworkPolicy_None   = NetworkPolicy("none")
)

// Mapping from string to NetworkPolicy
var networkPolicy_Values = map[string]NetworkPolicy{
	"azure":  NetworkPolicy_Azure,
	"calico": NetworkPolicy_Calico,
	"cilium": NetworkPolicy_Cilium,
	"none":   NetworkPolicy_None,
}

// Network policy used for building the Kubernetes network.
type NetworkPolicy_STATUS string

const (
	NetworkPolicy_STATUS_Azure  = NetworkPolicy_STATUS("azure")
	NetworkPolicy_STATUS_Calico = NetworkPolicy_STATUS("calico")
	NetworkPolicy_STATUS_Cilium = NetworkPolicy_STATUS("cilium")
	NetworkPolicy_STATUS_None   = NetworkPolicy_STATUS("none")
)

// Mapping from string to NetworkPolicy_STATUS
var networkPolicy_STATUS_Values = map[string]NetworkPolicy_STATUS{
	"azure":  NetworkPolicy_STATUS_Azure,
	"calico": NetworkPolicy_STATUS_Calico,
	"cilium": NetworkPolicy_STATUS_Cilium,
	"none":   NetworkPolicy_STATUS_None,
}

// Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
// +kubebuilder:validation:Enum={"NodeImage","None","SecurityPatch","Unmanaged"}
type NodeOSUpgradeChannel string

const (
	NodeOSUpgradeChannel_NodeImage     = NodeOSUpgradeChannel("NodeImage")
	NodeOSUpgradeChannel_None          = NodeOSUpgradeChannel("None")
	NodeOSUpgradeChannel_SecurityPatch = NodeOSUpgradeChannel("SecurityPatch")
	NodeOSUpgradeChannel_Unmanaged     = NodeOSUpgradeChannel("Unmanaged")
)

// Mapping from string to NodeOSUpgradeChannel
var nodeOSUpgradeChannel_Values = map[string]NodeOSUpgradeChannel{
	"nodeimage":     NodeOSUpgradeChannel_NodeImage,
	"none":          NodeOSUpgradeChannel_None,
	"securitypatch": NodeOSUpgradeChannel_SecurityPatch,
	"unmanaged":     NodeOSUpgradeChannel_Unmanaged,
}

// Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
type NodeOSUpgradeChannel_STATUS string

const (
	NodeOSUpgradeChannel_STATUS_NodeImage     = NodeOSUpgradeChannel_STATUS("NodeImage")
	NodeOSUpgradeChannel_STATUS_None          = NodeOSUpgradeChannel_STATUS("None")
	NodeOSUpgradeChannel_STATUS_SecurityPatch = NodeOSUpgradeChannel_STATUS("SecurityPatch")
	NodeOSUpgradeChannel_STATUS_Unmanaged     = NodeOSUpgradeChannel_STATUS("Unmanaged")
)

// Mapping from string to NodeOSUpgradeChannel_STATUS
var nodeOSUpgradeChannel_STATUS_Values = map[string]NodeOSUpgradeChannel_STATUS{
	"nodeimage":     NodeOSUpgradeChannel_STATUS_NodeImage,
	"none":          NodeOSUpgradeChannel_STATUS_None,
	"securitypatch": NodeOSUpgradeChannel_STATUS_SecurityPatch,
	"unmanaged":     NodeOSUpgradeChannel_STATUS_Unmanaged,
}

// The node provisioning mode. If not specified, the default is Manual.
// +kubebuilder:validation:Enum={"Auto","Manual"}
type NodeProvisioningMode string

const (
	NodeProvisioningMode_Auto   = NodeProvisioningMode("Auto")
	NodeProvisioningMode_Manual = NodeProvisioningMode("Manual")
)

// Mapping from string to NodeProvisioningMode
var nodeProvisioningMode_Values = map[string]NodeProvisioningMode{
	"auto":   NodeProvisioningMode_Auto,
	"manual": NodeProvisioningMode_Manual,
}

// The node provisioning mode. If not specified, the default is Manual.
type NodeProvisioningMode_STATUS string

const (
	NodeProvisioningMode_STATUS_Auto   = NodeProvisioningMode_STATUS("Auto")
	NodeProvisioningMode_STATUS_Manual = NodeProvisioningMode_STATUS("Manual")
)

// Mapping from string to NodeProvisioningMode_STATUS
var nodeProvisioningMode_STATUS_Values = map[string]NodeProvisioningMode_STATUS{
	"auto":   NodeProvisioningMode_STATUS_Auto,
	"manual": NodeProvisioningMode_STATUS_Manual,
}

// Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods with
// hostNetwork=false. If not specified, the default is 'IMDS'.
// +kubebuilder:validation:Enum={"IMDS","None"}
type PodLinkLocalAccess string

const (
	PodLinkLocalAccess_IMDS = PodLinkLocalAccess("IMDS")
	PodLinkLocalAccess_None = PodLinkLocalAccess("None")
)

// Mapping from string to PodLinkLocalAccess
var podLinkLocalAccess_Values = map[string]PodLinkLocalAccess{
	"imds": PodLinkLocalAccess_IMDS,
	"none": PodLinkLocalAccess_None,
}

// Defines access to special link local addresses (Azure Instance Metadata Service, aka IMDS) for pods with
// hostNetwork=false. If not specified, the default is 'IMDS'.
type PodLinkLocalAccess_STATUS string

const (
	PodLinkLocalAccess_STATUS_IMDS = PodLinkLocalAccess_STATUS("IMDS")
	PodLinkLocalAccess_STATUS_None = PodLinkLocalAccess_STATUS("None")
)

// Mapping from string to PodLinkLocalAccess_STATUS
var podLinkLocalAccess_STATUS_Values = map[string]PodLinkLocalAccess_STATUS{
	"imds": PodLinkLocalAccess_STATUS_IMDS,
	"none": PodLinkLocalAccess_STATUS_None,
}

// The type of identity used for the managed cluster. For more information see [use managed identities in
// AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
// +kubebuilder:validation:Enum={"None","SystemAssigned","UserAssigned"}
type ResourceIdentityType string

const (
	ResourceIdentityType_None           = ResourceIdentityType("None")
	ResourceIdentityType_SystemAssigned = ResourceIdentityType("SystemAssigned")
	ResourceIdentityType_UserAssigned   = ResourceIdentityType("UserAssigned")
)

// Mapping from string to ResourceIdentityType
var resourceIdentityType_Values = map[string]ResourceIdentityType{
	"none":           ResourceIdentityType_None,
	"systemassigned": ResourceIdentityType_SystemAssigned,
	"userassigned":   ResourceIdentityType_UserAssigned,
}

// The type of identity used for the managed cluster. For more information see [use managed identities in
// AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
type ResourceIdentityType_STATUS string

const (
	ResourceIdentityType_STATUS_None           = ResourceIdentityType_STATUS("None")
	ResourceIdentityType_STATUS_SystemAssigned = ResourceIdentityType_STATUS("SystemAssigned")
	ResourceIdentityType_STATUS_UserAssigned   = ResourceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ResourceIdentityType_STATUS
var resourceIdentityType_STATUS_Values = map[string]ResourceIdentityType_STATUS{
	"none":           ResourceIdentityType_STATUS_None,
	"systemassigned": ResourceIdentityType_STATUS_SystemAssigned,
	"userassigned":   ResourceIdentityType_STATUS_UserAssigned,
}

// The restriction level applied to the cluster's node resource group. If not specified, the default is 'Unrestricted'
// +kubebuilder:validation:Enum={"ReadOnly","Unrestricted"}
type RestrictionLevel string

const (
	RestrictionLevel_ReadOnly     = RestrictionLevel("ReadOnly")
	RestrictionLevel_Unrestricted = RestrictionLevel("Unrestricted")
)

// Mapping from string to RestrictionLevel
var restrictionLevel_Values = map[string]RestrictionLevel{
	"readonly":     RestrictionLevel_ReadOnly,
	"unrestricted": RestrictionLevel_Unrestricted,
}

// The restriction level applied to the cluster's node resource group. If not specified, the default is 'Unrestricted'
type RestrictionLevel_STATUS string

const (
	RestrictionLevel_STATUS_ReadOnly     = RestrictionLevel_STATUS("ReadOnly")
	RestrictionLevel_STATUS_Unrestricted = RestrictionLevel_STATUS("Unrestricted")
)

// Mapping from string to RestrictionLevel_STATUS
var restrictionLevel_STATUS_Values = map[string]RestrictionLevel_STATUS{
	"readonly":     RestrictionLevel_STATUS_ReadOnly,
	"unrestricted": RestrictionLevel_STATUS_Unrestricted,
}

// Mapping of each scheduler instance to its profile.
type SchedulerProfileSchedulerInstanceProfiles struct {
	// Upstream: The scheduler profile for the upstream scheduler instance.
	Upstream *SchedulerInstanceProfile `json:"upstream,omitempty"`
}

var _ genruntime.ARMTransformer = &SchedulerProfileSchedulerInstanceProfiles{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profiles *SchedulerProfileSchedulerInstanceProfiles) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profiles == nil {
		return nil, nil
	}
	result := &arm.SchedulerProfileSchedulerInstanceProfiles{}

	// Set property "Upstream":
	if profiles.Upstream != nil {
		upstream_ARM, err := profiles.Upstream.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upstream := *upstream_ARM.(*arm.SchedulerInstanceProfile)
		result.Upstream = &upstream
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profiles *SchedulerProfileSchedulerInstanceProfiles) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SchedulerProfileSchedulerInstanceProfiles{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profiles *SchedulerProfileSchedulerInstanceProfiles) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SchedulerProfileSchedulerInstanceProfiles)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SchedulerProfileSchedulerInstanceProfiles, got %T", armInput)
	}

	// Set property "Upstream":
	if typedInput.Upstream != nil {
		var upstream1 SchedulerInstanceProfile
		err := upstream1.PopulateFromARM(owner, *typedInput.Upstream)
		if err != nil {
			return err
		}
		upstream := upstream1
		profiles.Upstream = &upstream
	}

	// No error
	return nil
}

// AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles populates our SchedulerProfileSchedulerInstanceProfiles from the provided source SchedulerProfileSchedulerInstanceProfiles
func (profiles *SchedulerProfileSchedulerInstanceProfiles) AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles(source *storage.SchedulerProfileSchedulerInstanceProfiles) error {

	// Upstream
	if source.Upstream != nil {
		var upstream SchedulerInstanceProfile
		err := upstream.AssignProperties_From_SchedulerInstanceProfile(source.Upstream)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SchedulerInstanceProfile() to populate field Upstream")
		}
		profiles.Upstream = &upstream
	} else {
		profiles.Upstream = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles populates the provided destination SchedulerProfileSchedulerInstanceProfiles from our SchedulerProfileSchedulerInstanceProfiles
func (profiles *SchedulerProfileSchedulerInstanceProfiles) AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles(destination *storage.SchedulerProfileSchedulerInstanceProfiles) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Upstream
	if profiles.Upstream != nil {
		var upstream storage.SchedulerInstanceProfile
		err := profiles.Upstream.AssignProperties_To_SchedulerInstanceProfile(&upstream)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SchedulerInstanceProfile() to populate field Upstream")
		}
		destination.Upstream = &upstream
	} else {
		destination.Upstream = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Mapping of each scheduler instance to its profile.
type SchedulerProfileSchedulerInstanceProfiles_STATUS struct {
	// Upstream: The scheduler profile for the upstream scheduler instance.
	Upstream *SchedulerInstanceProfile_STATUS `json:"upstream,omitempty"`
}

var _ genruntime.FromARMConverter = &SchedulerProfileSchedulerInstanceProfiles_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profiles *SchedulerProfileSchedulerInstanceProfiles_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SchedulerProfileSchedulerInstanceProfiles_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profiles *SchedulerProfileSchedulerInstanceProfiles_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SchedulerProfileSchedulerInstanceProfiles_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SchedulerProfileSchedulerInstanceProfiles_STATUS, got %T", armInput)
	}

	// Set property "Upstream":
	if typedInput.Upstream != nil {
		var upstream1 SchedulerInstanceProfile_STATUS
		err := upstream1.PopulateFromARM(owner, *typedInput.Upstream)
		if err != nil {
			return err
		}
		upstream := upstream1
		profiles.Upstream = &upstream
	}

	// No error
	return nil
}

// AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles_STATUS populates our SchedulerProfileSchedulerInstanceProfiles_STATUS from the provided source SchedulerProfileSchedulerInstanceProfiles_STATUS
func (profiles *SchedulerProfileSchedulerInstanceProfiles_STATUS) AssignProperties_From_SchedulerProfileSchedulerInstanceProfiles_STATUS(source *storage.SchedulerProfileSchedulerInstanceProfiles_STATUS) error {

	// Upstream
	if source.Upstream != nil {
		var upstream SchedulerInstanceProfile_STATUS
		err := upstream.AssignProperties_From_SchedulerInstanceProfile_STATUS(source.Upstream)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SchedulerInstanceProfile_STATUS() to populate field Upstream")
		}
		profiles.Upstream = &upstream
	} else {
		profiles.Upstream = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles_STATUS populates the provided destination SchedulerProfileSchedulerInstanceProfiles_STATUS from our SchedulerProfileSchedulerInstanceProfiles_STATUS
func (profiles *SchedulerProfileSchedulerInstanceProfiles_STATUS) AssignProperties_To_SchedulerProfileSchedulerInstanceProfiles_STATUS(destination *storage.SchedulerProfileSchedulerInstanceProfiles_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Upstream
	if profiles.Upstream != nil {
		var upstream storage.SchedulerInstanceProfile_STATUS
		err := profiles.Upstream.AssignProperties_To_SchedulerInstanceProfile_STATUS(&upstream)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SchedulerInstanceProfile_STATUS() to populate field Upstream")
		}
		destination.Upstream = &upstream
	} else {
		destination.Upstream = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Mode of the service mesh.
// +kubebuilder:validation:Enum={"Disabled","Istio"}
type ServiceMeshMode string

const (
	ServiceMeshMode_Disabled = ServiceMeshMode("Disabled")
	ServiceMeshMode_Istio    = ServiceMeshMode("Istio")
)

// Mapping from string to ServiceMeshMode
var serviceMeshMode_Values = map[string]ServiceMeshMode{
	"disabled": ServiceMeshMode_Disabled,
	"istio":    ServiceMeshMode_Istio,
}

// Mode of the service mesh.
type ServiceMeshMode_STATUS string

const (
	ServiceMeshMode_STATUS_Disabled = ServiceMeshMode_STATUS("Disabled")
	ServiceMeshMode_STATUS_Istio    = ServiceMeshMode_STATUS("Istio")
)

// Mapping from string to ServiceMeshMode_STATUS
var serviceMeshMode_STATUS_Values = map[string]ServiceMeshMode_STATUS{
	"disabled": ServiceMeshMode_STATUS_Disabled,
	"istio":    ServiceMeshMode_STATUS_Istio,
}

// The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS cluster
// auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
// +kubebuilder:validation:Enum={"node-image","none","patch","rapid","stable"}
type UpgradeChannel string

const (
	UpgradeChannel_NodeImage = UpgradeChannel("node-image")
	UpgradeChannel_None      = UpgradeChannel("none")
	UpgradeChannel_Patch     = UpgradeChannel("patch")
	UpgradeChannel_Rapid     = UpgradeChannel("rapid")
	UpgradeChannel_Stable    = UpgradeChannel("stable")
)

// Mapping from string to UpgradeChannel
var upgradeChannel_Values = map[string]UpgradeChannel{
	"node-image": UpgradeChannel_NodeImage,
	"none":       UpgradeChannel_None,
	"patch":      UpgradeChannel_Patch,
	"rapid":      UpgradeChannel_Rapid,
	"stable":     UpgradeChannel_Stable,
}

// The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS cluster
// auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
type UpgradeChannel_STATUS string

const (
	UpgradeChannel_STATUS_NodeImage = UpgradeChannel_STATUS("node-image")
	UpgradeChannel_STATUS_None      = UpgradeChannel_STATUS("none")
	UpgradeChannel_STATUS_Patch     = UpgradeChannel_STATUS("patch")
	UpgradeChannel_STATUS_Rapid     = UpgradeChannel_STATUS("rapid")
	UpgradeChannel_STATUS_Stable    = UpgradeChannel_STATUS("stable")
)

// Mapping from string to UpgradeChannel_STATUS
var upgradeChannel_STATUS_Values = map[string]UpgradeChannel_STATUS{
	"node-image": UpgradeChannel_STATUS_NodeImage,
	"none":       UpgradeChannel_STATUS_None,
	"patch":      UpgradeChannel_STATUS_Patch,
	"rapid":      UpgradeChannel_STATUS_Rapid,
	"stable":     UpgradeChannel_STATUS_Stable,
}

// Settings for overrides when upgrading a cluster.
type UpgradeOverrideSettings struct {
	// ForceUpgrade: Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade
	// protections such as checking for deprecated API usage. Enable this option only with caution.
	ForceUpgrade *bool `json:"forceUpgrade,omitempty"`

	// Until: Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the
	// effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set
	// by default. It must be set for the overrides to take effect.
	Until *string `json:"until,omitempty"`
}

var _ genruntime.ARMTransformer = &UpgradeOverrideSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *UpgradeOverrideSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.UpgradeOverrideSettings{}

	// Set property "ForceUpgrade":
	if settings.ForceUpgrade != nil {
		forceUpgrade := *settings.ForceUpgrade
		result.ForceUpgrade = &forceUpgrade
	}

	// Set property "Until":
	if settings.Until != nil {
		until := *settings.Until
		result.Until = &until
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *UpgradeOverrideSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UpgradeOverrideSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *UpgradeOverrideSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UpgradeOverrideSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UpgradeOverrideSettings, got %T", armInput)
	}

	// Set property "ForceUpgrade":
	if typedInput.ForceUpgrade != nil {
		forceUpgrade := *typedInput.ForceUpgrade
		settings.ForceUpgrade = &forceUpgrade
	}

	// Set property "Until":
	if typedInput.Until != nil {
		until := *typedInput.Until
		settings.Until = &until
	}

	// No error
	return nil
}

// AssignProperties_From_UpgradeOverrideSettings populates our UpgradeOverrideSettings from the provided source UpgradeOverrideSettings
func (settings *UpgradeOverrideSettings) AssignProperties_From_UpgradeOverrideSettings(source *storage.UpgradeOverrideSettings) error {

	// ForceUpgrade
	if source.ForceUpgrade != nil {
		forceUpgrade := *source.ForceUpgrade
		settings.ForceUpgrade = &forceUpgrade
	} else {
		settings.ForceUpgrade = nil
	}

	// Until
	settings.Until = genruntime.ClonePointerToString(source.Until)

	// No error
	return nil
}

// AssignProperties_To_UpgradeOverrideSettings populates the provided destination UpgradeOverrideSettings from our UpgradeOverrideSettings
func (settings *UpgradeOverrideSettings) AssignProperties_To_UpgradeOverrideSettings(destination *storage.UpgradeOverrideSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForceUpgrade
	if settings.ForceUpgrade != nil {
		forceUpgrade := *settings.ForceUpgrade
		destination.ForceUpgrade = &forceUpgrade
	} else {
		destination.ForceUpgrade = nil
	}

	// Until
	destination.Until = genruntime.ClonePointerToString(settings.Until)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for overrides when upgrading a cluster.
type UpgradeOverrideSettings_STATUS struct {
	// ForceUpgrade: Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade
	// protections such as checking for deprecated API usage. Enable this option only with caution.
	ForceUpgrade *bool `json:"forceUpgrade,omitempty"`

	// Until: Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the
	// effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set
	// by default. It must be set for the overrides to take effect.
	Until *string `json:"until,omitempty"`
}

var _ genruntime.FromARMConverter = &UpgradeOverrideSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *UpgradeOverrideSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UpgradeOverrideSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *UpgradeOverrideSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UpgradeOverrideSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UpgradeOverrideSettings_STATUS, got %T", armInput)
	}

	// Set property "ForceUpgrade":
	if typedInput.ForceUpgrade != nil {
		forceUpgrade := *typedInput.ForceUpgrade
		settings.ForceUpgrade = &forceUpgrade
	}

	// Set property "Until":
	if typedInput.Until != nil {
		until := *typedInput.Until
		settings.Until = &until
	}

	// No error
	return nil
}

// AssignProperties_From_UpgradeOverrideSettings_STATUS populates our UpgradeOverrideSettings_STATUS from the provided source UpgradeOverrideSettings_STATUS
func (settings *UpgradeOverrideSettings_STATUS) AssignProperties_From_UpgradeOverrideSettings_STATUS(source *storage.UpgradeOverrideSettings_STATUS) error {

	// ForceUpgrade
	if source.ForceUpgrade != nil {
		forceUpgrade := *source.ForceUpgrade
		settings.ForceUpgrade = &forceUpgrade
	} else {
		settings.ForceUpgrade = nil
	}

	// Until
	settings.Until = genruntime.ClonePointerToString(source.Until)

	// No error
	return nil
}

// AssignProperties_To_UpgradeOverrideSettings_STATUS populates the provided destination UpgradeOverrideSettings_STATUS from our UpgradeOverrideSettings_STATUS
func (settings *UpgradeOverrideSettings_STATUS) AssignProperties_To_UpgradeOverrideSettings_STATUS(destination *storage.UpgradeOverrideSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForceUpgrade
	if settings.ForceUpgrade != nil {
		forceUpgrade := *settings.ForceUpgrade
		destination.ForceUpgrade = &forceUpgrade
	} else {
		destination.ForceUpgrade = nil
	}

	// Until
	destination.Until = genruntime.ClonePointerToString(settings.Until)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Windows gMSA Profile in the managed cluster.
type WindowsGmsaProfile struct {
	// DnsServer: Specifies the DNS server for Windows gMSA.
	// Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
	DnsServer *string `json:"dnsServer,omitempty"`

	// Enabled: Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the managed cluster.
	Enabled *bool `json:"enabled,omitempty"`

	// RootDomainName: Specifies the root domain name for Windows gMSA.
	// Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
	RootDomainName *string `json:"rootDomainName,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsGmsaProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *WindowsGmsaProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.WindowsGmsaProfile{}

	// Set property "DnsServer":
	if profile.DnsServer != nil {
		dnsServer := *profile.DnsServer
		result.DnsServer = &dnsServer
	}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}

	// Set property "RootDomainName":
	if profile.RootDomainName != nil {
		rootDomainName := *profile.RootDomainName
		result.RootDomainName = &rootDomainName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *WindowsGmsaProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsGmsaProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *WindowsGmsaProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsGmsaProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsGmsaProfile, got %T", armInput)
	}

	// Set property "DnsServer":
	if typedInput.DnsServer != nil {
		dnsServer := *typedInput.DnsServer
		profile.DnsServer = &dnsServer
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "RootDomainName":
	if typedInput.RootDomainName != nil {
		rootDomainName := *typedInput.RootDomainName
		profile.RootDomainName = &rootDomainName
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsGmsaProfile populates our WindowsGmsaProfile from the provided source WindowsGmsaProfile
func (profile *WindowsGmsaProfile) AssignProperties_From_WindowsGmsaProfile(source *storage.WindowsGmsaProfile) error {

	// DnsServer
	profile.DnsServer = genruntime.ClonePointerToString(source.DnsServer)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// RootDomainName
	profile.RootDomainName = genruntime.ClonePointerToString(source.RootDomainName)

	// No error
	return nil
}

// AssignProperties_To_WindowsGmsaProfile populates the provided destination WindowsGmsaProfile from our WindowsGmsaProfile
func (profile *WindowsGmsaProfile) AssignProperties_To_WindowsGmsaProfile(destination *storage.WindowsGmsaProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServer
	destination.DnsServer = genruntime.ClonePointerToString(profile.DnsServer)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RootDomainName
	destination.RootDomainName = genruntime.ClonePointerToString(profile.RootDomainName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Windows gMSA Profile in the managed cluster.
type WindowsGmsaProfile_STATUS struct {
	// DnsServer: Specifies the DNS server for Windows gMSA.
	// Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
	DnsServer *string `json:"dnsServer,omitempty"`

	// Enabled: Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the managed cluster.
	Enabled *bool `json:"enabled,omitempty"`

	// RootDomainName: Specifies the root domain name for Windows gMSA.
	// Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
	RootDomainName *string `json:"rootDomainName,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsGmsaProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *WindowsGmsaProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsGmsaProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *WindowsGmsaProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsGmsaProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsGmsaProfile_STATUS, got %T", armInput)
	}

	// Set property "DnsServer":
	if typedInput.DnsServer != nil {
		dnsServer := *typedInput.DnsServer
		profile.DnsServer = &dnsServer
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// Set property "RootDomainName":
	if typedInput.RootDomainName != nil {
		rootDomainName := *typedInput.RootDomainName
		profile.RootDomainName = &rootDomainName
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsGmsaProfile_STATUS populates our WindowsGmsaProfile_STATUS from the provided source WindowsGmsaProfile_STATUS
func (profile *WindowsGmsaProfile_STATUS) AssignProperties_From_WindowsGmsaProfile_STATUS(source *storage.WindowsGmsaProfile_STATUS) error {

	// DnsServer
	profile.DnsServer = genruntime.ClonePointerToString(source.DnsServer)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// RootDomainName
	profile.RootDomainName = genruntime.ClonePointerToString(source.RootDomainName)

	// No error
	return nil
}

// AssignProperties_To_WindowsGmsaProfile_STATUS populates the provided destination WindowsGmsaProfile_STATUS from our WindowsGmsaProfile_STATUS
func (profile *WindowsGmsaProfile_STATUS) AssignProperties_To_WindowsGmsaProfile_STATUS(destination *storage.WindowsGmsaProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServer
	destination.DnsServer = genruntime.ClonePointerToString(profile.DnsServer)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RootDomainName
	destination.RootDomainName = genruntime.ClonePointerToString(profile.RootDomainName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Observability profile to enable advanced network metrics and flow logs with historical contexts.
type AdvancedNetworkingObservability struct {
	// Enabled: Indicates the enablement of Advanced Networking observability functionalities on clusters.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AdvancedNetworkingObservability{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (observability *AdvancedNetworkingObservability) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if observability == nil {
		return nil, nil
	}
	result := &arm.AdvancedNetworkingObservability{}

	// Set property "Enabled":
	if observability.Enabled != nil {
		enabled := *observability.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (observability *AdvancedNetworkingObservability) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingObservability{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (observability *AdvancedNetworkingObservability) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingObservability)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingObservability, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		observability.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingObservability populates our AdvancedNetworkingObservability from the provided source AdvancedNetworkingObservability
func (observability *AdvancedNetworkingObservability) AssignProperties_From_AdvancedNetworkingObservability(source *storage.AdvancedNetworkingObservability) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		observability.Enabled = &enabled
	} else {
		observability.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingObservability populates the provided destination AdvancedNetworkingObservability from our AdvancedNetworkingObservability
func (observability *AdvancedNetworkingObservability) AssignProperties_To_AdvancedNetworkingObservability(destination *storage.AdvancedNetworkingObservability) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if observability.Enabled != nil {
		enabled := *observability.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Observability profile to enable advanced network metrics and flow logs with historical contexts.
type AdvancedNetworkingObservability_STATUS struct {
	// Enabled: Indicates the enablement of Advanced Networking observability functionalities on clusters.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AdvancedNetworkingObservability_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (observability *AdvancedNetworkingObservability_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingObservability_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (observability *AdvancedNetworkingObservability_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingObservability_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingObservability_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		observability.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingObservability_STATUS populates our AdvancedNetworkingObservability_STATUS from the provided source AdvancedNetworkingObservability_STATUS
func (observability *AdvancedNetworkingObservability_STATUS) AssignProperties_From_AdvancedNetworkingObservability_STATUS(source *storage.AdvancedNetworkingObservability_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		observability.Enabled = &enabled
	} else {
		observability.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingObservability_STATUS populates the provided destination AdvancedNetworkingObservability_STATUS from our AdvancedNetworkingObservability_STATUS
func (observability *AdvancedNetworkingObservability_STATUS) AssignProperties_To_AdvancedNetworkingObservability_STATUS(destination *storage.AdvancedNetworkingObservability_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if observability.Enabled != nil {
		enabled := *observability.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile to enable performance-enhancing features on clusters that use Azure CNI powered by Cilium.
type AdvancedNetworkingPerformance struct {
	// AccelerationMode: Enable advanced network acceleration options. This allows users to configure acceleration using BPF
	// host routing. This can be enabled only with Cilium dataplane. If not specified, the default value is None (no
	// acceleration). The acceleration mode can be changed on a pre-existing cluster. See https://aka.ms/acnsperformance for a
	// detailed explanation
	AccelerationMode *AdvancedNetworkingPerformance_AccelerationMode `json:"accelerationMode,omitempty"`
}

var _ genruntime.ARMTransformer = &AdvancedNetworkingPerformance{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (performance *AdvancedNetworkingPerformance) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if performance == nil {
		return nil, nil
	}
	result := &arm.AdvancedNetworkingPerformance{}

	// Set property "AccelerationMode":
	if performance.AccelerationMode != nil {
		var temp string
		temp = string(*performance.AccelerationMode)
		accelerationMode := arm.AdvancedNetworkingPerformance_AccelerationMode(temp)
		result.AccelerationMode = &accelerationMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (performance *AdvancedNetworkingPerformance) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingPerformance{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (performance *AdvancedNetworkingPerformance) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingPerformance)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingPerformance, got %T", armInput)
	}

	// Set property "AccelerationMode":
	if typedInput.AccelerationMode != nil {
		var temp string
		temp = string(*typedInput.AccelerationMode)
		accelerationMode := AdvancedNetworkingPerformance_AccelerationMode(temp)
		performance.AccelerationMode = &accelerationMode
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingPerformance populates our AdvancedNetworkingPerformance from the provided source AdvancedNetworkingPerformance
func (performance *AdvancedNetworkingPerformance) AssignProperties_From_AdvancedNetworkingPerformance(source *storage.AdvancedNetworkingPerformance) error {

	// AccelerationMode
	if source.AccelerationMode != nil {
		accelerationMode := *source.AccelerationMode
		accelerationModeTemp := genruntime.ToEnum(accelerationMode, advancedNetworkingPerformance_AccelerationMode_Values)
		performance.AccelerationMode = &accelerationModeTemp
	} else {
		performance.AccelerationMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingPerformance populates the provided destination AdvancedNetworkingPerformance from our AdvancedNetworkingPerformance
func (performance *AdvancedNetworkingPerformance) AssignProperties_To_AdvancedNetworkingPerformance(destination *storage.AdvancedNetworkingPerformance) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccelerationMode
	if performance.AccelerationMode != nil {
		accelerationMode := string(*performance.AccelerationMode)
		destination.AccelerationMode = &accelerationMode
	} else {
		destination.AccelerationMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile to enable performance-enhancing features on clusters that use Azure CNI powered by Cilium.
type AdvancedNetworkingPerformance_STATUS struct {
	// AccelerationMode: Enable advanced network acceleration options. This allows users to configure acceleration using BPF
	// host routing. This can be enabled only with Cilium dataplane. If not specified, the default value is None (no
	// acceleration). The acceleration mode can be changed on a pre-existing cluster. See https://aka.ms/acnsperformance for a
	// detailed explanation
	AccelerationMode *AdvancedNetworkingPerformance_AccelerationMode_STATUS `json:"accelerationMode,omitempty"`
}

var _ genruntime.FromARMConverter = &AdvancedNetworkingPerformance_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (performance *AdvancedNetworkingPerformance_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingPerformance_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (performance *AdvancedNetworkingPerformance_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingPerformance_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingPerformance_STATUS, got %T", armInput)
	}

	// Set property "AccelerationMode":
	if typedInput.AccelerationMode != nil {
		var temp string
		temp = string(*typedInput.AccelerationMode)
		accelerationMode := AdvancedNetworkingPerformance_AccelerationMode_STATUS(temp)
		performance.AccelerationMode = &accelerationMode
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingPerformance_STATUS populates our AdvancedNetworkingPerformance_STATUS from the provided source AdvancedNetworkingPerformance_STATUS
func (performance *AdvancedNetworkingPerformance_STATUS) AssignProperties_From_AdvancedNetworkingPerformance_STATUS(source *storage.AdvancedNetworkingPerformance_STATUS) error {

	// AccelerationMode
	if source.AccelerationMode != nil {
		accelerationMode := *source.AccelerationMode
		accelerationModeTemp := genruntime.ToEnum(accelerationMode, advancedNetworkingPerformance_AccelerationMode_STATUS_Values)
		performance.AccelerationMode = &accelerationModeTemp
	} else {
		performance.AccelerationMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingPerformance_STATUS populates the provided destination AdvancedNetworkingPerformance_STATUS from our AdvancedNetworkingPerformance_STATUS
func (performance *AdvancedNetworkingPerformance_STATUS) AssignProperties_To_AdvancedNetworkingPerformance_STATUS(destination *storage.AdvancedNetworkingPerformance_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccelerationMode
	if performance.AccelerationMode != nil {
		accelerationMode := string(*performance.AccelerationMode)
		destination.AccelerationMode = &accelerationMode
	} else {
		destination.AccelerationMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Security profile to enable security features on cilium based cluster.
type AdvancedNetworkingSecurity struct {
	// AdvancedNetworkPolicies: Enable advanced network policies. This allows users to configure Layer 7 network policies
	// (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see
	// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
	// specified, the default value is FQDN if security.enabled is set to true.
	AdvancedNetworkPolicies *AdvancedNetworkPolicies `json:"advancedNetworkPolicies,omitempty"`

	// Enabled: This feature allows user to configure network policy based on DNS (FQDN) names. It can be enabled only on
	// cilium based clusters. If not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// TransitEncryption: Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium managed
	// pods will be encrypted when it leaves the node boundary.
	TransitEncryption *AdvancedNetworkingSecurityTransitEncryption `json:"transitEncryption,omitempty"`
}

var _ genruntime.ARMTransformer = &AdvancedNetworkingSecurity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (security *AdvancedNetworkingSecurity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if security == nil {
		return nil, nil
	}
	result := &arm.AdvancedNetworkingSecurity{}

	// Set property "AdvancedNetworkPolicies":
	if security.AdvancedNetworkPolicies != nil {
		var temp string
		temp = string(*security.AdvancedNetworkPolicies)
		advancedNetworkPolicies := arm.AdvancedNetworkPolicies(temp)
		result.AdvancedNetworkPolicies = &advancedNetworkPolicies
	}

	// Set property "Enabled":
	if security.Enabled != nil {
		enabled := *security.Enabled
		result.Enabled = &enabled
	}

	// Set property "TransitEncryption":
	if security.TransitEncryption != nil {
		transitEncryption_ARM, err := security.TransitEncryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		transitEncryption := *transitEncryption_ARM.(*arm.AdvancedNetworkingSecurityTransitEncryption)
		result.TransitEncryption = &transitEncryption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (security *AdvancedNetworkingSecurity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingSecurity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (security *AdvancedNetworkingSecurity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingSecurity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingSecurity, got %T", armInput)
	}

	// Set property "AdvancedNetworkPolicies":
	if typedInput.AdvancedNetworkPolicies != nil {
		var temp string
		temp = string(*typedInput.AdvancedNetworkPolicies)
		advancedNetworkPolicies := AdvancedNetworkPolicies(temp)
		security.AdvancedNetworkPolicies = &advancedNetworkPolicies
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		security.Enabled = &enabled
	}

	// Set property "TransitEncryption":
	if typedInput.TransitEncryption != nil {
		var transitEncryption1 AdvancedNetworkingSecurityTransitEncryption
		err := transitEncryption1.PopulateFromARM(owner, *typedInput.TransitEncryption)
		if err != nil {
			return err
		}
		transitEncryption := transitEncryption1
		security.TransitEncryption = &transitEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingSecurity populates our AdvancedNetworkingSecurity from the provided source AdvancedNetworkingSecurity
func (security *AdvancedNetworkingSecurity) AssignProperties_From_AdvancedNetworkingSecurity(source *storage.AdvancedNetworkingSecurity) error {

	// AdvancedNetworkPolicies
	if source.AdvancedNetworkPolicies != nil {
		advancedNetworkPolicy := *source.AdvancedNetworkPolicies
		advancedNetworkPolicyTemp := genruntime.ToEnum(advancedNetworkPolicy, advancedNetworkPolicies_Values)
		security.AdvancedNetworkPolicies = &advancedNetworkPolicyTemp
	} else {
		security.AdvancedNetworkPolicies = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		security.Enabled = &enabled
	} else {
		security.Enabled = nil
	}

	// TransitEncryption
	if source.TransitEncryption != nil {
		var transitEncryption AdvancedNetworkingSecurityTransitEncryption
		err := transitEncryption.AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption(source.TransitEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption() to populate field TransitEncryption")
		}
		security.TransitEncryption = &transitEncryption
	} else {
		security.TransitEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingSecurity populates the provided destination AdvancedNetworkingSecurity from our AdvancedNetworkingSecurity
func (security *AdvancedNetworkingSecurity) AssignProperties_To_AdvancedNetworkingSecurity(destination *storage.AdvancedNetworkingSecurity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdvancedNetworkPolicies
	if security.AdvancedNetworkPolicies != nil {
		advancedNetworkPolicy := string(*security.AdvancedNetworkPolicies)
		destination.AdvancedNetworkPolicies = &advancedNetworkPolicy
	} else {
		destination.AdvancedNetworkPolicies = nil
	}

	// Enabled
	if security.Enabled != nil {
		enabled := *security.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TransitEncryption
	if security.TransitEncryption != nil {
		var transitEncryption storage.AdvancedNetworkingSecurityTransitEncryption
		err := security.TransitEncryption.AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption(&transitEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption() to populate field TransitEncryption")
		}
		destination.TransitEncryption = &transitEncryption
	} else {
		destination.TransitEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Security profile to enable security features on cilium based cluster.
type AdvancedNetworkingSecurity_STATUS struct {
	// AdvancedNetworkPolicies: Enable advanced network policies. This allows users to configure Layer 7 network policies
	// (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see
	// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
	// specified, the default value is FQDN if security.enabled is set to true.
	AdvancedNetworkPolicies *AdvancedNetworkPolicies_STATUS `json:"advancedNetworkPolicies,omitempty"`

	// Enabled: This feature allows user to configure network policy based on DNS (FQDN) names. It can be enabled only on
	// cilium based clusters. If not specified, the default is false.
	Enabled *bool `json:"enabled,omitempty"`

	// TransitEncryption: Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium managed
	// pods will be encrypted when it leaves the node boundary.
	TransitEncryption *AdvancedNetworkingSecurityTransitEncryption_STATUS `json:"transitEncryption,omitempty"`
}

var _ genruntime.FromARMConverter = &AdvancedNetworkingSecurity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (security *AdvancedNetworkingSecurity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingSecurity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (security *AdvancedNetworkingSecurity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingSecurity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingSecurity_STATUS, got %T", armInput)
	}

	// Set property "AdvancedNetworkPolicies":
	if typedInput.AdvancedNetworkPolicies != nil {
		var temp string
		temp = string(*typedInput.AdvancedNetworkPolicies)
		advancedNetworkPolicies := AdvancedNetworkPolicies_STATUS(temp)
		security.AdvancedNetworkPolicies = &advancedNetworkPolicies
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		security.Enabled = &enabled
	}

	// Set property "TransitEncryption":
	if typedInput.TransitEncryption != nil {
		var transitEncryption1 AdvancedNetworkingSecurityTransitEncryption_STATUS
		err := transitEncryption1.PopulateFromARM(owner, *typedInput.TransitEncryption)
		if err != nil {
			return err
		}
		transitEncryption := transitEncryption1
		security.TransitEncryption = &transitEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingSecurity_STATUS populates our AdvancedNetworkingSecurity_STATUS from the provided source AdvancedNetworkingSecurity_STATUS
func (security *AdvancedNetworkingSecurity_STATUS) AssignProperties_From_AdvancedNetworkingSecurity_STATUS(source *storage.AdvancedNetworkingSecurity_STATUS) error {

	// AdvancedNetworkPolicies
	if source.AdvancedNetworkPolicies != nil {
		advancedNetworkPolicy := *source.AdvancedNetworkPolicies
		advancedNetworkPolicyTemp := genruntime.ToEnum(advancedNetworkPolicy, advancedNetworkPolicies_STATUS_Values)
		security.AdvancedNetworkPolicies = &advancedNetworkPolicyTemp
	} else {
		security.AdvancedNetworkPolicies = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		security.Enabled = &enabled
	} else {
		security.Enabled = nil
	}

	// TransitEncryption
	if source.TransitEncryption != nil {
		var transitEncryption AdvancedNetworkingSecurityTransitEncryption_STATUS
		err := transitEncryption.AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption_STATUS(source.TransitEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption_STATUS() to populate field TransitEncryption")
		}
		security.TransitEncryption = &transitEncryption
	} else {
		security.TransitEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingSecurity_STATUS populates the provided destination AdvancedNetworkingSecurity_STATUS from our AdvancedNetworkingSecurity_STATUS
func (security *AdvancedNetworkingSecurity_STATUS) AssignProperties_To_AdvancedNetworkingSecurity_STATUS(destination *storage.AdvancedNetworkingSecurity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdvancedNetworkPolicies
	if security.AdvancedNetworkPolicies != nil {
		advancedNetworkPolicy := string(*security.AdvancedNetworkPolicies)
		destination.AdvancedNetworkPolicies = &advancedNetworkPolicy
	} else {
		destination.AdvancedNetworkPolicies = nil
	}

	// Enabled
	if security.Enabled != nil {
		enabled := *security.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// TransitEncryption
	if security.TransitEncryption != nil {
		var transitEncryption storage.AdvancedNetworkingSecurityTransitEncryption_STATUS
		err := security.TransitEncryption.AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption_STATUS(&transitEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption_STATUS() to populate field TransitEncryption")
		}
		destination.TransitEncryption = &transitEncryption
	} else {
		destination.TransitEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Private","Public"}
type AzureKeyVaultKms_KeyVaultNetworkAccess string

const (
	AzureKeyVaultKms_KeyVaultNetworkAccess_Private = AzureKeyVaultKms_KeyVaultNetworkAccess("Private")
	AzureKeyVaultKms_KeyVaultNetworkAccess_Public  = AzureKeyVaultKms_KeyVaultNetworkAccess("Public")
)

// Mapping from string to AzureKeyVaultKms_KeyVaultNetworkAccess
var azureKeyVaultKms_KeyVaultNetworkAccess_Values = map[string]AzureKeyVaultKms_KeyVaultNetworkAccess{
	"private": AzureKeyVaultKms_KeyVaultNetworkAccess_Private,
	"public":  AzureKeyVaultKms_KeyVaultNetworkAccess_Public,
}

type AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS string

const (
	AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Private = AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS("Private")
	AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Public  = AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS("Public")
)

// Mapping from string to AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS
var azureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Values = map[string]AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS{
	"private": AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Private,
	"public":  AzureKeyVaultKms_KeyVaultNetworkAccess_STATUS_Public,
}

// Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.
type ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig struct {
	// Scheduler: IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
	Scheduler *IpvsScheduler `json:"scheduler,omitempty"`

	// TcpFinTimeoutSeconds: The timeout value used for IPVS TCP sessions after receiving a FIN in seconds. Must be a positive
	// integer value.
	TcpFinTimeoutSeconds *int `json:"tcpFinTimeoutSeconds,omitempty"`

	// TcpTimeoutSeconds: The timeout value used for idle IPVS TCP sessions in seconds. Must be a positive integer value.
	TcpTimeoutSeconds *int `json:"tcpTimeoutSeconds,omitempty"`

	// UdpTimeoutSeconds: The timeout value used for IPVS UDP packets in seconds. Must be a positive integer value.
	UdpTimeoutSeconds *int `json:"udpTimeoutSeconds,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig{}

	// Set property "Scheduler":
	if config.Scheduler != nil {
		var temp string
		temp = string(*config.Scheduler)
		scheduler := arm.IpvsScheduler(temp)
		result.Scheduler = &scheduler
	}

	// Set property "TcpFinTimeoutSeconds":
	if config.TcpFinTimeoutSeconds != nil {
		tcpFinTimeoutSeconds := *config.TcpFinTimeoutSeconds
		result.TcpFinTimeoutSeconds = &tcpFinTimeoutSeconds
	}

	// Set property "TcpTimeoutSeconds":
	if config.TcpTimeoutSeconds != nil {
		tcpTimeoutSeconds := *config.TcpTimeoutSeconds
		result.TcpTimeoutSeconds = &tcpTimeoutSeconds
	}

	// Set property "UdpTimeoutSeconds":
	if config.UdpTimeoutSeconds != nil {
		udpTimeoutSeconds := *config.UdpTimeoutSeconds
		result.UdpTimeoutSeconds = &udpTimeoutSeconds
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig, got %T", armInput)
	}

	// Set property "Scheduler":
	if typedInput.Scheduler != nil {
		var temp string
		temp = string(*typedInput.Scheduler)
		scheduler := IpvsScheduler(temp)
		config.Scheduler = &scheduler
	}

	// Set property "TcpFinTimeoutSeconds":
	if typedInput.TcpFinTimeoutSeconds != nil {
		tcpFinTimeoutSeconds := *typedInput.TcpFinTimeoutSeconds
		config.TcpFinTimeoutSeconds = &tcpFinTimeoutSeconds
	}

	// Set property "TcpTimeoutSeconds":
	if typedInput.TcpTimeoutSeconds != nil {
		tcpTimeoutSeconds := *typedInput.TcpTimeoutSeconds
		config.TcpTimeoutSeconds = &tcpTimeoutSeconds
	}

	// Set property "UdpTimeoutSeconds":
	if typedInput.UdpTimeoutSeconds != nil {
		udpTimeoutSeconds := *typedInput.UdpTimeoutSeconds
		config.UdpTimeoutSeconds = &udpTimeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig populates our ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig from the provided source ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig(source *storage.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) error {

	// Scheduler
	if source.Scheduler != nil {
		scheduler := *source.Scheduler
		schedulerTemp := genruntime.ToEnum(scheduler, ipvsScheduler_Values)
		config.Scheduler = &schedulerTemp
	} else {
		config.Scheduler = nil
	}

	// TcpFinTimeoutSeconds
	config.TcpFinTimeoutSeconds = genruntime.ClonePointerToInt(source.TcpFinTimeoutSeconds)

	// TcpTimeoutSeconds
	config.TcpTimeoutSeconds = genruntime.ClonePointerToInt(source.TcpTimeoutSeconds)

	// UdpTimeoutSeconds
	config.UdpTimeoutSeconds = genruntime.ClonePointerToInt(source.UdpTimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig populates the provided destination ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig from our ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig(destination *storage.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scheduler
	if config.Scheduler != nil {
		scheduler := string(*config.Scheduler)
		destination.Scheduler = &scheduler
	} else {
		destination.Scheduler = nil
	}

	// TcpFinTimeoutSeconds
	destination.TcpFinTimeoutSeconds = genruntime.ClonePointerToInt(config.TcpFinTimeoutSeconds)

	// TcpTimeoutSeconds
	destination.TcpTimeoutSeconds = genruntime.ClonePointerToInt(config.TcpTimeoutSeconds)

	// UdpTimeoutSeconds
	destination.UdpTimeoutSeconds = genruntime.ClonePointerToInt(config.UdpTimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Holds configuration customizations for IPVS. May only be specified if 'mode' is set to 'IPVS'.
type ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS struct {
	// Scheduler: IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
	Scheduler *IpvsScheduler_STATUS `json:"scheduler,omitempty"`

	// TcpFinTimeoutSeconds: The timeout value used for IPVS TCP sessions after receiving a FIN in seconds. Must be a positive
	// integer value.
	TcpFinTimeoutSeconds *int `json:"tcpFinTimeoutSeconds,omitempty"`

	// TcpTimeoutSeconds: The timeout value used for idle IPVS TCP sessions in seconds. Must be a positive integer value.
	TcpTimeoutSeconds *int `json:"tcpTimeoutSeconds,omitempty"`

	// UdpTimeoutSeconds: The timeout value used for IPVS UDP packets in seconds. Must be a positive integer value.
	UdpTimeoutSeconds *int `json:"udpTimeoutSeconds,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS, got %T", armInput)
	}

	// Set property "Scheduler":
	if typedInput.Scheduler != nil {
		var temp string
		temp = string(*typedInput.Scheduler)
		scheduler := IpvsScheduler_STATUS(temp)
		config.Scheduler = &scheduler
	}

	// Set property "TcpFinTimeoutSeconds":
	if typedInput.TcpFinTimeoutSeconds != nil {
		tcpFinTimeoutSeconds := *typedInput.TcpFinTimeoutSeconds
		config.TcpFinTimeoutSeconds = &tcpFinTimeoutSeconds
	}

	// Set property "TcpTimeoutSeconds":
	if typedInput.TcpTimeoutSeconds != nil {
		tcpTimeoutSeconds := *typedInput.TcpTimeoutSeconds
		config.TcpTimeoutSeconds = &tcpTimeoutSeconds
	}

	// Set property "UdpTimeoutSeconds":
	if typedInput.UdpTimeoutSeconds != nil {
		udpTimeoutSeconds := *typedInput.UdpTimeoutSeconds
		config.UdpTimeoutSeconds = &udpTimeoutSeconds
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS populates our ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS from the provided source ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS) AssignProperties_From_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS(source *storage.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS) error {

	// Scheduler
	if source.Scheduler != nil {
		scheduler := *source.Scheduler
		schedulerTemp := genruntime.ToEnum(scheduler, ipvsScheduler_STATUS_Values)
		config.Scheduler = &schedulerTemp
	} else {
		config.Scheduler = nil
	}

	// TcpFinTimeoutSeconds
	config.TcpFinTimeoutSeconds = genruntime.ClonePointerToInt(source.TcpFinTimeoutSeconds)

	// TcpTimeoutSeconds
	config.TcpTimeoutSeconds = genruntime.ClonePointerToInt(source.TcpTimeoutSeconds)

	// UdpTimeoutSeconds
	config.UdpTimeoutSeconds = genruntime.ClonePointerToInt(source.UdpTimeoutSeconds)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS populates the provided destination ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS from our ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS
func (config *ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS) AssignProperties_To_ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS(destination *storage.ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scheduler
	if config.Scheduler != nil {
		scheduler := string(*config.Scheduler)
		destination.Scheduler = &scheduler
	} else {
		destination.Scheduler = nil
	}

	// TcpFinTimeoutSeconds
	destination.TcpFinTimeoutSeconds = genruntime.ClonePointerToInt(config.TcpFinTimeoutSeconds)

	// TcpTimeoutSeconds
	destination.TcpTimeoutSeconds = genruntime.ClonePointerToInt(config.TcpTimeoutSeconds)

	// UdpTimeoutSeconds
	destination.UdpTimeoutSeconds = genruntime.ClonePointerToInt(config.UdpTimeoutSeconds)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains information about SSH certificate public key data.
type ContainerServiceSshPublicKey struct {
	// +kubebuilder:validation:Required
	// KeyData: Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or
	// without headers.
	KeyData *string `json:"keyData,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshPublicKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (publicKey *ContainerServiceSshPublicKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if publicKey == nil {
		return nil, nil
	}
	result := &arm.ContainerServiceSshPublicKey{}

	// Set property "KeyData":
	if publicKey.KeyData != nil {
		keyData := *publicKey.KeyData
		result.KeyData = &keyData
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *ContainerServiceSshPublicKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshPublicKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *ContainerServiceSshPublicKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshPublicKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshPublicKey, got %T", armInput)
	}

	// Set property "KeyData":
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshPublicKey populates our ContainerServiceSshPublicKey from the provided source ContainerServiceSshPublicKey
func (publicKey *ContainerServiceSshPublicKey) AssignProperties_From_ContainerServiceSshPublicKey(source *storage.ContainerServiceSshPublicKey) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshPublicKey populates the provided destination ContainerServiceSshPublicKey from our ContainerServiceSshPublicKey
func (publicKey *ContainerServiceSshPublicKey) AssignProperties_To_ContainerServiceSshPublicKey(destination *storage.ContainerServiceSshPublicKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains information about SSH certificate public key data.
type ContainerServiceSshPublicKey_STATUS struct {
	// KeyData: Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or
	// without headers.
	KeyData *string `json:"keyData,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshPublicKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *ContainerServiceSshPublicKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ContainerServiceSshPublicKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *ContainerServiceSshPublicKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ContainerServiceSshPublicKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ContainerServiceSshPublicKey_STATUS, got %T", armInput)
	}

	// Set property "KeyData":
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// No error
	return nil
}

// AssignProperties_From_ContainerServiceSshPublicKey_STATUS populates our ContainerServiceSshPublicKey_STATUS from the provided source ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignProperties_From_ContainerServiceSshPublicKey_STATUS(source *storage.ContainerServiceSshPublicKey_STATUS) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshPublicKey_STATUS populates the provided destination ContainerServiceSshPublicKey_STATUS from our ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignProperties_To_ContainerServiceSshPublicKey_STATUS(destination *storage.ContainerServiceSshPublicKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource management error additional info.
type ErrorAdditionalInfo_STATUS struct {
	// Info: The additional info.
	Info map[string]v1.JSON `json:"info,omitempty"`

	// Type: The additional info type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorAdditionalInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ErrorAdditionalInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorAdditionalInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ErrorAdditionalInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorAdditionalInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorAdditionalInfo_STATUS, got %T", armInput)
	}

	// Set property "Info":
	if typedInput.Info != nil {
		info.Info = make(map[string]v1.JSON, len(typedInput.Info))
		for key, value := range typedInput.Info {
			info.Info[key] = *value.DeepCopy()
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorAdditionalInfo_STATUS populates our ErrorAdditionalInfo_STATUS from the provided source ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_From_ErrorAdditionalInfo_STATUS(source *storage.ErrorAdditionalInfo_STATUS) error {

	// Info
	if source.Info != nil {
		infoMap := make(map[string]v1.JSON, len(source.Info))
		for infoKey, infoValue := range source.Info {
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		info.Info = infoMap
	} else {
		info.Info = nil
	}

	// Type
	info.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ErrorAdditionalInfo_STATUS populates the provided destination ErrorAdditionalInfo_STATUS from our ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_To_ErrorAdditionalInfo_STATUS(destination *storage.ErrorAdditionalInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Info
	if info.Info != nil {
		infoMap := make(map[string]v1.JSON, len(info.Info))
		for infoKey, infoValue := range info.Info {
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		destination.Info = infoMap
	} else {
		destination.Info = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(info.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorDetail_STATUS_Unrolled struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ErrorDetail_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorDetail_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ErrorDetail_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorDetail_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorDetail_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		unrolled.AdditionalInfo = append(unrolled.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS_Unrolled populates our ErrorDetail_STATUS_Unrolled from the provided source ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_From_ErrorDetail_STATUS_Unrolled(source *storage.ErrorDetail_STATUS_Unrolled) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		unrolled.AdditionalInfo = additionalInfoList
	} else {
		unrolled.AdditionalInfo = nil
	}

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS_Unrolled populates the provided destination ErrorDetail_STATUS_Unrolled from our ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_To_ErrorDetail_STATUS_Unrolled(destination *storage.ErrorDetail_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if unrolled.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(unrolled.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range unrolled.AdditionalInfo {
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described
// here https://aka.ms/asm-plugin-ca
type IstioCertificateAuthority struct {
	// Plugin: Plugin certificates information for Service Mesh.
	Plugin *IstioPluginCertificateAuthority `json:"plugin,omitempty"`
}

var _ genruntime.ARMTransformer = &IstioCertificateAuthority{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (authority *IstioCertificateAuthority) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if authority == nil {
		return nil, nil
	}
	result := &arm.IstioCertificateAuthority{}

	// Set property "Plugin":
	if authority.Plugin != nil {
		plugin_ARM, err := authority.Plugin.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plugin := *plugin_ARM.(*arm.IstioPluginCertificateAuthority)
		result.Plugin = &plugin
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authority *IstioCertificateAuthority) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioCertificateAuthority{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authority *IstioCertificateAuthority) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioCertificateAuthority)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioCertificateAuthority, got %T", armInput)
	}

	// Set property "Plugin":
	if typedInput.Plugin != nil {
		var plugin1 IstioPluginCertificateAuthority
		err := plugin1.PopulateFromARM(owner, *typedInput.Plugin)
		if err != nil {
			return err
		}
		plugin := plugin1
		authority.Plugin = &plugin
	}

	// No error
	return nil
}

// AssignProperties_From_IstioCertificateAuthority populates our IstioCertificateAuthority from the provided source IstioCertificateAuthority
func (authority *IstioCertificateAuthority) AssignProperties_From_IstioCertificateAuthority(source *storage.IstioCertificateAuthority) error {

	// Plugin
	if source.Plugin != nil {
		var plugin IstioPluginCertificateAuthority
		err := plugin.AssignProperties_From_IstioPluginCertificateAuthority(source.Plugin)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioPluginCertificateAuthority() to populate field Plugin")
		}
		authority.Plugin = &plugin
	} else {
		authority.Plugin = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IstioCertificateAuthority populates the provided destination IstioCertificateAuthority from our IstioCertificateAuthority
func (authority *IstioCertificateAuthority) AssignProperties_To_IstioCertificateAuthority(destination *storage.IstioCertificateAuthority) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Plugin
	if authority.Plugin != nil {
		var plugin storage.IstioPluginCertificateAuthority
		err := authority.Plugin.AssignProperties_To_IstioPluginCertificateAuthority(&plugin)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioPluginCertificateAuthority() to populate field Plugin")
		}
		destination.Plugin = &plugin
	} else {
		destination.Plugin = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described
// here https://aka.ms/asm-plugin-ca
type IstioCertificateAuthority_STATUS struct {
	// Plugin: Plugin certificates information for Service Mesh.
	Plugin *IstioPluginCertificateAuthority_STATUS `json:"plugin,omitempty"`
}

var _ genruntime.FromARMConverter = &IstioCertificateAuthority_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authority *IstioCertificateAuthority_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioCertificateAuthority_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authority *IstioCertificateAuthority_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioCertificateAuthority_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioCertificateAuthority_STATUS, got %T", armInput)
	}

	// Set property "Plugin":
	if typedInput.Plugin != nil {
		var plugin1 IstioPluginCertificateAuthority_STATUS
		err := plugin1.PopulateFromARM(owner, *typedInput.Plugin)
		if err != nil {
			return err
		}
		plugin := plugin1
		authority.Plugin = &plugin
	}

	// No error
	return nil
}

// AssignProperties_From_IstioCertificateAuthority_STATUS populates our IstioCertificateAuthority_STATUS from the provided source IstioCertificateAuthority_STATUS
func (authority *IstioCertificateAuthority_STATUS) AssignProperties_From_IstioCertificateAuthority_STATUS(source *storage.IstioCertificateAuthority_STATUS) error {

	// Plugin
	if source.Plugin != nil {
		var plugin IstioPluginCertificateAuthority_STATUS
		err := plugin.AssignProperties_From_IstioPluginCertificateAuthority_STATUS(source.Plugin)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IstioPluginCertificateAuthority_STATUS() to populate field Plugin")
		}
		authority.Plugin = &plugin
	} else {
		authority.Plugin = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IstioCertificateAuthority_STATUS populates the provided destination IstioCertificateAuthority_STATUS from our IstioCertificateAuthority_STATUS
func (authority *IstioCertificateAuthority_STATUS) AssignProperties_To_IstioCertificateAuthority_STATUS(destination *storage.IstioCertificateAuthority_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Plugin
	if authority.Plugin != nil {
		var plugin storage.IstioPluginCertificateAuthority_STATUS
		err := authority.Plugin.AssignProperties_To_IstioPluginCertificateAuthority_STATUS(&plugin)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IstioPluginCertificateAuthority_STATUS() to populate field Plugin")
		}
		destination.Plugin = &plugin
	} else {
		destination.Plugin = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio components configuration.
type IstioComponents struct {
	// EgressGateways: Istio egress gateways.
	EgressGateways []IstioEgressGateway `json:"egressGateways,omitempty"`

	// IngressGateways: Istio ingress gateways.
	IngressGateways []IstioIngressGateway `json:"ingressGateways,omitempty"`

	// ProxyRedirectionMechanism: Mode of traffic redirection.
	ProxyRedirectionMechanism *ProxyRedirectionMechanism `json:"proxyRedirectionMechanism,omitempty"`
}

var _ genruntime.ARMTransformer = &IstioComponents{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (components *IstioComponents) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if components == nil {
		return nil, nil
	}
	result := &arm.IstioComponents{}

	// Set property "EgressGateways":
	for _, item := range components.EgressGateways {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EgressGateways = append(result.EgressGateways, *item_ARM.(*arm.IstioEgressGateway))
	}

	// Set property "IngressGateways":
	for _, item := range components.IngressGateways {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IngressGateways = append(result.IngressGateways, *item_ARM.(*arm.IstioIngressGateway))
	}

	// Set property "ProxyRedirectionMechanism":
	if components.ProxyRedirectionMechanism != nil {
		var temp string
		temp = string(*components.ProxyRedirectionMechanism)
		proxyRedirectionMechanism := arm.ProxyRedirectionMechanism(temp)
		result.ProxyRedirectionMechanism = &proxyRedirectionMechanism
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (components *IstioComponents) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioComponents{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (components *IstioComponents) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioComponents)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioComponents, got %T", armInput)
	}

	// Set property "EgressGateways":
	for _, item := range typedInput.EgressGateways {
		var item1 IstioEgressGateway
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		components.EgressGateways = append(components.EgressGateways, item1)
	}

	// Set property "IngressGateways":
	for _, item := range typedInput.IngressGateways {
		var item1 IstioIngressGateway
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		components.IngressGateways = append(components.IngressGateways, item1)
	}

	// Set property "ProxyRedirectionMechanism":
	if typedInput.ProxyRedirectionMechanism != nil {
		var temp string
		temp = string(*typedInput.ProxyRedirectionMechanism)
		proxyRedirectionMechanism := ProxyRedirectionMechanism(temp)
		components.ProxyRedirectionMechanism = &proxyRedirectionMechanism
	}

	// No error
	return nil
}

// AssignProperties_From_IstioComponents populates our IstioComponents from the provided source IstioComponents
func (components *IstioComponents) AssignProperties_From_IstioComponents(source *storage.IstioComponents) error {

	// EgressGateways
	if source.EgressGateways != nil {
		egressGatewayList := make([]IstioEgressGateway, len(source.EgressGateways))
		for egressGatewayIndex, egressGatewayItem := range source.EgressGateways {
			var egressGateway IstioEgressGateway
			err := egressGateway.AssignProperties_From_IstioEgressGateway(&egressGatewayItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IstioEgressGateway() to populate field EgressGateways")
			}
			egressGatewayList[egressGatewayIndex] = egressGateway
		}
		components.EgressGateways = egressGatewayList
	} else {
		components.EgressGateways = nil
	}

	// IngressGateways
	if source.IngressGateways != nil {
		ingressGatewayList := make([]IstioIngressGateway, len(source.IngressGateways))
		for ingressGatewayIndex, ingressGatewayItem := range source.IngressGateways {
			var ingressGateway IstioIngressGateway
			err := ingressGateway.AssignProperties_From_IstioIngressGateway(&ingressGatewayItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IstioIngressGateway() to populate field IngressGateways")
			}
			ingressGatewayList[ingressGatewayIndex] = ingressGateway
		}
		components.IngressGateways = ingressGatewayList
	} else {
		components.IngressGateways = nil
	}

	// ProxyRedirectionMechanism
	if source.ProxyRedirectionMechanism != nil {
		proxyRedirectionMechanism := *source.ProxyRedirectionMechanism
		proxyRedirectionMechanismTemp := genruntime.ToEnum(proxyRedirectionMechanism, proxyRedirectionMechanism_Values)
		components.ProxyRedirectionMechanism = &proxyRedirectionMechanismTemp
	} else {
		components.ProxyRedirectionMechanism = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IstioComponents populates the provided destination IstioComponents from our IstioComponents
func (components *IstioComponents) AssignProperties_To_IstioComponents(destination *storage.IstioComponents) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EgressGateways
	if components.EgressGateways != nil {
		egressGatewayList := make([]storage.IstioEgressGateway, len(components.EgressGateways))
		for egressGatewayIndex, egressGatewayItem := range components.EgressGateways {
			var egressGateway storage.IstioEgressGateway
			err := egressGatewayItem.AssignProperties_To_IstioEgressGateway(&egressGateway)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IstioEgressGateway() to populate field EgressGateways")
			}
			egressGatewayList[egressGatewayIndex] = egressGateway
		}
		destination.EgressGateways = egressGatewayList
	} else {
		destination.EgressGateways = nil
	}

	// IngressGateways
	if components.IngressGateways != nil {
		ingressGatewayList := make([]storage.IstioIngressGateway, len(components.IngressGateways))
		for ingressGatewayIndex, ingressGatewayItem := range components.IngressGateways {
			var ingressGateway storage.IstioIngressGateway
			err := ingressGatewayItem.AssignProperties_To_IstioIngressGateway(&ingressGateway)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IstioIngressGateway() to populate field IngressGateways")
			}
			ingressGatewayList[ingressGatewayIndex] = ingressGateway
		}
		destination.IngressGateways = ingressGatewayList
	} else {
		destination.IngressGateways = nil
	}

	// ProxyRedirectionMechanism
	if components.ProxyRedirectionMechanism != nil {
		proxyRedirectionMechanism := string(*components.ProxyRedirectionMechanism)
		destination.ProxyRedirectionMechanism = &proxyRedirectionMechanism
	} else {
		destination.ProxyRedirectionMechanism = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio components configuration.
type IstioComponents_STATUS struct {
	// EgressGateways: Istio egress gateways.
	EgressGateways []IstioEgressGateway_STATUS `json:"egressGateways,omitempty"`

	// IngressGateways: Istio ingress gateways.
	IngressGateways []IstioIngressGateway_STATUS `json:"ingressGateways,omitempty"`

	// ProxyRedirectionMechanism: Mode of traffic redirection.
	ProxyRedirectionMechanism *ProxyRedirectionMechanism_STATUS `json:"proxyRedirectionMechanism,omitempty"`
}

var _ genruntime.FromARMConverter = &IstioComponents_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (components *IstioComponents_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioComponents_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (components *IstioComponents_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioComponents_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioComponents_STATUS, got %T", armInput)
	}

	// Set property "EgressGateways":
	for _, item := range typedInput.EgressGateways {
		var item1 IstioEgressGateway_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		components.EgressGateways = append(components.EgressGateways, item1)
	}

	// Set property "IngressGateways":
	for _, item := range typedInput.IngressGateways {
		var item1 IstioIngressGateway_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		components.IngressGateways = append(components.IngressGateways, item1)
	}

	// Set property "ProxyRedirectionMechanism":
	if typedInput.ProxyRedirectionMechanism != nil {
		var temp string
		temp = string(*typedInput.ProxyRedirectionMechanism)
		proxyRedirectionMechanism := ProxyRedirectionMechanism_STATUS(temp)
		components.ProxyRedirectionMechanism = &proxyRedirectionMechanism
	}

	// No error
	return nil
}

// AssignProperties_From_IstioComponents_STATUS populates our IstioComponents_STATUS from the provided source IstioComponents_STATUS
func (components *IstioComponents_STATUS) AssignProperties_From_IstioComponents_STATUS(source *storage.IstioComponents_STATUS) error {

	// EgressGateways
	if source.EgressGateways != nil {
		egressGatewayList := make([]IstioEgressGateway_STATUS, len(source.EgressGateways))
		for egressGatewayIndex, egressGatewayItem := range source.EgressGateways {
			var egressGateway IstioEgressGateway_STATUS
			err := egressGateway.AssignProperties_From_IstioEgressGateway_STATUS(&egressGatewayItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IstioEgressGateway_STATUS() to populate field EgressGateways")
			}
			egressGatewayList[egressGatewayIndex] = egressGateway
		}
		components.EgressGateways = egressGatewayList
	} else {
		components.EgressGateways = nil
	}

	// IngressGateways
	if source.IngressGateways != nil {
		ingressGatewayList := make([]IstioIngressGateway_STATUS, len(source.IngressGateways))
		for ingressGatewayIndex, ingressGatewayItem := range source.IngressGateways {
			var ingressGateway IstioIngressGateway_STATUS
			err := ingressGateway.AssignProperties_From_IstioIngressGateway_STATUS(&ingressGatewayItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IstioIngressGateway_STATUS() to populate field IngressGateways")
			}
			ingressGatewayList[ingressGatewayIndex] = ingressGateway
		}
		components.IngressGateways = ingressGatewayList
	} else {
		components.IngressGateways = nil
	}

	// ProxyRedirectionMechanism
	if source.ProxyRedirectionMechanism != nil {
		proxyRedirectionMechanism := *source.ProxyRedirectionMechanism
		proxyRedirectionMechanismTemp := genruntime.ToEnum(proxyRedirectionMechanism, proxyRedirectionMechanism_STATUS_Values)
		components.ProxyRedirectionMechanism = &proxyRedirectionMechanismTemp
	} else {
		components.ProxyRedirectionMechanism = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IstioComponents_STATUS populates the provided destination IstioComponents_STATUS from our IstioComponents_STATUS
func (components *IstioComponents_STATUS) AssignProperties_To_IstioComponents_STATUS(destination *storage.IstioComponents_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EgressGateways
	if components.EgressGateways != nil {
		egressGatewayList := make([]storage.IstioEgressGateway_STATUS, len(components.EgressGateways))
		for egressGatewayIndex, egressGatewayItem := range components.EgressGateways {
			var egressGateway storage.IstioEgressGateway_STATUS
			err := egressGatewayItem.AssignProperties_To_IstioEgressGateway_STATUS(&egressGateway)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IstioEgressGateway_STATUS() to populate field EgressGateways")
			}
			egressGatewayList[egressGatewayIndex] = egressGateway
		}
		destination.EgressGateways = egressGatewayList
	} else {
		destination.EgressGateways = nil
	}

	// IngressGateways
	if components.IngressGateways != nil {
		ingressGatewayList := make([]storage.IstioIngressGateway_STATUS, len(components.IngressGateways))
		for ingressGatewayIndex, ingressGatewayItem := range components.IngressGateways {
			var ingressGateway storage.IstioIngressGateway_STATUS
			err := ingressGatewayItem.AssignProperties_To_IstioIngressGateway_STATUS(&ingressGateway)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IstioIngressGateway_STATUS() to populate field IngressGateways")
			}
			ingressGatewayList[ingressGatewayIndex] = ingressGateway
		}
		destination.IngressGateways = ingressGatewayList
	} else {
		destination.IngressGateways = nil
	}

	// ProxyRedirectionMechanism
	if components.ProxyRedirectionMechanism != nil {
		proxyRedirectionMechanism := string(*components.ProxyRedirectionMechanism)
		destination.ProxyRedirectionMechanism = &proxyRedirectionMechanism
	} else {
		destination.ProxyRedirectionMechanism = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption string

const (
	KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_Disabled = KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption("Disabled")
	KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_Enabled  = KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption("Enabled")
)

// Mapping from string to KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption
var kubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_Values = map[string]KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption{
	"disabled": KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_Disabled,
	"enabled":  KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_Enabled,
}

type KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS string

const (
	KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Disabled = KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS("Disabled")
	KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Enabled  = KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS("Enabled")
)

// Mapping from string to KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS
var kubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Values = map[string]KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS{
	"disabled": KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Disabled,
	"enabled":  KubernetesResourceObjectEncryptionProfile_InfrastructureEncryption_STATUS_Enabled,
}

// Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook to auto-instrument
// Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the application. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation struct {
	// Enabled: Indicates if Application Monitoring Auto Instrumentation is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instrumentation == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation{}

	// Set property "Enabled":
	if instrumentation.Enabled != nil {
		enabled := *instrumentation.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		instrumentation.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation populates our ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation from the provided source ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation(source *storage.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		instrumentation.Enabled = &enabled
	} else {
		instrumentation.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation from our ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if instrumentation.Enabled != nil {
		enabled := *instrumentation.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook to auto-instrument
// Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the application. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS struct {
	// Enabled: Indicates if Application Monitoring Auto Instrumentation is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		instrumentation.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS populates our ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS from the provided source ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS(source *storage.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		instrumentation.Enabled = &enabled
	} else {
		instrumentation.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS from our ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS
func (instrumentation *ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if instrumentation.Enabled != nil {
		enabled := *instrumentation.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and Traces. Collects
// OpenTelemetry logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs struct {
	// Enabled: Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Port: The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if logs == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs{}

	// Set property "Enabled":
	if logs.Enabled != nil {
		enabled := *logs.Enabled
		result.Enabled = &enabled
	}

	// Set property "Port":
	if logs.Port != nil {
		port := *logs.Port
		result.Port = &port
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		logs.Enabled = &enabled
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		logs.Port = &port
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs populates our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs from the provided source ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs(source *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		logs.Enabled = &enabled
	} else {
		logs.Enabled = nil
	}

	// Port
	logs.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs from our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if logs.Enabled != nil {
		enabled := *logs.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Port
	destination.Port = genruntime.ClonePointerToInt(logs.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and Traces. Collects
// OpenTelemetry logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS struct {
	// Enabled: Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Port: The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		logs.Enabled = &enabled
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		logs.Port = &port
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS populates our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS from the provided source ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS(source *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		logs.Enabled = &enabled
	} else {
		logs.Enabled = nil
	}

	// Port
	logs.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS from our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS
func (logs *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if logs.Enabled != nil {
		enabled := *logs.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Port
	destination.Port = genruntime.ClonePointerToInt(logs.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Metrics. Collects
// OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics struct {
	// Enabled: Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Port: The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if metrics == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics{}

	// Set property "Enabled":
	if metrics.Enabled != nil {
		enabled := *metrics.Enabled
		result.Enabled = &enabled
	}

	// Set property "Port":
	if metrics.Port != nil {
		port := *metrics.Port
		result.Port = &port
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		metrics.Enabled = &enabled
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		metrics.Port = &port
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics populates our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics from the provided source ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics(source *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		metrics.Enabled = &enabled
	} else {
		metrics.Enabled = nil
	}

	// Port
	metrics.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics from our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if metrics.Enabled != nil {
		enabled := *metrics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Port
	destination.Port = genruntime.ClonePointerToInt(metrics.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Metrics. Collects
// OpenTelemetry metrics of the application using Azure Monitor OpenTelemetry based SDKs. See
// aka.ms/AzureMonitorApplicationMonitoring for an overview.
type ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS struct {
	// Enabled: Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Port: The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
	Port *int `json:"port,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		metrics.Enabled = &enabled
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		metrics.Port = &port
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS populates our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS from the provided source ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS(source *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		metrics.Enabled = &enabled
	} else {
		metrics.Enabled = nil
	}

	// Port
	metrics.Port = genruntime.ClonePointerToInt(source.Port)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS populates the provided destination ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS from our ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS
func (metrics *ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS(destination *storage.ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if metrics.Enabled != nil {
		enabled := *metrics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Port
	destination.Port = genruntime.ClonePointerToInt(metrics.Port)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the
// kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for
// details.
type ManagedClusterAzureMonitorProfileKubeStateMetrics struct {
	// MetricAnnotationsAllowList: Comma-separated list of Kubernetes annotation keys that will be used in the resource's
	// labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric
	// contains only resource name and namespace labels.
	MetricAnnotationsAllowList *string `json:"metricAnnotationsAllowList,omitempty"`

	// MetricLabelsAllowlist: Comma-separated list of additional Kubernetes label keys that will be used in the resource's
	// labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only
	// resource name and namespace labels.
	MetricLabelsAllowlist *string `json:"metricLabelsAllowlist,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAzureMonitorProfileKubeStateMetrics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if metrics == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterAzureMonitorProfileKubeStateMetrics{}

	// Set property "MetricAnnotationsAllowList":
	if metrics.MetricAnnotationsAllowList != nil {
		metricAnnotationsAllowList := *metrics.MetricAnnotationsAllowList
		result.MetricAnnotationsAllowList = &metricAnnotationsAllowList
	}

	// Set property "MetricLabelsAllowlist":
	if metrics.MetricLabelsAllowlist != nil {
		metricLabelsAllowlist := *metrics.MetricLabelsAllowlist
		result.MetricLabelsAllowlist = &metricLabelsAllowlist
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileKubeStateMetrics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileKubeStateMetrics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileKubeStateMetrics, got %T", armInput)
	}

	// Set property "MetricAnnotationsAllowList":
	if typedInput.MetricAnnotationsAllowList != nil {
		metricAnnotationsAllowList := *typedInput.MetricAnnotationsAllowList
		metrics.MetricAnnotationsAllowList = &metricAnnotationsAllowList
	}

	// Set property "MetricLabelsAllowlist":
	if typedInput.MetricLabelsAllowlist != nil {
		metricLabelsAllowlist := *typedInput.MetricLabelsAllowlist
		metrics.MetricLabelsAllowlist = &metricLabelsAllowlist
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics populates our ManagedClusterAzureMonitorProfileKubeStateMetrics from the provided source ManagedClusterAzureMonitorProfileKubeStateMetrics
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics) AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics(source *storage.ManagedClusterAzureMonitorProfileKubeStateMetrics) error {

	// MetricAnnotationsAllowList
	metrics.MetricAnnotationsAllowList = genruntime.ClonePointerToString(source.MetricAnnotationsAllowList)

	// MetricLabelsAllowlist
	metrics.MetricLabelsAllowlist = genruntime.ClonePointerToString(source.MetricLabelsAllowlist)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics populates the provided destination ManagedClusterAzureMonitorProfileKubeStateMetrics from our ManagedClusterAzureMonitorProfileKubeStateMetrics
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics) AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics(destination *storage.ManagedClusterAzureMonitorProfileKubeStateMetrics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MetricAnnotationsAllowList
	destination.MetricAnnotationsAllowList = genruntime.ClonePointerToString(metrics.MetricAnnotationsAllowList)

	// MetricLabelsAllowlist
	destination.MetricLabelsAllowlist = genruntime.ClonePointerToString(metrics.MetricLabelsAllowlist)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the
// kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for
// details.
type ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS struct {
	// MetricAnnotationsAllowList: Comma-separated list of Kubernetes annotation keys that will be used in the resource's
	// labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric
	// contains only resource name and namespace labels.
	MetricAnnotationsAllowList *string `json:"metricAnnotationsAllowList,omitempty"`

	// MetricLabelsAllowlist: Comma-separated list of additional Kubernetes label keys that will be used in the resource's
	// labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only
	// resource name and namespace labels.
	MetricLabelsAllowlist *string `json:"metricLabelsAllowlist,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS, got %T", armInput)
	}

	// Set property "MetricAnnotationsAllowList":
	if typedInput.MetricAnnotationsAllowList != nil {
		metricAnnotationsAllowList := *typedInput.MetricAnnotationsAllowList
		metrics.MetricAnnotationsAllowList = &metricAnnotationsAllowList
	}

	// Set property "MetricLabelsAllowlist":
	if typedInput.MetricLabelsAllowlist != nil {
		metricLabelsAllowlist := *typedInput.MetricLabelsAllowlist
		metrics.MetricLabelsAllowlist = &metricLabelsAllowlist
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS populates our ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS from the provided source ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS) AssignProperties_From_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS(source *storage.ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS) error {

	// MetricAnnotationsAllowList
	metrics.MetricAnnotationsAllowList = genruntime.ClonePointerToString(source.MetricAnnotationsAllowList)

	// MetricLabelsAllowlist
	metrics.MetricLabelsAllowlist = genruntime.ClonePointerToString(source.MetricLabelsAllowlist)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS populates the provided destination ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS from our ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS
func (metrics *ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS) AssignProperties_To_ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS(destination *storage.ManagedClusterAzureMonitorProfileKubeStateMetrics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MetricAnnotationsAllowList
	destination.MetricAnnotationsAllowList = genruntime.ClonePointerToString(metrics.MetricAnnotationsAllowList)

	// MetricLabelsAllowlist
	destination.MetricLabelsAllowlist = genruntime.ClonePointerToString(metrics.MetricLabelsAllowlist)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIngressDefaultDomainProfile struct {
	// Enabled: Whether to enable Default Domain.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIngressDefaultDomainProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterIngressDefaultDomainProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIngressDefaultDomainProfile{}

	// Set property "Enabled":
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterIngressDefaultDomainProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressDefaultDomainProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterIngressDefaultDomainProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressDefaultDomainProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressDefaultDomainProfile, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressDefaultDomainProfile populates our ManagedClusterIngressDefaultDomainProfile from the provided source ManagedClusterIngressDefaultDomainProfile
func (profile *ManagedClusterIngressDefaultDomainProfile) AssignProperties_From_ManagedClusterIngressDefaultDomainProfile(source *storage.ManagedClusterIngressDefaultDomainProfile) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressDefaultDomainProfile populates the provided destination ManagedClusterIngressDefaultDomainProfile from our ManagedClusterIngressDefaultDomainProfile
func (profile *ManagedClusterIngressDefaultDomainProfile) AssignProperties_To_ManagedClusterIngressDefaultDomainProfile(destination *storage.ManagedClusterIngressDefaultDomainProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIngressDefaultDomainProfile_STATUS struct {
	// DomainName: The unique fully qualified domain name assigned to the cluster. This will not change even if disabled then
	// reenabled.
	DomainName *string `json:"domainName,omitempty"`

	// Enabled: Whether to enable Default Domain.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIngressDefaultDomainProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterIngressDefaultDomainProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressDefaultDomainProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterIngressDefaultDomainProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressDefaultDomainProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressDefaultDomainProfile_STATUS, got %T", armInput)
	}

	// Set property "DomainName":
	if typedInput.DomainName != nil {
		domainName := *typedInput.DomainName
		profile.DomainName = &domainName
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		profile.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressDefaultDomainProfile_STATUS populates our ManagedClusterIngressDefaultDomainProfile_STATUS from the provided source ManagedClusterIngressDefaultDomainProfile_STATUS
func (profile *ManagedClusterIngressDefaultDomainProfile_STATUS) AssignProperties_From_ManagedClusterIngressDefaultDomainProfile_STATUS(source *storage.ManagedClusterIngressDefaultDomainProfile_STATUS) error {

	// DomainName
	profile.DomainName = genruntime.ClonePointerToString(source.DomainName)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressDefaultDomainProfile_STATUS populates the provided destination ManagedClusterIngressDefaultDomainProfile_STATUS from our ManagedClusterIngressDefaultDomainProfile_STATUS
func (profile *ManagedClusterIngressDefaultDomainProfile_STATUS) AssignProperties_To_ManagedClusterIngressDefaultDomainProfile_STATUS(destination *storage.ManagedClusterIngressDefaultDomainProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainName
	destination.DomainName = genruntime.ClonePointerToString(profile.DomainName)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIngressProfileNginx struct {
	// DefaultIngressControllerType: Ingress type for the default NginxIngressController custom resource
	DefaultIngressControllerType *NginxIngressControllerType `json:"defaultIngressControllerType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIngressProfileNginx{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (nginx *ManagedClusterIngressProfileNginx) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if nginx == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterIngressProfileNginx{}

	// Set property "DefaultIngressControllerType":
	if nginx.DefaultIngressControllerType != nil {
		var temp string
		temp = string(*nginx.DefaultIngressControllerType)
		defaultIngressControllerType := arm.NginxIngressControllerType(temp)
		result.DefaultIngressControllerType = &defaultIngressControllerType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (nginx *ManagedClusterIngressProfileNginx) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileNginx{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (nginx *ManagedClusterIngressProfileNginx) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileNginx)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileNginx, got %T", armInput)
	}

	// Set property "DefaultIngressControllerType":
	if typedInput.DefaultIngressControllerType != nil {
		var temp string
		temp = string(*typedInput.DefaultIngressControllerType)
		defaultIngressControllerType := NginxIngressControllerType(temp)
		nginx.DefaultIngressControllerType = &defaultIngressControllerType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileNginx populates our ManagedClusterIngressProfileNginx from the provided source ManagedClusterIngressProfileNginx
func (nginx *ManagedClusterIngressProfileNginx) AssignProperties_From_ManagedClusterIngressProfileNginx(source *storage.ManagedClusterIngressProfileNginx) error {

	// DefaultIngressControllerType
	if source.DefaultIngressControllerType != nil {
		defaultIngressControllerType := *source.DefaultIngressControllerType
		defaultIngressControllerTypeTemp := genruntime.ToEnum(defaultIngressControllerType, nginxIngressControllerType_Values)
		nginx.DefaultIngressControllerType = &defaultIngressControllerTypeTemp
	} else {
		nginx.DefaultIngressControllerType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileNginx populates the provided destination ManagedClusterIngressProfileNginx from our ManagedClusterIngressProfileNginx
func (nginx *ManagedClusterIngressProfileNginx) AssignProperties_To_ManagedClusterIngressProfileNginx(destination *storage.ManagedClusterIngressProfileNginx) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultIngressControllerType
	if nginx.DefaultIngressControllerType != nil {
		defaultIngressControllerType := string(*nginx.DefaultIngressControllerType)
		destination.DefaultIngressControllerType = &defaultIngressControllerType
	} else {
		destination.DefaultIngressControllerType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterIngressProfileNginx_STATUS struct {
	// DefaultIngressControllerType: Ingress type for the default NginxIngressController custom resource
	DefaultIngressControllerType *NginxIngressControllerType_STATUS `json:"defaultIngressControllerType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIngressProfileNginx_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (nginx *ManagedClusterIngressProfileNginx_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterIngressProfileNginx_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (nginx *ManagedClusterIngressProfileNginx_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterIngressProfileNginx_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterIngressProfileNginx_STATUS, got %T", armInput)
	}

	// Set property "DefaultIngressControllerType":
	if typedInput.DefaultIngressControllerType != nil {
		var temp string
		temp = string(*typedInput.DefaultIngressControllerType)
		defaultIngressControllerType := NginxIngressControllerType_STATUS(temp)
		nginx.DefaultIngressControllerType = &defaultIngressControllerType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterIngressProfileNginx_STATUS populates our ManagedClusterIngressProfileNginx_STATUS from the provided source ManagedClusterIngressProfileNginx_STATUS
func (nginx *ManagedClusterIngressProfileNginx_STATUS) AssignProperties_From_ManagedClusterIngressProfileNginx_STATUS(source *storage.ManagedClusterIngressProfileNginx_STATUS) error {

	// DefaultIngressControllerType
	if source.DefaultIngressControllerType != nil {
		defaultIngressControllerType := *source.DefaultIngressControllerType
		defaultIngressControllerTypeTemp := genruntime.ToEnum(defaultIngressControllerType, nginxIngressControllerType_STATUS_Values)
		nginx.DefaultIngressControllerType = &defaultIngressControllerTypeTemp
	} else {
		nginx.DefaultIngressControllerType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIngressProfileNginx_STATUS populates the provided destination ManagedClusterIngressProfileNginx_STATUS from our ManagedClusterIngressProfileNginx_STATUS
func (nginx *ManagedClusterIngressProfileNginx_STATUS) AssignProperties_To_ManagedClusterIngressProfileNginx_STATUS(destination *storage.ManagedClusterIngressProfileNginx_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultIngressControllerType
	if nginx.DefaultIngressControllerType != nil {
		defaultIngressControllerType := string(*nginx.DefaultIngressControllerType)
		destination.DefaultIngressControllerType = &defaultIngressControllerType
	} else {
		destination.DefaultIngressControllerType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"NodeIP","NodeIPConfiguration"}
type ManagedClusterLoadBalancerProfile_BackendPoolType string

const (
	ManagedClusterLoadBalancerProfile_BackendPoolType_NodeIP              = ManagedClusterLoadBalancerProfile_BackendPoolType("NodeIP")
	ManagedClusterLoadBalancerProfile_BackendPoolType_NodeIPConfiguration = ManagedClusterLoadBalancerProfile_BackendPoolType("NodeIPConfiguration")
)

// Mapping from string to ManagedClusterLoadBalancerProfile_BackendPoolType
var managedClusterLoadBalancerProfile_BackendPoolType_Values = map[string]ManagedClusterLoadBalancerProfile_BackendPoolType{
	"nodeip":              ManagedClusterLoadBalancerProfile_BackendPoolType_NodeIP,
	"nodeipconfiguration": ManagedClusterLoadBalancerProfile_BackendPoolType_NodeIPConfiguration,
}

type ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS string

const (
	ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIP              = ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS("NodeIP")
	ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIPConfiguration = ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS("NodeIPConfiguration")
)

// Mapping from string to ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS
var managedClusterLoadBalancerProfile_BackendPoolType_STATUS_Values = map[string]ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS{
	"nodeip":              ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIP,
	"nodeipconfiguration": ManagedClusterLoadBalancerProfile_BackendPoolType_STATUS_NodeIPConfiguration,
}

// +kubebuilder:validation:Enum={"ServiceNodePort","Shared"}
type ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode string

const (
	ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_ServiceNodePort = ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode("ServiceNodePort")
	ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_Shared          = ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode("Shared")
)

// Mapping from string to ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode
var managedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_Values = map[string]ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode{
	"servicenodeport": ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_ServiceNodePort,
	"shared":          ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_Shared,
}

type ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS string

const (
	ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_ServiceNodePort = ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS("ServiceNodePort")
	ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Shared          = ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS("Shared")
)

// Mapping from string to ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS
var managedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Values = map[string]ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS{
	"servicenodeport": ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_ServiceNodePort,
	"shared":          ManagedClusterLoadBalancerProfile_ClusterServiceLoadBalancerHealthProbeMode_STATUS_Shared,
}

// Desired managed outbound IPs for the cluster load balancer.
type ManagedClusterLoadBalancerProfileManagedOutboundIPs struct {
	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	// Count: The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values
	// must be in the range of 1 to 100 (inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	// CountIPv6: The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed
	// values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
	CountIPv6 *int `json:"countIPv6,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfileManagedOutboundIPs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iPs == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs{}

	// Set property "Count":
	if iPs.Count != nil {
		count := *iPs.Count
		result.Count = &count
	}

	// Set property "CountIPv6":
	if iPs.CountIPv6 != nil {
		countIPv6 := *iPs.CountIPv6
		result.CountIPv6 = &countIPv6
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		iPs.Count = &count
	}

	// Set property "CountIPv6":
	if typedInput.CountIPv6 != nil {
		countIPv6 := *typedInput.CountIPv6
		iPs.CountIPv6 = &countIPv6
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs populates our ManagedClusterLoadBalancerProfileManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfileManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs(source *storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs) error {

	// Count
	iPs.Count = genruntime.ClonePointerToInt(source.Count)

	// CountIPv6
	iPs.CountIPv6 = genruntime.ClonePointerToInt(source.CountIPv6)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfileManagedOutboundIPs from our ManagedClusterLoadBalancerProfileManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs(destination *storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(iPs.Count)

	// CountIPv6
	destination.CountIPv6 = genruntime.ClonePointerToInt(iPs.CountIPv6)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Desired managed outbound IPs for the cluster load balancer.
type ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS struct {
	// Count: The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values
	// must be in the range of 1 to 100 (inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`

	// CountIPv6: The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed
	// values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
	CountIPv6 *int `json:"countIPv6,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		iPs.Count = &count
	}

	// Set property "CountIPv6":
	if typedInput.CountIPv6 != nil {
		countIPv6 := *typedInput.CountIPv6
		iPs.CountIPv6 = &countIPv6
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS populates our ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS from the provided source ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS(source *storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS) error {

	// Count
	iPs.Count = genruntime.ClonePointerToInt(source.Count)

	// CountIPv6
	iPs.CountIPv6 = genruntime.ClonePointerToInt(source.CountIPv6)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS populates the provided destination ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS from our ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS(destination *storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(iPs.Count)

	// CountIPv6
	destination.CountIPv6 = genruntime.ClonePointerToInt(iPs.CountIPv6)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Desired outbound IP Prefix resources for the cluster load balancer.
type ManagedClusterLoadBalancerProfileOutboundIPPrefixes struct {
	// PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfileOutboundIPPrefixes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if prefixes == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes{}

	// Set property "PublicIPPrefixes":
	for _, item := range prefixes.PublicIPPrefixes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPPrefixes = append(result.PublicIPPrefixes, *item_ARM.(*arm.ResourceReference))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes, got %T", armInput)
	}

	// Set property "PublicIPPrefixes":
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		prefixes.PublicIPPrefixes = append(prefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes populates our ManagedClusterLoadBalancerProfileOutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfileOutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(source *storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes) error {

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			var publicIPPrefix ResourceReference
			err := publicIPPrefix.AssignProperties_From_ResourceReference(&publicIPPrefixItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPPrefixes from our ManagedClusterLoadBalancerProfileOutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(destination *storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]storage.ResourceReference, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			var publicIPPrefix storage.ResourceReference
			err := publicIPPrefixItem.AssignProperties_To_ResourceReference(&publicIPPrefix)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Desired outbound IP Prefix resources for the cluster load balancer.
type ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS struct {
	// PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference_STATUS `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS, got %T", armInput)
	}

	// Set property "PublicIPPrefixes":
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		prefixes.PublicIPPrefixes = append(prefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS populates our ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS from the provided source ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS(source *storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS) error {

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference_STATUS, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			var publicIPPrefix ResourceReference_STATUS
			err := publicIPPrefix.AssignProperties_From_ResourceReference_STATUS(&publicIPPrefixItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS from our ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS(destination *storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]storage.ResourceReference_STATUS, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			var publicIPPrefix storage.ResourceReference_STATUS
			err := publicIPPrefixItem.AssignProperties_To_ResourceReference_STATUS(&publicIPPrefix)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Desired outbound IP resources for the cluster load balancer.
type ManagedClusterLoadBalancerProfileOutboundIPs struct {
	// PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference `json:"publicIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfileOutboundIPs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iPs == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterLoadBalancerProfileOutboundIPs{}

	// Set property "PublicIPs":
	for _, item := range iPs.PublicIPs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPs = append(result.PublicIPs, *item_ARM.(*arm.ResourceReference))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfileOutboundIPs{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfileOutboundIPs)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfileOutboundIPs, got %T", armInput)
	}

	// Set property "PublicIPs":
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		iPs.PublicIPs = append(iPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs populates our ManagedClusterLoadBalancerProfileOutboundIPs from the provided source ManagedClusterLoadBalancerProfileOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs(source *storage.ManagedClusterLoadBalancerProfileOutboundIPs) error {

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			var publicIP ResourceReference
			err := publicIP.AssignProperties_From_ResourceReference(&publicIPItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPs from our ManagedClusterLoadBalancerProfileOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs(destination *storage.ManagedClusterLoadBalancerProfileOutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]storage.ResourceReference, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			var publicIP storage.ResourceReference
			err := publicIPItem.AssignProperties_To_ResourceReference(&publicIP)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Desired outbound IP resources for the cluster load balancer.
type ManagedClusterLoadBalancerProfileOutboundIPs_STATUS struct {
	// PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference_STATUS `json:"publicIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfileOutboundIPs_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterLoadBalancerProfileOutboundIPs_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterLoadBalancerProfileOutboundIPs_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterLoadBalancerProfileOutboundIPs_STATUS, got %T", armInput)
	}

	// Set property "PublicIPs":
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		iPs.PublicIPs = append(iPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS populates our ManagedClusterLoadBalancerProfileOutboundIPs_STATUS from the provided source ManagedClusterLoadBalancerProfileOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS(source *storage.ManagedClusterLoadBalancerProfileOutboundIPs_STATUS) error {

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference_STATUS, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			var publicIP ResourceReference_STATUS
			err := publicIP.AssignProperties_From_ResourceReference_STATUS(&publicIPItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPs_STATUS from our ManagedClusterLoadBalancerProfileOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs_STATUS(destination *storage.ManagedClusterLoadBalancerProfileOutboundIPs_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]storage.ResourceReference_STATUS, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			var publicIP storage.ResourceReference_STATUS
			err := publicIPItem.AssignProperties_To_ResourceReference_STATUS(&publicIP)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of the managed outbound IP resources of the managed cluster.
type ManagedClusterManagedOutboundIPProfile struct {
	// +kubebuilder:validation:Maximum=16
	// +kubebuilder:validation:Minimum=1
	// Count: The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16
	// (inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterManagedOutboundIPProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ManagedClusterManagedOutboundIPProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterManagedOutboundIPProfile{}

	// Set property "Count":
	if profile.Count != nil {
		count := *profile.Count
		result.Count = &count
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterManagedOutboundIPProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterManagedOutboundIPProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterManagedOutboundIPProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterManagedOutboundIPProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterManagedOutboundIPProfile, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterManagedOutboundIPProfile populates our ManagedClusterManagedOutboundIPProfile from the provided source ManagedClusterManagedOutboundIPProfile
func (profile *ManagedClusterManagedOutboundIPProfile) AssignProperties_From_ManagedClusterManagedOutboundIPProfile(source *storage.ManagedClusterManagedOutboundIPProfile) error {

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterManagedOutboundIPProfile populates the provided destination ManagedClusterManagedOutboundIPProfile from our ManagedClusterManagedOutboundIPProfile
func (profile *ManagedClusterManagedOutboundIPProfile) AssignProperties_To_ManagedClusterManagedOutboundIPProfile(destination *storage.ManagedClusterManagedOutboundIPProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Profile of the managed outbound IP resources of the managed cluster.
type ManagedClusterManagedOutboundIPProfile_STATUS struct {
	// Count: The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16
	// (inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterManagedOutboundIPProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ManagedClusterManagedOutboundIPProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterManagedOutboundIPProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ManagedClusterManagedOutboundIPProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterManagedOutboundIPProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterManagedOutboundIPProfile_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		profile.Count = &count
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterManagedOutboundIPProfile_STATUS populates our ManagedClusterManagedOutboundIPProfile_STATUS from the provided source ManagedClusterManagedOutboundIPProfile_STATUS
func (profile *ManagedClusterManagedOutboundIPProfile_STATUS) AssignProperties_From_ManagedClusterManagedOutboundIPProfile_STATUS(source *storage.ManagedClusterManagedOutboundIPProfile_STATUS) error {

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterManagedOutboundIPProfile_STATUS populates the provided destination ManagedClusterManagedOutboundIPProfile_STATUS from our ManagedClusterManagedOutboundIPProfile_STATUS
func (profile *ManagedClusterManagedOutboundIPProfile_STATUS) AssignProperties_To_ManagedClusterManagedOutboundIPProfile_STATUS(destination *storage.ManagedClusterManagedOutboundIPProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterPodIdentityProvisioningInfo_STATUS struct {
	// Error: Pod identity assignment error (if any).
	Error *ManagedClusterPodIdentityProvisioningError_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ManagedClusterPodIdentityProvisioningInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ManagedClusterPodIdentityProvisioningInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningInfo_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error1 ManagedClusterPodIdentityProvisioningError_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		info.Error = &error
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningInfo_STATUS populates our ManagedClusterPodIdentityProvisioningInfo_STATUS from the provided source ManagedClusterPodIdentityProvisioningInfo_STATUS
func (info *ManagedClusterPodIdentityProvisioningInfo_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningInfo_STATUS(source *storage.ManagedClusterPodIdentityProvisioningInfo_STATUS) error {

	// Error
	if source.Error != nil {
		var error ManagedClusterPodIdentityProvisioningError_STATUS
		err := error.AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS(source.Error)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
		}
		info.Error = &error
	} else {
		info.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningInfo_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningInfo_STATUS from our ManagedClusterPodIdentityProvisioningInfo_STATUS
func (info *ManagedClusterPodIdentityProvisioningInfo_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningInfo_STATUS(destination *storage.ManagedClusterPodIdentityProvisioningInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if info.Error != nil {
		var error storage.ManagedClusterPodIdentityProvisioningError_STATUS
		err := info.Error.AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS(&error)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The current provisioning state of the pod identity.
type ManagedClusterPodIdentityProvisioningState_STATUS string

const (
	ManagedClusterPodIdentityProvisioningState_STATUS_Assigned  = ManagedClusterPodIdentityProvisioningState_STATUS("Assigned")
	ManagedClusterPodIdentityProvisioningState_STATUS_Canceled  = ManagedClusterPodIdentityProvisioningState_STATUS("Canceled")
	ManagedClusterPodIdentityProvisioningState_STATUS_Deleting  = ManagedClusterPodIdentityProvisioningState_STATUS("Deleting")
	ManagedClusterPodIdentityProvisioningState_STATUS_Failed    = ManagedClusterPodIdentityProvisioningState_STATUS("Failed")
	ManagedClusterPodIdentityProvisioningState_STATUS_Succeeded = ManagedClusterPodIdentityProvisioningState_STATUS("Succeeded")
	ManagedClusterPodIdentityProvisioningState_STATUS_Updating  = ManagedClusterPodIdentityProvisioningState_STATUS("Updating")
)

// Mapping from string to ManagedClusterPodIdentityProvisioningState_STATUS
var managedClusterPodIdentityProvisioningState_STATUS_Values = map[string]ManagedClusterPodIdentityProvisioningState_STATUS{
	"assigned":  ManagedClusterPodIdentityProvisioningState_STATUS_Assigned,
	"canceled":  ManagedClusterPodIdentityProvisioningState_STATUS_Canceled,
	"deleting":  ManagedClusterPodIdentityProvisioningState_STATUS_Deleting,
	"failed":    ManagedClusterPodIdentityProvisioningState_STATUS_Failed,
	"succeeded": ManagedClusterPodIdentityProvisioningState_STATUS_Succeeded,
	"updating":  ManagedClusterPodIdentityProvisioningState_STATUS_Updating,
}

// Microsoft Defender settings for security gating, validates container images eligibility for deployment based on Defender
// for Containers security findings. Using Admission Controller, it either audits or prevents the deployment of images that
// do not meet security standards.
type ManagedClusterSecurityProfileDefenderSecurityGating struct {
	// AllowSecretAccess: In use only while registry access granted by secret rather than managed identity. Set whether to
	// grant the Defender gating agent access to the cluster's secrets for pulling images from registries. If secret access is
	// denied and the registry requires pull secrets, the add-on will not perform any image validation. Default value is false.
	AllowSecretAccess *bool `json:"allowSecretAccess,omitempty"`

	// Enabled: Whether to enable Defender security gating. When enabled, the gating feature will scan container images and
	// audit or block the deployment of images that do not meet security standards according to the configured security rules.
	Enabled *bool `json:"enabled,omitempty"`

	// Identities: List of identities that the admission controller will make use of in order to pull security artifacts from
	// the registry. These are the same identities used by the cluster to pull container images. Each identity provided should
	// have federated identity credential attached to it.
	Identities []ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem `json:"identities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileDefenderSecurityGating{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if gating == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileDefenderSecurityGating{}

	// Set property "AllowSecretAccess":
	if gating.AllowSecretAccess != nil {
		allowSecretAccess := *gating.AllowSecretAccess
		result.AllowSecretAccess = &allowSecretAccess
	}

	// Set property "Enabled":
	if gating.Enabled != nil {
		enabled := *gating.Enabled
		result.Enabled = &enabled
	}

	// Set property "Identities":
	for _, item := range gating.Identities {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Identities = append(result.Identities, *item_ARM.(*arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefenderSecurityGating{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefenderSecurityGating)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefenderSecurityGating, got %T", armInput)
	}

	// Set property "AllowSecretAccess":
	if typedInput.AllowSecretAccess != nil {
		allowSecretAccess := *typedInput.AllowSecretAccess
		gating.AllowSecretAccess = &allowSecretAccess
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gating.Enabled = &enabled
	}

	// Set property "Identities":
	for _, item := range typedInput.Identities {
		var item1 ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		gating.Identities = append(gating.Identities, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating populates our ManagedClusterSecurityProfileDefenderSecurityGating from the provided source ManagedClusterSecurityProfileDefenderSecurityGating
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating) AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating(source *storage.ManagedClusterSecurityProfileDefenderSecurityGating) error {

	// AllowSecretAccess
	if source.AllowSecretAccess != nil {
		allowSecretAccess := *source.AllowSecretAccess
		gating.AllowSecretAccess = &allowSecretAccess
	} else {
		gating.AllowSecretAccess = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gating.Enabled = &enabled
	} else {
		gating.Enabled = nil
	}

	// Identities
	if source.Identities != nil {
		identityList := make([]ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem, len(source.Identities))
		for identityIndex, identityItem := range source.Identities {
			var identity ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem
			err := identity.AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem(&identityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem() to populate field Identities")
			}
			identityList[identityIndex] = identity
		}
		gating.Identities = identityList
	} else {
		gating.Identities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating populates the provided destination ManagedClusterSecurityProfileDefenderSecurityGating from our ManagedClusterSecurityProfileDefenderSecurityGating
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating) AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating(destination *storage.ManagedClusterSecurityProfileDefenderSecurityGating) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowSecretAccess
	if gating.AllowSecretAccess != nil {
		allowSecretAccess := *gating.AllowSecretAccess
		destination.AllowSecretAccess = &allowSecretAccess
	} else {
		destination.AllowSecretAccess = nil
	}

	// Enabled
	if gating.Enabled != nil {
		enabled := *gating.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Identities
	if gating.Identities != nil {
		identityList := make([]storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem, len(gating.Identities))
		for identityIndex, identityItem := range gating.Identities {
			var identity storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem
			err := identityItem.AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem(&identity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem() to populate field Identities")
			}
			identityList[identityIndex] = identity
		}
		destination.Identities = identityList
	} else {
		destination.Identities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Microsoft Defender settings for security gating, validates container images eligibility for deployment based on Defender
// for Containers security findings. Using Admission Controller, it either audits or prevents the deployment of images that
// do not meet security standards.
type ManagedClusterSecurityProfileDefenderSecurityGating_STATUS struct {
	// AllowSecretAccess: In use only while registry access granted by secret rather than managed identity. Set whether to
	// grant the Defender gating agent access to the cluster's secrets for pulling images from registries. If secret access is
	// denied and the registry requires pull secrets, the add-on will not perform any image validation. Default value is false.
	AllowSecretAccess *bool `json:"allowSecretAccess,omitempty"`

	// Enabled: Whether to enable Defender security gating. When enabled, the gating feature will scan container images and
	// audit or block the deployment of images that do not meet security standards according to the configured security rules.
	Enabled *bool `json:"enabled,omitempty"`

	// Identities: List of identities that the admission controller will make use of in order to pull security artifacts from
	// the registry. These are the same identities used by the cluster to pull container images. Each identity provided should
	// have federated identity credential attached to it.
	Identities []ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS `json:"identities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileDefenderSecurityGating_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefenderSecurityGating_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefenderSecurityGating_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefenderSecurityGating_STATUS, got %T", armInput)
	}

	// Set property "AllowSecretAccess":
	if typedInput.AllowSecretAccess != nil {
		allowSecretAccess := *typedInput.AllowSecretAccess
		gating.AllowSecretAccess = &allowSecretAccess
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gating.Enabled = &enabled
	}

	// Set property "Identities":
	for _, item := range typedInput.Identities {
		var item1 ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		gating.Identities = append(gating.Identities, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS populates our ManagedClusterSecurityProfileDefenderSecurityGating_STATUS from the provided source ManagedClusterSecurityProfileDefenderSecurityGating_STATUS
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating_STATUS) AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS(source *storage.ManagedClusterSecurityProfileDefenderSecurityGating_STATUS) error {

	// AllowSecretAccess
	if source.AllowSecretAccess != nil {
		allowSecretAccess := *source.AllowSecretAccess
		gating.AllowSecretAccess = &allowSecretAccess
	} else {
		gating.AllowSecretAccess = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gating.Enabled = &enabled
	} else {
		gating.Enabled = nil
	}

	// Identities
	if source.Identities != nil {
		identityList := make([]ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS, len(source.Identities))
		for identityIndex, identityItem := range source.Identities {
			var identity ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS
			err := identity.AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS(&identityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS() to populate field Identities")
			}
			identityList[identityIndex] = identity
		}
		gating.Identities = identityList
	} else {
		gating.Identities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS populates the provided destination ManagedClusterSecurityProfileDefenderSecurityGating_STATUS from our ManagedClusterSecurityProfileDefenderSecurityGating_STATUS
func (gating *ManagedClusterSecurityProfileDefenderSecurityGating_STATUS) AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGating_STATUS(destination *storage.ManagedClusterSecurityProfileDefenderSecurityGating_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowSecretAccess
	if gating.AllowSecretAccess != nil {
		allowSecretAccess := *gating.AllowSecretAccess
		destination.AllowSecretAccess = &allowSecretAccess
	} else {
		destination.AllowSecretAccess = nil
	}

	// Enabled
	if gating.Enabled != nil {
		enabled := *gating.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Identities
	if gating.Identities != nil {
		identityList := make([]storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS, len(gating.Identities))
		for identityIndex, identityItem := range gating.Identities {
			var identity storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS
			err := identityItem.AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS(&identity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS() to populate field Identities")
			}
			identityList[identityIndex] = identity
		}
		destination.Identities = identityList
	} else {
		destination.Identities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Microsoft Defender settings for the security profile threat detection.
type ManagedClusterSecurityProfileDefenderSecurityMonitoring struct {
	// Enabled: Whether to enable Defender threat detection
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileDefenderSecurityMonitoring{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if monitoring == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring{}

	// Set property "Enabled":
	if monitoring.Enabled != nil {
		enabled := *monitoring.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		monitoring.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring populates our ManagedClusterSecurityProfileDefenderSecurityMonitoring from the provided source ManagedClusterSecurityProfileDefenderSecurityMonitoring
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring) AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring(source *storage.ManagedClusterSecurityProfileDefenderSecurityMonitoring) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		monitoring.Enabled = &enabled
	} else {
		monitoring.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring populates the provided destination ManagedClusterSecurityProfileDefenderSecurityMonitoring from our ManagedClusterSecurityProfileDefenderSecurityMonitoring
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring) AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring(destination *storage.ManagedClusterSecurityProfileDefenderSecurityMonitoring) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if monitoring.Enabled != nil {
		enabled := *monitoring.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Microsoft Defender settings for the security profile threat detection.
type ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS struct {
	// Enabled: Whether to enable Defender threat detection
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		monitoring.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS populates our ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS from the provided source ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS) AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS(source *storage.ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		monitoring.Enabled = &enabled
	} else {
		monitoring.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS populates the provided destination ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS from our ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS
func (monitoring *ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS) AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS(destination *storage.ManagedClusterSecurityProfileDefenderSecurityMonitoring_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if monitoring.Enabled != nil {
		enabled := *monitoring.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling string

const (
	ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_Disabled = ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling("Disabled")
	ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_Enabled  = ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling("Enabled")
)

// Mapping from string to ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling
var managedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_Values = map[string]ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling{
	"disabled": ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_Disabled,
	"enabled":  ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_Enabled,
}

type ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS string

const (
	ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Disabled = ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS("Disabled")
	ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Enabled  = ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS("Enabled")
)

// Mapping from string to ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS
var managedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Values = map[string]ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS{
	"disabled": ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Disabled,
	"enabled":  ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler_AddonAutoscaling_STATUS_Enabled,
}

// Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'. See
// https://aka.ms/k8s-gateway-api for more details.
// +kubebuilder:validation:Enum={"Disabled","Standard"}
type ManagedGatewayType string

const (
	ManagedGatewayType_Disabled = ManagedGatewayType("Disabled")
	ManagedGatewayType_Standard = ManagedGatewayType("Standard")
)

// Mapping from string to ManagedGatewayType
var managedGatewayType_Values = map[string]ManagedGatewayType{
	"disabled": ManagedGatewayType_Disabled,
	"standard": ManagedGatewayType_Standard,
}

// Configuration for the managed Gateway API installation. If not specified, the default is 'Disabled'. See
// https://aka.ms/k8s-gateway-api for more details.
type ManagedGatewayType_STATUS string

const (
	ManagedGatewayType_STATUS_Disabled = ManagedGatewayType_STATUS("Disabled")
	ManagedGatewayType_STATUS_Standard = ManagedGatewayType_STATUS("Standard")
)

// Mapping from string to ManagedGatewayType_STATUS
var managedGatewayType_STATUS_Values = map[string]ManagedGatewayType_STATUS{
	"disabled": ManagedGatewayType_STATUS_Disabled,
	"standard": ManagedGatewayType_STATUS_Standard,
}

// Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
// +kubebuilder:validation:Enum={"IPTABLES","IPVS","NFTABLES"}
type Mode string

const (
	Mode_IPTABLES = Mode("IPTABLES")
	Mode_IPVS     = Mode("IPVS")
	Mode_NFTABLES = Mode("NFTABLES")
)

// Mapping from string to Mode
var mode_Values = map[string]Mode{
	"iptables": Mode_IPTABLES,
	"ipvs":     Mode_IPVS,
	"nftables": Mode_NFTABLES,
}

// Specify which proxy mode to use ('IPTABLES', 'IPVS' or 'NFTABLES')
type Mode_STATUS string

const (
	Mode_STATUS_IPTABLES = Mode_STATUS("IPTABLES")
	Mode_STATUS_IPVS     = Mode_STATUS("IPVS")
	Mode_STATUS_NFTABLES = Mode_STATUS("NFTABLES")
)

// Mapping from string to Mode_STATUS
var mode_STATUS_Values = map[string]Mode_STATUS{
	"iptables": Mode_STATUS_IPTABLES,
	"ipvs":     Mode_STATUS_IPVS,
	"nftables": Mode_STATUS_NFTABLES,
}

// A reference to an Azure resource.
type ResourceReference_STATUS struct {
	// Id: The fully qualified Azure resource id.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceReference_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_From_ResourceReference_STATUS(source *storage.ResourceReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_To_ResourceReference_STATUS(destination *storage.ResourceReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The scheduler profile for a single scheduler instance.
type SchedulerInstanceProfile struct {
	// SchedulerConfigMode: The config customization mode for this scheduler instance.
	SchedulerConfigMode *SchedulerConfigMode `json:"schedulerConfigMode,omitempty"`
}

var _ genruntime.ARMTransformer = &SchedulerInstanceProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *SchedulerInstanceProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.SchedulerInstanceProfile{}

	// Set property "SchedulerConfigMode":
	if profile.SchedulerConfigMode != nil {
		var temp string
		temp = string(*profile.SchedulerConfigMode)
		schedulerConfigMode := arm.SchedulerConfigMode(temp)
		result.SchedulerConfigMode = &schedulerConfigMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SchedulerInstanceProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SchedulerInstanceProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SchedulerInstanceProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SchedulerInstanceProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SchedulerInstanceProfile, got %T", armInput)
	}

	// Set property "SchedulerConfigMode":
	if typedInput.SchedulerConfigMode != nil {
		var temp string
		temp = string(*typedInput.SchedulerConfigMode)
		schedulerConfigMode := SchedulerConfigMode(temp)
		profile.SchedulerConfigMode = &schedulerConfigMode
	}

	// No error
	return nil
}

// AssignProperties_From_SchedulerInstanceProfile populates our SchedulerInstanceProfile from the provided source SchedulerInstanceProfile
func (profile *SchedulerInstanceProfile) AssignProperties_From_SchedulerInstanceProfile(source *storage.SchedulerInstanceProfile) error {

	// SchedulerConfigMode
	if source.SchedulerConfigMode != nil {
		schedulerConfigMode := *source.SchedulerConfigMode
		schedulerConfigModeTemp := genruntime.ToEnum(schedulerConfigMode, schedulerConfigMode_Values)
		profile.SchedulerConfigMode = &schedulerConfigModeTemp
	} else {
		profile.SchedulerConfigMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SchedulerInstanceProfile populates the provided destination SchedulerInstanceProfile from our SchedulerInstanceProfile
func (profile *SchedulerInstanceProfile) AssignProperties_To_SchedulerInstanceProfile(destination *storage.SchedulerInstanceProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SchedulerConfigMode
	if profile.SchedulerConfigMode != nil {
		schedulerConfigMode := string(*profile.SchedulerConfigMode)
		destination.SchedulerConfigMode = &schedulerConfigMode
	} else {
		destination.SchedulerConfigMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The scheduler profile for a single scheduler instance.
type SchedulerInstanceProfile_STATUS struct {
	// SchedulerConfigMode: The config customization mode for this scheduler instance.
	SchedulerConfigMode *SchedulerConfigMode_STATUS `json:"schedulerConfigMode,omitempty"`
}

var _ genruntime.FromARMConverter = &SchedulerInstanceProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SchedulerInstanceProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SchedulerInstanceProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SchedulerInstanceProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SchedulerInstanceProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SchedulerInstanceProfile_STATUS, got %T", armInput)
	}

	// Set property "SchedulerConfigMode":
	if typedInput.SchedulerConfigMode != nil {
		var temp string
		temp = string(*typedInput.SchedulerConfigMode)
		schedulerConfigMode := SchedulerConfigMode_STATUS(temp)
		profile.SchedulerConfigMode = &schedulerConfigMode
	}

	// No error
	return nil
}

// AssignProperties_From_SchedulerInstanceProfile_STATUS populates our SchedulerInstanceProfile_STATUS from the provided source SchedulerInstanceProfile_STATUS
func (profile *SchedulerInstanceProfile_STATUS) AssignProperties_From_SchedulerInstanceProfile_STATUS(source *storage.SchedulerInstanceProfile_STATUS) error {

	// SchedulerConfigMode
	if source.SchedulerConfigMode != nil {
		schedulerConfigMode := *source.SchedulerConfigMode
		schedulerConfigModeTemp := genruntime.ToEnum(schedulerConfigMode, schedulerConfigMode_STATUS_Values)
		profile.SchedulerConfigMode = &schedulerConfigModeTemp
	} else {
		profile.SchedulerConfigMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SchedulerInstanceProfile_STATUS populates the provided destination SchedulerInstanceProfile_STATUS from our SchedulerInstanceProfile_STATUS
func (profile *SchedulerInstanceProfile_STATUS) AssignProperties_To_SchedulerInstanceProfile_STATUS(destination *storage.SchedulerInstanceProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SchedulerConfigMode
	if profile.SchedulerConfigMode != nil {
		schedulerConfigMode := string(*profile.SchedulerConfigMode)
		destination.SchedulerConfigMode = &schedulerConfigMode
	} else {
		destination.SchedulerConfigMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"BpfVeth","None"}
type AdvancedNetworkingPerformance_AccelerationMode string

const (
	AdvancedNetworkingPerformance_AccelerationMode_BpfVeth = AdvancedNetworkingPerformance_AccelerationMode("BpfVeth")
	AdvancedNetworkingPerformance_AccelerationMode_None    = AdvancedNetworkingPerformance_AccelerationMode("None")
)

// Mapping from string to AdvancedNetworkingPerformance_AccelerationMode
var advancedNetworkingPerformance_AccelerationMode_Values = map[string]AdvancedNetworkingPerformance_AccelerationMode{
	"bpfveth": AdvancedNetworkingPerformance_AccelerationMode_BpfVeth,
	"none":    AdvancedNetworkingPerformance_AccelerationMode_None,
}

type AdvancedNetworkingPerformance_AccelerationMode_STATUS string

const (
	AdvancedNetworkingPerformance_AccelerationMode_STATUS_BpfVeth = AdvancedNetworkingPerformance_AccelerationMode_STATUS("BpfVeth")
	AdvancedNetworkingPerformance_AccelerationMode_STATUS_None    = AdvancedNetworkingPerformance_AccelerationMode_STATUS("None")
)

// Mapping from string to AdvancedNetworkingPerformance_AccelerationMode_STATUS
var advancedNetworkingPerformance_AccelerationMode_STATUS_Values = map[string]AdvancedNetworkingPerformance_AccelerationMode_STATUS{
	"bpfveth": AdvancedNetworkingPerformance_AccelerationMode_STATUS_BpfVeth,
	"none":    AdvancedNetworkingPerformance_AccelerationMode_STATUS_None,
}

// Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium managed pods will be
// encrypted when it leaves the node boundary.
type AdvancedNetworkingSecurityTransitEncryption struct {
	// Type: Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified, the default
	// value is None.
	Type *TransitEncryptionType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &AdvancedNetworkingSecurityTransitEncryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *AdvancedNetworkingSecurityTransitEncryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.AdvancedNetworkingSecurityTransitEncryption{}

	// Set property "Type":
	if encryption.Type != nil {
		var temp string
		temp = string(*encryption.Type)
		typeVar := arm.TransitEncryptionType(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *AdvancedNetworkingSecurityTransitEncryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingSecurityTransitEncryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *AdvancedNetworkingSecurityTransitEncryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingSecurityTransitEncryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingSecurityTransitEncryption, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := TransitEncryptionType(temp)
		encryption.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption populates our AdvancedNetworkingSecurityTransitEncryption from the provided source AdvancedNetworkingSecurityTransitEncryption
func (encryption *AdvancedNetworkingSecurityTransitEncryption) AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption(source *storage.AdvancedNetworkingSecurityTransitEncryption) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, transitEncryptionType_Values)
		encryption.Type = &typeTemp
	} else {
		encryption.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption populates the provided destination AdvancedNetworkingSecurityTransitEncryption from our AdvancedNetworkingSecurityTransitEncryption
func (encryption *AdvancedNetworkingSecurityTransitEncryption) AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption(destination *storage.AdvancedNetworkingSecurityTransitEncryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if encryption.Type != nil {
		typeVar := string(*encryption.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Encryption configuration for Cilium-based clusters. Once enabled all traffic between Cilium managed pods will be
// encrypted when it leaves the node boundary.
type AdvancedNetworkingSecurityTransitEncryption_STATUS struct {
	// Type: Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified, the default
	// value is None.
	Type *TransitEncryptionType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &AdvancedNetworkingSecurityTransitEncryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *AdvancedNetworkingSecurityTransitEncryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdvancedNetworkingSecurityTransitEncryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *AdvancedNetworkingSecurityTransitEncryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdvancedNetworkingSecurityTransitEncryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdvancedNetworkingSecurityTransitEncryption_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := TransitEncryptionType_STATUS(temp)
		encryption.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption_STATUS populates our AdvancedNetworkingSecurityTransitEncryption_STATUS from the provided source AdvancedNetworkingSecurityTransitEncryption_STATUS
func (encryption *AdvancedNetworkingSecurityTransitEncryption_STATUS) AssignProperties_From_AdvancedNetworkingSecurityTransitEncryption_STATUS(source *storage.AdvancedNetworkingSecurityTransitEncryption_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, transitEncryptionType_STATUS_Values)
		encryption.Type = &typeTemp
	} else {
		encryption.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption_STATUS populates the provided destination AdvancedNetworkingSecurityTransitEncryption_STATUS from our AdvancedNetworkingSecurityTransitEncryption_STATUS
func (encryption *AdvancedNetworkingSecurityTransitEncryption_STATUS) AssignProperties_To_AdvancedNetworkingSecurityTransitEncryption_STATUS(destination *storage.AdvancedNetworkingSecurityTransitEncryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if encryption.Type != nil {
		typeVar := string(*encryption.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies
// themselves must be configured via the Cilium Network Policy resources, see
// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
// specified, the default value is FQDN if security.enabled is set to true.
// +kubebuilder:validation:Enum={"FQDN","L7","None"}
type AdvancedNetworkPolicies string

const (
	AdvancedNetworkPolicies_FQDN = AdvancedNetworkPolicies("FQDN")
	AdvancedNetworkPolicies_L7   = AdvancedNetworkPolicies("L7")
	AdvancedNetworkPolicies_None = AdvancedNetworkPolicies("None")
)

// Mapping from string to AdvancedNetworkPolicies
var advancedNetworkPolicies_Values = map[string]AdvancedNetworkPolicies{
	"fqdn": AdvancedNetworkPolicies_FQDN,
	"l7":   AdvancedNetworkPolicies_L7,
	"none": AdvancedNetworkPolicies_None,
}

// Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies
// themselves must be configured via the Cilium Network Policy resources, see
// https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not
// specified, the default value is FQDN if security.enabled is set to true.
type AdvancedNetworkPolicies_STATUS string

const (
	AdvancedNetworkPolicies_STATUS_FQDN = AdvancedNetworkPolicies_STATUS("FQDN")
	AdvancedNetworkPolicies_STATUS_L7   = AdvancedNetworkPolicies_STATUS("L7")
	AdvancedNetworkPolicies_STATUS_None = AdvancedNetworkPolicies_STATUS("None")
)

// Mapping from string to AdvancedNetworkPolicies_STATUS
var advancedNetworkPolicies_STATUS_Values = map[string]AdvancedNetworkPolicies_STATUS{
	"fqdn": AdvancedNetworkPolicies_STATUS_FQDN,
	"l7":   AdvancedNetworkPolicies_STATUS_L7,
	"none": AdvancedNetworkPolicies_STATUS_None,
}

// IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
// +kubebuilder:validation:Enum={"LeastConnection","RoundRobin"}
type IpvsScheduler string

const (
	IpvsScheduler_LeastConnection = IpvsScheduler("LeastConnection")
	IpvsScheduler_RoundRobin      = IpvsScheduler("RoundRobin")
)

// Mapping from string to IpvsScheduler
var ipvsScheduler_Values = map[string]IpvsScheduler{
	"leastconnection": IpvsScheduler_LeastConnection,
	"roundrobin":      IpvsScheduler_RoundRobin,
}

// IPVS scheduler, for more information please see http://www.linuxvirtualserver.org/docs/scheduling.html.
type IpvsScheduler_STATUS string

const (
	IpvsScheduler_STATUS_LeastConnection = IpvsScheduler_STATUS("LeastConnection")
	IpvsScheduler_STATUS_RoundRobin      = IpvsScheduler_STATUS("RoundRobin")
)

// Mapping from string to IpvsScheduler_STATUS
var ipvsScheduler_STATUS_Values = map[string]IpvsScheduler_STATUS{
	"leastconnection": IpvsScheduler_STATUS_LeastConnection,
	"roundrobin":      IpvsScheduler_STATUS_RoundRobin,
}

// Istio egress gateway configuration.
type IstioEgressGateway struct {
	// +kubebuilder:validation:Required
	// Enabled: Whether to enable the egress gateway.
	Enabled *bool `json:"enabled,omitempty"`

	// GatewayConfigurationName: Name of the gateway configuration custom resource for the Istio add-on egress gateway. Must be
	// specified when enabling the Istio egress gateway. Must be deployed in the same namespace that the Istio egress gateway
	// will be deployed in.
	GatewayConfigurationName *string `json:"gatewayConfigurationName,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*"
	// Name: Name of the Istio add-on egress gateway.
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace that the Istio add-on egress gateway should be deployed in. If unspecified, the default is
	// aks-istio-egress.
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.ARMTransformer = &IstioEgressGateway{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (gateway *IstioEgressGateway) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if gateway == nil {
		return nil, nil
	}
	result := &arm.IstioEgressGateway{}

	// Set property "Enabled":
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		result.Enabled = &enabled
	}

	// Set property "GatewayConfigurationName":
	if gateway.GatewayConfigurationName != nil {
		gatewayConfigurationName := *gateway.GatewayConfigurationName
		result.GatewayConfigurationName = &gatewayConfigurationName
	}

	// Set property "Name":
	if gateway.Name != nil {
		name := *gateway.Name
		result.Name = &name
	}

	// Set property "Namespace":
	if gateway.Namespace != nil {
		namespace := *gateway.Namespace
		result.Namespace = &namespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gateway *IstioEgressGateway) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioEgressGateway{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gateway *IstioEgressGateway) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioEgressGateway)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioEgressGateway, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gateway.Enabled = &enabled
	}

	// Set property "GatewayConfigurationName":
	if typedInput.GatewayConfigurationName != nil {
		gatewayConfigurationName := *typedInput.GatewayConfigurationName
		gateway.GatewayConfigurationName = &gatewayConfigurationName
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		gateway.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		gateway.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_IstioEgressGateway populates our IstioEgressGateway from the provided source IstioEgressGateway
func (gateway *IstioEgressGateway) AssignProperties_From_IstioEgressGateway(source *storage.IstioEgressGateway) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gateway.Enabled = &enabled
	} else {
		gateway.Enabled = nil
	}

	// GatewayConfigurationName
	gateway.GatewayConfigurationName = genruntime.ClonePointerToString(source.GatewayConfigurationName)

	// Name
	gateway.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	gateway.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_IstioEgressGateway populates the provided destination IstioEgressGateway from our IstioEgressGateway
func (gateway *IstioEgressGateway) AssignProperties_To_IstioEgressGateway(destination *storage.IstioEgressGateway) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GatewayConfigurationName
	destination.GatewayConfigurationName = genruntime.ClonePointerToString(gateway.GatewayConfigurationName)

	// Name
	destination.Name = genruntime.ClonePointerToString(gateway.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(gateway.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio egress gateway configuration.
type IstioEgressGateway_STATUS struct {
	// Enabled: Whether to enable the egress gateway.
	Enabled *bool `json:"enabled,omitempty"`

	// GatewayConfigurationName: Name of the gateway configuration custom resource for the Istio add-on egress gateway. Must be
	// specified when enabling the Istio egress gateway. Must be deployed in the same namespace that the Istio egress gateway
	// will be deployed in.
	GatewayConfigurationName *string `json:"gatewayConfigurationName,omitempty"`

	// Name: Name of the Istio add-on egress gateway.
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace that the Istio add-on egress gateway should be deployed in. If unspecified, the default is
	// aks-istio-egress.
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.FromARMConverter = &IstioEgressGateway_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gateway *IstioEgressGateway_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioEgressGateway_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gateway *IstioEgressGateway_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioEgressGateway_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioEgressGateway_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gateway.Enabled = &enabled
	}

	// Set property "GatewayConfigurationName":
	if typedInput.GatewayConfigurationName != nil {
		gatewayConfigurationName := *typedInput.GatewayConfigurationName
		gateway.GatewayConfigurationName = &gatewayConfigurationName
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		gateway.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		gateway.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_IstioEgressGateway_STATUS populates our IstioEgressGateway_STATUS from the provided source IstioEgressGateway_STATUS
func (gateway *IstioEgressGateway_STATUS) AssignProperties_From_IstioEgressGateway_STATUS(source *storage.IstioEgressGateway_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gateway.Enabled = &enabled
	} else {
		gateway.Enabled = nil
	}

	// GatewayConfigurationName
	gateway.GatewayConfigurationName = genruntime.ClonePointerToString(source.GatewayConfigurationName)

	// Name
	gateway.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	gateway.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_IstioEgressGateway_STATUS populates the provided destination IstioEgressGateway_STATUS from our IstioEgressGateway_STATUS
func (gateway *IstioEgressGateway_STATUS) AssignProperties_To_IstioEgressGateway_STATUS(destination *storage.IstioEgressGateway_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GatewayConfigurationName
	destination.GatewayConfigurationName = genruntime.ClonePointerToString(gateway.GatewayConfigurationName)

	// Name
	destination.Name = genruntime.ClonePointerToString(gateway.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(gateway.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio ingress gateway configuration. For now, we support up to one external ingress gateway named
// `aks-istio-ingressgateway-external` and one internal ingress gateway named `aks-istio-ingressgateway-internal`.
type IstioIngressGateway struct {
	// +kubebuilder:validation:Required
	// Enabled: Whether to enable the ingress gateway.
	Enabled *bool `json:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	// Mode: Mode of an ingress gateway.
	Mode *IstioIngressGatewayMode `json:"mode,omitempty"`
}

var _ genruntime.ARMTransformer = &IstioIngressGateway{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (gateway *IstioIngressGateway) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if gateway == nil {
		return nil, nil
	}
	result := &arm.IstioIngressGateway{}

	// Set property "Enabled":
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		result.Enabled = &enabled
	}

	// Set property "Mode":
	if gateway.Mode != nil {
		var temp string
		temp = string(*gateway.Mode)
		mode := arm.IstioIngressGatewayMode(temp)
		result.Mode = &mode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gateway *IstioIngressGateway) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioIngressGateway{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gateway *IstioIngressGateway) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioIngressGateway)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioIngressGateway, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gateway.Enabled = &enabled
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := IstioIngressGatewayMode(temp)
		gateway.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_IstioIngressGateway populates our IstioIngressGateway from the provided source IstioIngressGateway
func (gateway *IstioIngressGateway) AssignProperties_From_IstioIngressGateway(source *storage.IstioIngressGateway) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gateway.Enabled = &enabled
	} else {
		gateway.Enabled = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, istioIngressGatewayMode_Values)
		gateway.Mode = &modeTemp
	} else {
		gateway.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IstioIngressGateway populates the provided destination IstioIngressGateway from our IstioIngressGateway
func (gateway *IstioIngressGateway) AssignProperties_To_IstioIngressGateway(destination *storage.IstioIngressGateway) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Mode
	if gateway.Mode != nil {
		mode := string(*gateway.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Istio ingress gateway configuration. For now, we support up to one external ingress gateway named
// `aks-istio-ingressgateway-external` and one internal ingress gateway named `aks-istio-ingressgateway-internal`.
type IstioIngressGateway_STATUS struct {
	// Enabled: Whether to enable the ingress gateway.
	Enabled *bool `json:"enabled,omitempty"`

	// Mode: Mode of an ingress gateway.
	Mode *IstioIngressGatewayMode_STATUS `json:"mode,omitempty"`
}

var _ genruntime.FromARMConverter = &IstioIngressGateway_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (gateway *IstioIngressGateway_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioIngressGateway_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (gateway *IstioIngressGateway_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioIngressGateway_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioIngressGateway_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		gateway.Enabled = &enabled
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := IstioIngressGatewayMode_STATUS(temp)
		gateway.Mode = &mode
	}

	// No error
	return nil
}

// AssignProperties_From_IstioIngressGateway_STATUS populates our IstioIngressGateway_STATUS from the provided source IstioIngressGateway_STATUS
func (gateway *IstioIngressGateway_STATUS) AssignProperties_From_IstioIngressGateway_STATUS(source *storage.IstioIngressGateway_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		gateway.Enabled = &enabled
	} else {
		gateway.Enabled = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, istioIngressGatewayMode_STATUS_Values)
		gateway.Mode = &modeTemp
	} else {
		gateway.Mode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IstioIngressGateway_STATUS populates the provided destination IstioIngressGateway_STATUS from our IstioIngressGateway_STATUS
func (gateway *IstioIngressGateway_STATUS) AssignProperties_To_IstioIngressGateway_STATUS(destination *storage.IstioIngressGateway_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if gateway.Enabled != nil {
		enabled := *gateway.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Mode
	if gateway.Mode != nil {
		mode := string(*gateway.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Plugin certificates information for Service Mesh.
type IstioPluginCertificateAuthority struct {
	// CertChainObjectName: Certificate chain object name in Azure Key Vault.
	CertChainObjectName *string `json:"certChainObjectName,omitempty"`

	// CertObjectName: Intermediate certificate object name in Azure Key Vault.
	CertObjectName *string `json:"certObjectName,omitempty"`

	// KeyObjectName: Intermediate certificate private key object name in Azure Key Vault.
	KeyObjectName *string `json:"keyObjectName,omitempty"`

	// KeyVaultReference: The resource ID of the Key Vault.
	KeyVaultReference *genruntime.ResourceReference `armReference:"KeyVaultId" json:"keyVaultReference,omitempty"`

	// RootCertObjectName: Root certificate object name in Azure Key Vault.
	RootCertObjectName *string `json:"rootCertObjectName,omitempty"`
}

var _ genruntime.ARMTransformer = &IstioPluginCertificateAuthority{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (authority *IstioPluginCertificateAuthority) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if authority == nil {
		return nil, nil
	}
	result := &arm.IstioPluginCertificateAuthority{}

	// Set property "CertChainObjectName":
	if authority.CertChainObjectName != nil {
		certChainObjectName := *authority.CertChainObjectName
		result.CertChainObjectName = &certChainObjectName
	}

	// Set property "CertObjectName":
	if authority.CertObjectName != nil {
		certObjectName := *authority.CertObjectName
		result.CertObjectName = &certObjectName
	}

	// Set property "KeyObjectName":
	if authority.KeyObjectName != nil {
		keyObjectName := *authority.KeyObjectName
		result.KeyObjectName = &keyObjectName
	}

	// Set property "KeyVaultId":
	if authority.KeyVaultReference != nil {
		keyVaultReferenceARMID, err := resolved.ResolvedReferences.Lookup(*authority.KeyVaultReference)
		if err != nil {
			return nil, err
		}
		keyVaultReference := keyVaultReferenceARMID
		result.KeyVaultId = &keyVaultReference
	}

	// Set property "RootCertObjectName":
	if authority.RootCertObjectName != nil {
		rootCertObjectName := *authority.RootCertObjectName
		result.RootCertObjectName = &rootCertObjectName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authority *IstioPluginCertificateAuthority) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioPluginCertificateAuthority{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authority *IstioPluginCertificateAuthority) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioPluginCertificateAuthority)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioPluginCertificateAuthority, got %T", armInput)
	}

	// Set property "CertChainObjectName":
	if typedInput.CertChainObjectName != nil {
		certChainObjectName := *typedInput.CertChainObjectName
		authority.CertChainObjectName = &certChainObjectName
	}

	// Set property "CertObjectName":
	if typedInput.CertObjectName != nil {
		certObjectName := *typedInput.CertObjectName
		authority.CertObjectName = &certObjectName
	}

	// Set property "KeyObjectName":
	if typedInput.KeyObjectName != nil {
		keyObjectName := *typedInput.KeyObjectName
		authority.KeyObjectName = &keyObjectName
	}

	// no assignment for property "KeyVaultReference"

	// Set property "RootCertObjectName":
	if typedInput.RootCertObjectName != nil {
		rootCertObjectName := *typedInput.RootCertObjectName
		authority.RootCertObjectName = &rootCertObjectName
	}

	// No error
	return nil
}

// AssignProperties_From_IstioPluginCertificateAuthority populates our IstioPluginCertificateAuthority from the provided source IstioPluginCertificateAuthority
func (authority *IstioPluginCertificateAuthority) AssignProperties_From_IstioPluginCertificateAuthority(source *storage.IstioPluginCertificateAuthority) error {

	// CertChainObjectName
	authority.CertChainObjectName = genruntime.ClonePointerToString(source.CertChainObjectName)

	// CertObjectName
	authority.CertObjectName = genruntime.ClonePointerToString(source.CertObjectName)

	// KeyObjectName
	authority.KeyObjectName = genruntime.ClonePointerToString(source.KeyObjectName)

	// KeyVaultReference
	if source.KeyVaultReference != nil {
		keyVaultReference := source.KeyVaultReference.Copy()
		authority.KeyVaultReference = &keyVaultReference
	} else {
		authority.KeyVaultReference = nil
	}

	// RootCertObjectName
	authority.RootCertObjectName = genruntime.ClonePointerToString(source.RootCertObjectName)

	// No error
	return nil
}

// AssignProperties_To_IstioPluginCertificateAuthority populates the provided destination IstioPluginCertificateAuthority from our IstioPluginCertificateAuthority
func (authority *IstioPluginCertificateAuthority) AssignProperties_To_IstioPluginCertificateAuthority(destination *storage.IstioPluginCertificateAuthority) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertChainObjectName
	destination.CertChainObjectName = genruntime.ClonePointerToString(authority.CertChainObjectName)

	// CertObjectName
	destination.CertObjectName = genruntime.ClonePointerToString(authority.CertObjectName)

	// KeyObjectName
	destination.KeyObjectName = genruntime.ClonePointerToString(authority.KeyObjectName)

	// KeyVaultReference
	if authority.KeyVaultReference != nil {
		keyVaultReference := authority.KeyVaultReference.Copy()
		destination.KeyVaultReference = &keyVaultReference
	} else {
		destination.KeyVaultReference = nil
	}

	// RootCertObjectName
	destination.RootCertObjectName = genruntime.ClonePointerToString(authority.RootCertObjectName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Plugin certificates information for Service Mesh.
type IstioPluginCertificateAuthority_STATUS struct {
	// CertChainObjectName: Certificate chain object name in Azure Key Vault.
	CertChainObjectName *string `json:"certChainObjectName,omitempty"`

	// CertObjectName: Intermediate certificate object name in Azure Key Vault.
	CertObjectName *string `json:"certObjectName,omitempty"`

	// KeyObjectName: Intermediate certificate private key object name in Azure Key Vault.
	KeyObjectName *string `json:"keyObjectName,omitempty"`

	// KeyVaultId: The resource ID of the Key Vault.
	KeyVaultId *string `json:"keyVaultId,omitempty"`

	// RootCertObjectName: Root certificate object name in Azure Key Vault.
	RootCertObjectName *string `json:"rootCertObjectName,omitempty"`
}

var _ genruntime.FromARMConverter = &IstioPluginCertificateAuthority_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authority *IstioPluginCertificateAuthority_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IstioPluginCertificateAuthority_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authority *IstioPluginCertificateAuthority_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IstioPluginCertificateAuthority_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IstioPluginCertificateAuthority_STATUS, got %T", armInput)
	}

	// Set property "CertChainObjectName":
	if typedInput.CertChainObjectName != nil {
		certChainObjectName := *typedInput.CertChainObjectName
		authority.CertChainObjectName = &certChainObjectName
	}

	// Set property "CertObjectName":
	if typedInput.CertObjectName != nil {
		certObjectName := *typedInput.CertObjectName
		authority.CertObjectName = &certObjectName
	}

	// Set property "KeyObjectName":
	if typedInput.KeyObjectName != nil {
		keyObjectName := *typedInput.KeyObjectName
		authority.KeyObjectName = &keyObjectName
	}

	// Set property "KeyVaultId":
	if typedInput.KeyVaultId != nil {
		keyVaultId := *typedInput.KeyVaultId
		authority.KeyVaultId = &keyVaultId
	}

	// Set property "RootCertObjectName":
	if typedInput.RootCertObjectName != nil {
		rootCertObjectName := *typedInput.RootCertObjectName
		authority.RootCertObjectName = &rootCertObjectName
	}

	// No error
	return nil
}

// AssignProperties_From_IstioPluginCertificateAuthority_STATUS populates our IstioPluginCertificateAuthority_STATUS from the provided source IstioPluginCertificateAuthority_STATUS
func (authority *IstioPluginCertificateAuthority_STATUS) AssignProperties_From_IstioPluginCertificateAuthority_STATUS(source *storage.IstioPluginCertificateAuthority_STATUS) error {

	// CertChainObjectName
	authority.CertChainObjectName = genruntime.ClonePointerToString(source.CertChainObjectName)

	// CertObjectName
	authority.CertObjectName = genruntime.ClonePointerToString(source.CertObjectName)

	// KeyObjectName
	authority.KeyObjectName = genruntime.ClonePointerToString(source.KeyObjectName)

	// KeyVaultId
	authority.KeyVaultId = genruntime.ClonePointerToString(source.KeyVaultId)

	// RootCertObjectName
	authority.RootCertObjectName = genruntime.ClonePointerToString(source.RootCertObjectName)

	// No error
	return nil
}

// AssignProperties_To_IstioPluginCertificateAuthority_STATUS populates the provided destination IstioPluginCertificateAuthority_STATUS from our IstioPluginCertificateAuthority_STATUS
func (authority *IstioPluginCertificateAuthority_STATUS) AssignProperties_To_IstioPluginCertificateAuthority_STATUS(destination *storage.IstioPluginCertificateAuthority_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertChainObjectName
	destination.CertChainObjectName = genruntime.ClonePointerToString(authority.CertChainObjectName)

	// CertObjectName
	destination.CertObjectName = genruntime.ClonePointerToString(authority.CertObjectName)

	// KeyObjectName
	destination.KeyObjectName = genruntime.ClonePointerToString(authority.KeyObjectName)

	// KeyVaultId
	destination.KeyVaultId = genruntime.ClonePointerToString(authority.KeyVaultId)

	// RootCertObjectName
	destination.RootCertObjectName = genruntime.ClonePointerToString(authority.RootCertObjectName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An error response from the pod identity provisioning.
type ManagedClusterPodIdentityProvisioningError_STATUS struct {
	// Error: Details about the error.
	Error *ManagedClusterPodIdentityProvisioningErrorBody_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningError_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error2 ManagedClusterPodIdentityProvisioningErrorBody_STATUS
		err := error2.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error1 := error2
		error.Error = &error1
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS populates our ManagedClusterPodIdentityProvisioningError_STATUS from the provided source ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS(source *storage.ManagedClusterPodIdentityProvisioningError_STATUS) error {

	// Error
	if source.Error != nil {
		var errorLocal ManagedClusterPodIdentityProvisioningErrorBody_STATUS
		err := errorLocal.AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(source.Error)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
		}
		error.Error = &errorLocal
	} else {
		error.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningError_STATUS from our ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS(destination *storage.ManagedClusterPodIdentityProvisioningError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if error.Error != nil {
		var errorLocal storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS
		err := error.Error.AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(&errorLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
		}
		destination.Error = &errorLocal
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem struct {
	// AzureContainerRegistry: The container registry for which the identity will be used; the identity specified here should
	// have a federated identity credential attached to it.
	AzureContainerRegistry *string `json:"azureContainerRegistry,omitempty"`

	// Identity: The identity object used to access the registry
	Identity *UserAssignedIdentity `json:"identity,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem{}

	// Set property "AzureContainerRegistry":
	if item.AzureContainerRegistry != nil {
		azureContainerRegistry := *item.AzureContainerRegistry
		result.AzureContainerRegistry = &azureContainerRegistry
	}

	// Set property "Identity":
	if item.Identity != nil {
		identity_ARM, err := item.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.UserAssignedIdentity)
		result.Identity = &identity
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem, got %T", armInput)
	}

	// Set property "AzureContainerRegistry":
	if typedInput.AzureContainerRegistry != nil {
		azureContainerRegistry := *typedInput.AzureContainerRegistry
		item.AzureContainerRegistry = &azureContainerRegistry
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 UserAssignedIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		item.Identity = &identity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem populates our ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem from the provided source ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem(source *storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) error {

	// AzureContainerRegistry
	item.AzureContainerRegistry = genruntime.ClonePointerToString(source.AzureContainerRegistry)

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity
		err := identity.AssignProperties_From_UserAssignedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity() to populate field Identity")
		}
		item.Identity = &identity
	} else {
		item.Identity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem populates the provided destination ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem from our ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem(destination *storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureContainerRegistry
	destination.AzureContainerRegistry = genruntime.ClonePointerToString(item.AzureContainerRegistry)

	// Identity
	if item.Identity != nil {
		var identity storage.UserAssignedIdentity
		err := item.Identity.AssignProperties_To_UserAssignedIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS struct {
	// AzureContainerRegistry: The container registry for which the identity will be used; the identity specified here should
	// have a federated identity credential attached to it.
	AzureContainerRegistry *string `json:"azureContainerRegistry,omitempty"`

	// Identity: The identity object used to access the registry
	Identity *UserAssignedIdentity_STATUS `json:"identity,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS, got %T", armInput)
	}

	// Set property "AzureContainerRegistry":
	if typedInput.AzureContainerRegistry != nil {
		azureContainerRegistry := *typedInput.AzureContainerRegistry
		item.AzureContainerRegistry = &azureContainerRegistry
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 UserAssignedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		item.Identity = &identity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS populates our ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS from the provided source ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS) AssignProperties_From_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS(source *storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS) error {

	// AzureContainerRegistry
	item.AzureContainerRegistry = genruntime.ClonePointerToString(source.AzureContainerRegistry)

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity_STATUS
		err := identity.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		item.Identity = &identity
	} else {
		item.Identity = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS populates the provided destination ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS from our ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS
func (item *ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS) AssignProperties_To_ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS(destination *storage.ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureContainerRegistry
	destination.AzureContainerRegistry = genruntime.ClonePointerToString(item.AzureContainerRegistry)

	// Identity
	if item.Identity != nil {
		var identity storage.UserAssignedIdentity_STATUS
		err := item.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Ingress type for the default NginxIngressController custom resource
// +kubebuilder:validation:Enum={"AnnotationControlled","External","Internal","None"}
type NginxIngressControllerType string

const (
	NginxIngressControllerType_AnnotationControlled = NginxIngressControllerType("AnnotationControlled")
	NginxIngressControllerType_External             = NginxIngressControllerType("External")
	NginxIngressControllerType_Internal             = NginxIngressControllerType("Internal")
	NginxIngressControllerType_None                 = NginxIngressControllerType("None")
)

// Mapping from string to NginxIngressControllerType
var nginxIngressControllerType_Values = map[string]NginxIngressControllerType{
	"annotationcontrolled": NginxIngressControllerType_AnnotationControlled,
	"external":             NginxIngressControllerType_External,
	"internal":             NginxIngressControllerType_Internal,
	"none":                 NginxIngressControllerType_None,
}

// Ingress type for the default NginxIngressController custom resource
type NginxIngressControllerType_STATUS string

const (
	NginxIngressControllerType_STATUS_AnnotationControlled = NginxIngressControllerType_STATUS("AnnotationControlled")
	NginxIngressControllerType_STATUS_External             = NginxIngressControllerType_STATUS("External")
	NginxIngressControllerType_STATUS_Internal             = NginxIngressControllerType_STATUS("Internal")
	NginxIngressControllerType_STATUS_None                 = NginxIngressControllerType_STATUS("None")
)

// Mapping from string to NginxIngressControllerType_STATUS
var nginxIngressControllerType_STATUS_Values = map[string]NginxIngressControllerType_STATUS{
	"annotationcontrolled": NginxIngressControllerType_STATUS_AnnotationControlled,
	"external":             NginxIngressControllerType_STATUS_External,
	"internal":             NginxIngressControllerType_STATUS_Internal,
	"none":                 NginxIngressControllerType_STATUS_None,
}

// Mode of traffic redirection.
// +kubebuilder:validation:Enum={"CNIChaining","InitContainers"}
type ProxyRedirectionMechanism string

const (
	ProxyRedirectionMechanism_CNIChaining    = ProxyRedirectionMechanism("CNIChaining")
	ProxyRedirectionMechanism_InitContainers = ProxyRedirectionMechanism("InitContainers")
)

// Mapping from string to ProxyRedirectionMechanism
var proxyRedirectionMechanism_Values = map[string]ProxyRedirectionMechanism{
	"cnichaining":    ProxyRedirectionMechanism_CNIChaining,
	"initcontainers": ProxyRedirectionMechanism_InitContainers,
}

// Mode of traffic redirection.
type ProxyRedirectionMechanism_STATUS string

const (
	ProxyRedirectionMechanism_STATUS_CNIChaining    = ProxyRedirectionMechanism_STATUS("CNIChaining")
	ProxyRedirectionMechanism_STATUS_InitContainers = ProxyRedirectionMechanism_STATUS("InitContainers")
)

// Mapping from string to ProxyRedirectionMechanism_STATUS
var proxyRedirectionMechanism_STATUS_Values = map[string]ProxyRedirectionMechanism_STATUS{
	"cnichaining":    ProxyRedirectionMechanism_STATUS_CNIChaining,
	"initcontainers": ProxyRedirectionMechanism_STATUS_InitContainers,
}

// A reference to an Azure resource.
type ResourceReference struct {
	// Reference: The fully qualified Azure resource id.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ResourceReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ResourceReference{}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ResourceReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceReference, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignProperties_From_ResourceReference(source *storage.ResourceReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignProperties_To_ResourceReference(destination *storage.ResourceReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The config customization mode for this scheduler instance.
// +kubebuilder:validation:Enum={"Default","ManagedByCRD"}
type SchedulerConfigMode string

const (
	SchedulerConfigMode_Default      = SchedulerConfigMode("Default")
	SchedulerConfigMode_ManagedByCRD = SchedulerConfigMode("ManagedByCRD")
)

// Mapping from string to SchedulerConfigMode
var schedulerConfigMode_Values = map[string]SchedulerConfigMode{
	"default":      SchedulerConfigMode_Default,
	"managedbycrd": SchedulerConfigMode_ManagedByCRD,
}

// The config customization mode for this scheduler instance.
type SchedulerConfigMode_STATUS string

const (
	SchedulerConfigMode_STATUS_Default      = SchedulerConfigMode_STATUS("Default")
	SchedulerConfigMode_STATUS_ManagedByCRD = SchedulerConfigMode_STATUS("ManagedByCRD")
)

// Mapping from string to SchedulerConfigMode_STATUS
var schedulerConfigMode_STATUS_Values = map[string]SchedulerConfigMode_STATUS{
	"default":      SchedulerConfigMode_STATUS_Default,
	"managedbycrd": SchedulerConfigMode_STATUS_ManagedByCRD,
}

// Mode of an ingress gateway.
// +kubebuilder:validation:Enum={"External","Internal"}
type IstioIngressGatewayMode string

const (
	IstioIngressGatewayMode_External = IstioIngressGatewayMode("External")
	IstioIngressGatewayMode_Internal = IstioIngressGatewayMode("Internal")
)

// Mapping from string to IstioIngressGatewayMode
var istioIngressGatewayMode_Values = map[string]IstioIngressGatewayMode{
	"external": IstioIngressGatewayMode_External,
	"internal": IstioIngressGatewayMode_Internal,
}

// Mode of an ingress gateway.
type IstioIngressGatewayMode_STATUS string

const (
	IstioIngressGatewayMode_STATUS_External = IstioIngressGatewayMode_STATUS("External")
	IstioIngressGatewayMode_STATUS_Internal = IstioIngressGatewayMode_STATUS("Internal")
)

// Mapping from string to IstioIngressGatewayMode_STATUS
var istioIngressGatewayMode_STATUS_Values = map[string]IstioIngressGatewayMode_STATUS{
	"external": IstioIngressGatewayMode_STATUS_External,
	"internal": IstioIngressGatewayMode_STATUS_Internal,
}

// An error response from the pod identity provisioning.
type ManagedClusterPodIdentityProvisioningErrorBody_STATUS struct {
	// Code: An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// Details: A list of additional details about the error.
	Details []ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled `json:"details,omitempty"`

	// Message: A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningErrorBody_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		body.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		body.Details = append(body.Details, item1)
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		body.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		body.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(source *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {

	// Code
	body.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			var detail ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
			err := detail.AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detailItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		body.Details = detailList
	} else {
		body.Details = nil
	}

	// Message
	body.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	body.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(destination *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(body.Code)

	// Details
	if body.Details != nil {
		detailList := make([]storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, len(body.Details))
		for detailIndex, detailItem := range body.Details {
			var detail storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detail)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(body.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(body.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified, the default value
// is None.
// +kubebuilder:validation:Enum={"None","WireGuard"}
type TransitEncryptionType string

const (
	TransitEncryptionType_None      = TransitEncryptionType("None")
	TransitEncryptionType_WireGuard = TransitEncryptionType("WireGuard")
)

// Mapping from string to TransitEncryptionType
var transitEncryptionType_Values = map[string]TransitEncryptionType{
	"none":      TransitEncryptionType_None,
	"wireguard": TransitEncryptionType_WireGuard,
}

// Configures pod-to-pod encryption. This can be enabled only on Cilium-based clusters. If not specified, the default value
// is None.
type TransitEncryptionType_STATUS string

const (
	TransitEncryptionType_STATUS_None      = TransitEncryptionType_STATUS("None")
	TransitEncryptionType_STATUS_WireGuard = TransitEncryptionType_STATUS("WireGuard")
)

// Mapping from string to TransitEncryptionType_STATUS
var transitEncryptionType_STATUS_Values = map[string]TransitEncryptionType_STATUS{
	"none":      TransitEncryptionType_STATUS_None,
	"wireguard": TransitEncryptionType_STATUS_WireGuard,
}

type ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled struct {
	// Code: An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`

	// Message: A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(source *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(destination *storage.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedCluster{}, &ManagedClusterList{})
}
