// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v20240701

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/batch/v20240701/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/batch/v20240701/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,batch}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /batch/resource-manager/Microsoft.Batch/Batch/stable/2024-07-01/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}
type BatchAccount struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BatchAccount_Spec   `json:"spec,omitempty"`
	Status            BatchAccount_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BatchAccount{}

// GetConditions returns the conditions of the resource
func (account *BatchAccount) GetConditions() conditions.Conditions {
	return account.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (account *BatchAccount) SetConditions(conditions conditions.Conditions) {
	account.Status.Conditions = conditions
}

var _ conversion.Convertible = &BatchAccount{}

// ConvertFrom populates our BatchAccount from the provided hub BatchAccount
func (account *BatchAccount) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.BatchAccount)
	if !ok {
		return fmt.Errorf("expected batch/v20240701/storage/BatchAccount but received %T instead", hub)
	}

	return account.AssignProperties_From_BatchAccount(source)
}

// ConvertTo populates the provided hub BatchAccount from our BatchAccount
func (account *BatchAccount) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.BatchAccount)
	if !ok {
		return fmt.Errorf("expected batch/v20240701/storage/BatchAccount but received %T instead", hub)
	}

	return account.AssignProperties_To_BatchAccount(destination)
}

var _ configmaps.Exporter = &BatchAccount{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (account *BatchAccount) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if account.Spec.OperatorSpec == nil {
		return nil
	}
	return account.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &BatchAccount{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (account *BatchAccount) SecretDestinationExpressions() []*core.DestinationExpression {
	if account.Spec.OperatorSpec == nil {
		return nil
	}
	return account.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &BatchAccount{}

// InitializeSpec initializes the spec for this resource from the given status
func (account *BatchAccount) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*BatchAccount_STATUS); ok {
		return account.Spec.Initialize_From_BatchAccount_STATUS(s)
	}

	return fmt.Errorf("expected Status of type BatchAccount_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &BatchAccount{}

// AzureName returns the Azure name of the resource
func (account *BatchAccount) AzureName() string {
	return account.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-07-01"
func (account BatchAccount) GetAPIVersion() string {
	return "2024-07-01"
}

// GetResourceScope returns the scope of the resource
func (account *BatchAccount) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (account *BatchAccount) GetSpec() genruntime.ConvertibleSpec {
	return &account.Spec
}

// GetStatus returns the status of this resource
func (account *BatchAccount) GetStatus() genruntime.ConvertibleStatus {
	return &account.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (account *BatchAccount) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Batch/batchAccounts"
func (account *BatchAccount) GetType() string {
	return "Microsoft.Batch/batchAccounts"
}

// NewEmptyStatus returns a new empty (blank) status
func (account *BatchAccount) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BatchAccount_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (account *BatchAccount) Owner() *genruntime.ResourceReference {
	if account.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(account.Spec)
	return account.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (account *BatchAccount) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BatchAccount_STATUS); ok {
		account.Status = *st
		return nil
	}

	// Convert status to required version
	var st BatchAccount_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	account.Status = st
	return nil
}

// AssignProperties_From_BatchAccount populates our BatchAccount from the provided source BatchAccount
func (account *BatchAccount) AssignProperties_From_BatchAccount(source *storage.BatchAccount) error {

	// ObjectMeta
	account.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BatchAccount_Spec
	err := spec.AssignProperties_From_BatchAccount_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_BatchAccount_Spec() to populate field Spec")
	}
	account.Spec = spec

	// Status
	var status BatchAccount_STATUS
	err = status.AssignProperties_From_BatchAccount_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_BatchAccount_STATUS() to populate field Status")
	}
	account.Status = status

	// No error
	return nil
}

// AssignProperties_To_BatchAccount populates the provided destination BatchAccount from our BatchAccount
func (account *BatchAccount) AssignProperties_To_BatchAccount(destination *storage.BatchAccount) error {

	// ObjectMeta
	destination.ObjectMeta = *account.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.BatchAccount_Spec
	err := account.Spec.AssignProperties_To_BatchAccount_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_BatchAccount_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.BatchAccount_STATUS
	err = account.Status.AssignProperties_To_BatchAccount_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_BatchAccount_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (account *BatchAccount) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: account.Spec.OriginalVersion(),
		Kind:    "BatchAccount",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /batch/resource-manager/Microsoft.Batch/Batch/stable/2024-07-01/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}
type BatchAccountList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BatchAccount `json:"items"`
}

// +kubebuilder:validation:Enum={"2024-07-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-07-01")

type BatchAccount_Spec struct {
	// AllowedAuthenticationModes: List of allowed authentication modes for the Batch account that can be used to authenticate
	// with the data plane. This does not affect authentication with the control plane.
	AllowedAuthenticationModes []AuthenticationMode `json:"allowedAuthenticationModes,omitempty"`

	// AutoStorage: The properties related to the auto-storage account.
	AutoStorage *AutoStorageBaseProperties `json:"autoStorage,omitempty"`

	// +kubebuilder:validation:MaxLength=24
	// +kubebuilder:validation:MinLength=3
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9]+$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Encryption: Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using
	// a Microsoft managed key. For additional control, a customer-managed key can be used instead.
	Encryption *EncryptionProperties `json:"encryption,omitempty"`

	// Identity: The identity of the Batch account.
	Identity *BatchAccountIdentity `json:"identity,omitempty"`

	// KeyVaultReference: A reference to the Azure key vault associated with the Batch account.
	KeyVaultReference *KeyVaultReference `json:"keyVaultReference,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The region in which to create the account.
	Location *string `json:"location,omitempty"`

	// NetworkProfile: The network profile only takes effect when publicNetworkAccess is enabled.
	NetworkProfile *NetworkProfile `json:"networkProfile,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *BatchAccountOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PoolAllocationMode: The pool allocation mode also affects how clients may authenticate to the Batch Service API. If the
	// mode is BatchService, clients may authenticate using access keys or Microsoft Entra ID. If the mode is UserSubscription,
	// clients must use Microsoft Entra ID. The default is BatchService.
	PoolAllocationMode *PoolAllocationMode `json:"poolAllocationMode,omitempty"`

	// PublicNetworkAccess: The network access type for operating on the resources in the Batch account.
	PublicNetworkAccess *BatchAccountCreateProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Tags: The user-specified tags associated with the account.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &BatchAccount_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (account *BatchAccount_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if account == nil {
		return nil, nil
	}
	result := &arm.BatchAccount_Spec{}

	// Set property "Identity":
	if account.Identity != nil {
		identity_ARM, err := account.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.BatchAccountIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if account.Location != nil {
		location := *account.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if account.AllowedAuthenticationModes != nil ||
		account.AutoStorage != nil ||
		account.Encryption != nil ||
		account.KeyVaultReference != nil ||
		account.NetworkProfile != nil ||
		account.PoolAllocationMode != nil ||
		account.PublicNetworkAccess != nil {
		result.Properties = &arm.BatchAccountCreateProperties{}
	}
	for _, item := range account.AllowedAuthenticationModes {
		var temp string
		temp = string(item)
		result.Properties.AllowedAuthenticationModes = append(result.Properties.AllowedAuthenticationModes, arm.AuthenticationMode(temp))
	}
	if account.AutoStorage != nil {
		autoStorage_ARM, err := account.AutoStorage.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoStorage := *autoStorage_ARM.(*arm.AutoStorageBaseProperties)
		result.Properties.AutoStorage = &autoStorage
	}
	if account.Encryption != nil {
		encryption_ARM, err := account.Encryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.EncryptionProperties)
		result.Properties.Encryption = &encryption
	}
	if account.KeyVaultReference != nil {
		keyVaultReference_ARM, err := account.KeyVaultReference.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultReference := *keyVaultReference_ARM.(*arm.KeyVaultReference)
		result.Properties.KeyVaultReference = &keyVaultReference
	}
	if account.NetworkProfile != nil {
		networkProfile_ARM, err := account.NetworkProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfile_ARM.(*arm.NetworkProfile)
		result.Properties.NetworkProfile = &networkProfile
	}
	if account.PoolAllocationMode != nil {
		var temp string
		temp = string(*account.PoolAllocationMode)
		poolAllocationMode := arm.PoolAllocationMode(temp)
		result.Properties.PoolAllocationMode = &poolAllocationMode
	}
	if account.PublicNetworkAccess != nil {
		var temp string
		temp = string(*account.PublicNetworkAccess)
		publicNetworkAccess := arm.BatchAccountCreateProperties_PublicNetworkAccess(temp)
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "Tags":
	if account.Tags != nil {
		result.Tags = make(map[string]string, len(account.Tags))
		for key, value := range account.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *BatchAccount_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BatchAccount_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *BatchAccount_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BatchAccount_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BatchAccount_Spec, got %T", armInput)
	}

	// Set property "AllowedAuthenticationModes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedAuthenticationModes {
			var temp string
			temp = string(item)
			account.AllowedAuthenticationModes = append(account.AllowedAuthenticationModes, AuthenticationMode(temp))
		}
	}

	// Set property "AutoStorage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoStorage != nil {
			var autoStorage1 AutoStorageBaseProperties
			err := autoStorage1.PopulateFromARM(owner, *typedInput.Properties.AutoStorage)
			if err != nil {
				return err
			}
			autoStorage := autoStorage1
			account.AutoStorage = &autoStorage
		}
	}

	// Set property "AzureName":
	account.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 EncryptionProperties
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			account.Encryption = &encryption
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 BatchAccountIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		account.Identity = &identity
	}

	// Set property "KeyVaultReference":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReference != nil {
			var keyVaultReference1 KeyVaultReference
			err := keyVaultReference1.PopulateFromARM(owner, *typedInput.Properties.KeyVaultReference)
			if err != nil {
				return err
			}
			keyVaultReference := keyVaultReference1
			account.KeyVaultReference = &keyVaultReference
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		account.Location = &location
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 NetworkProfile
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			account.NetworkProfile = &networkProfile
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	account.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PoolAllocationMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PoolAllocationMode != nil {
			var temp string
			temp = string(*typedInput.Properties.PoolAllocationMode)
			poolAllocationMode := PoolAllocationMode(temp)
			account.PoolAllocationMode = &poolAllocationMode
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := BatchAccountCreateProperties_PublicNetworkAccess(temp)
			account.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		account.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			account.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &BatchAccount_Spec{}

// ConvertSpecFrom populates our BatchAccount_Spec from the provided source
func (account *BatchAccount_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.BatchAccount_Spec)
	if ok {
		// Populate our instance from source
		return account.AssignProperties_From_BatchAccount_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.BatchAccount_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = account.AssignProperties_From_BatchAccount_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BatchAccount_Spec
func (account *BatchAccount_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.BatchAccount_Spec)
	if ok {
		// Populate destination from our instance
		return account.AssignProperties_To_BatchAccount_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BatchAccount_Spec{}
	err := account.AssignProperties_To_BatchAccount_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BatchAccount_Spec populates our BatchAccount_Spec from the provided source BatchAccount_Spec
func (account *BatchAccount_Spec) AssignProperties_From_BatchAccount_Spec(source *storage.BatchAccount_Spec) error {

	// AllowedAuthenticationModes
	if source.AllowedAuthenticationModes != nil {
		allowedAuthenticationModeList := make([]AuthenticationMode, len(source.AllowedAuthenticationModes))
		for allowedAuthenticationModeIndex, allowedAuthenticationModeItem := range source.AllowedAuthenticationModes {
			allowedAuthenticationModeList[allowedAuthenticationModeIndex] = genruntime.ToEnum(allowedAuthenticationModeItem, authenticationMode_Values)
		}
		account.AllowedAuthenticationModes = allowedAuthenticationModeList
	} else {
		account.AllowedAuthenticationModes = nil
	}

	// AutoStorage
	if source.AutoStorage != nil {
		var autoStorage AutoStorageBaseProperties
		err := autoStorage.AssignProperties_From_AutoStorageBaseProperties(source.AutoStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutoStorageBaseProperties() to populate field AutoStorage")
		}
		account.AutoStorage = &autoStorage
	} else {
		account.AutoStorage = nil
	}

	// AzureName
	account.AzureName = source.AzureName

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionProperties
		err := encryption.AssignProperties_From_EncryptionProperties(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionProperties() to populate field Encryption")
		}
		account.Encryption = &encryption
	} else {
		account.Encryption = nil
	}

	// Identity
	if source.Identity != nil {
		var identity BatchAccountIdentity
		err := identity.AssignProperties_From_BatchAccountIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BatchAccountIdentity() to populate field Identity")
		}
		account.Identity = &identity
	} else {
		account.Identity = nil
	}

	// KeyVaultReference
	if source.KeyVaultReference != nil {
		var keyVaultReference KeyVaultReference
		err := keyVaultReference.AssignProperties_From_KeyVaultReference(source.KeyVaultReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultReference() to populate field KeyVaultReference")
		}
		account.KeyVaultReference = &keyVaultReference
	} else {
		account.KeyVaultReference = nil
	}

	// Location
	account.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile
		err := networkProfile.AssignProperties_From_NetworkProfile(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkProfile() to populate field NetworkProfile")
		}
		account.NetworkProfile = &networkProfile
	} else {
		account.NetworkProfile = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec BatchAccountOperatorSpec
		err := operatorSpec.AssignProperties_From_BatchAccountOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BatchAccountOperatorSpec() to populate field OperatorSpec")
		}
		account.OperatorSpec = &operatorSpec
	} else {
		account.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		account.Owner = &owner
	} else {
		account.Owner = nil
	}

	// PoolAllocationMode
	if source.PoolAllocationMode != nil {
		poolAllocationMode := *source.PoolAllocationMode
		poolAllocationModeTemp := genruntime.ToEnum(poolAllocationMode, poolAllocationMode_Values)
		account.PoolAllocationMode = &poolAllocationModeTemp
	} else {
		account.PoolAllocationMode = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, batchAccountCreateProperties_PublicNetworkAccess_Values)
		account.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		account.PublicNetworkAccess = nil
	}

	// Tags
	account.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_BatchAccount_Spec populates the provided destination BatchAccount_Spec from our BatchAccount_Spec
func (account *BatchAccount_Spec) AssignProperties_To_BatchAccount_Spec(destination *storage.BatchAccount_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedAuthenticationModes
	if account.AllowedAuthenticationModes != nil {
		allowedAuthenticationModeList := make([]string, len(account.AllowedAuthenticationModes))
		for allowedAuthenticationModeIndex, allowedAuthenticationModeItem := range account.AllowedAuthenticationModes {
			allowedAuthenticationModeList[allowedAuthenticationModeIndex] = string(allowedAuthenticationModeItem)
		}
		destination.AllowedAuthenticationModes = allowedAuthenticationModeList
	} else {
		destination.AllowedAuthenticationModes = nil
	}

	// AutoStorage
	if account.AutoStorage != nil {
		var autoStorage storage.AutoStorageBaseProperties
		err := account.AutoStorage.AssignProperties_To_AutoStorageBaseProperties(&autoStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutoStorageBaseProperties() to populate field AutoStorage")
		}
		destination.AutoStorage = &autoStorage
	} else {
		destination.AutoStorage = nil
	}

	// AzureName
	destination.AzureName = account.AzureName

	// Encryption
	if account.Encryption != nil {
		var encryption storage.EncryptionProperties
		err := account.Encryption.AssignProperties_To_EncryptionProperties(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionProperties() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Identity
	if account.Identity != nil {
		var identity storage.BatchAccountIdentity
		err := account.Identity.AssignProperties_To_BatchAccountIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BatchAccountIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyVaultReference
	if account.KeyVaultReference != nil {
		var keyVaultReference storage.KeyVaultReference
		err := account.KeyVaultReference.AssignProperties_To_KeyVaultReference(&keyVaultReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultReference() to populate field KeyVaultReference")
		}
		destination.KeyVaultReference = &keyVaultReference
	} else {
		destination.KeyVaultReference = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(account.Location)

	// NetworkProfile
	if account.NetworkProfile != nil {
		var networkProfile storage.NetworkProfile
		err := account.NetworkProfile.AssignProperties_To_NetworkProfile(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OperatorSpec
	if account.OperatorSpec != nil {
		var operatorSpec storage.BatchAccountOperatorSpec
		err := account.OperatorSpec.AssignProperties_To_BatchAccountOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BatchAccountOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = account.OriginalVersion()

	// Owner
	if account.Owner != nil {
		owner := account.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PoolAllocationMode
	if account.PoolAllocationMode != nil {
		poolAllocationMode := string(*account.PoolAllocationMode)
		destination.PoolAllocationMode = &poolAllocationMode
	} else {
		destination.PoolAllocationMode = nil
	}

	// PublicNetworkAccess
	if account.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*account.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(account.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BatchAccount_STATUS populates our BatchAccount_Spec from the provided source BatchAccount_STATUS
func (account *BatchAccount_Spec) Initialize_From_BatchAccount_STATUS(source *BatchAccount_STATUS) error {

	// AllowedAuthenticationModes
	if source.AllowedAuthenticationModes != nil {
		allowedAuthenticationModeList := make([]AuthenticationMode, len(source.AllowedAuthenticationModes))
		for allowedAuthenticationModeIndex, allowedAuthenticationModeItem := range source.AllowedAuthenticationModes {
			allowedAuthenticationMode := genruntime.ToEnum(string(allowedAuthenticationModeItem), authenticationMode_Values)
			allowedAuthenticationModeList[allowedAuthenticationModeIndex] = allowedAuthenticationMode
		}
		account.AllowedAuthenticationModes = allowedAuthenticationModeList
	} else {
		account.AllowedAuthenticationModes = nil
	}

	// AutoStorage
	if source.AutoStorage != nil {
		var autoStorage AutoStorageBaseProperties
		err := autoStorage.Initialize_From_AutoStorageProperties_STATUS(source.AutoStorage)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AutoStorageProperties_STATUS() to populate field AutoStorage")
		}
		account.AutoStorage = &autoStorage
	} else {
		account.AutoStorage = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionProperties
		err := encryption.Initialize_From_EncryptionProperties_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EncryptionProperties_STATUS() to populate field Encryption")
		}
		account.Encryption = &encryption
	} else {
		account.Encryption = nil
	}

	// Identity
	if source.Identity != nil {
		var identity BatchAccountIdentity
		err := identity.Initialize_From_BatchAccountIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_BatchAccountIdentity_STATUS() to populate field Identity")
		}
		account.Identity = &identity
	} else {
		account.Identity = nil
	}

	// KeyVaultReference
	if source.KeyVaultReference != nil {
		var keyVaultReference KeyVaultReference
		err := keyVaultReference.Initialize_From_KeyVaultReference_STATUS(source.KeyVaultReference)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KeyVaultReference_STATUS() to populate field KeyVaultReference")
		}
		account.KeyVaultReference = &keyVaultReference
	} else {
		account.KeyVaultReference = nil
	}

	// Location
	account.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile
		err := networkProfile.Initialize_From_NetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		account.NetworkProfile = &networkProfile
	} else {
		account.NetworkProfile = nil
	}

	// PoolAllocationMode
	if source.PoolAllocationMode != nil {
		poolAllocationMode := genruntime.ToEnum(string(*source.PoolAllocationMode), poolAllocationMode_Values)
		account.PoolAllocationMode = &poolAllocationMode
	} else {
		account.PoolAllocationMode = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), batchAccountCreateProperties_PublicNetworkAccess_Values)
		account.PublicNetworkAccess = &publicNetworkAccess
	} else {
		account.PublicNetworkAccess = nil
	}

	// Tags
	account.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (account *BatchAccount_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (account *BatchAccount_Spec) SetAzureName(azureName string) { account.AzureName = azureName }

// Contains information about an Azure Batch account.
type BatchAccount_STATUS struct {
	// AccountEndpoint: The account endpoint used to interact with the Batch service.
	AccountEndpoint *string `json:"accountEndpoint,omitempty"`

	// ActiveJobAndJobScheduleQuota: The active job and job schedule quota for the Batch account.
	ActiveJobAndJobScheduleQuota *int `json:"activeJobAndJobScheduleQuota,omitempty"`

	// AllowedAuthenticationModes: List of allowed authentication modes for the Batch account that can be used to authenticate
	// with the data plane. This does not affect authentication with the control plane.
	AllowedAuthenticationModes []AuthenticationMode_STATUS `json:"allowedAuthenticationModes,omitempty"`

	// AutoStorage: Contains information about the auto-storage account associated with a Batch account.
	AutoStorage *AutoStorageProperties_STATUS `json:"autoStorage,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DedicatedCoreQuota: For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription
	// so this value is not returned.
	DedicatedCoreQuota *int `json:"dedicatedCoreQuota,omitempty"`

	// DedicatedCoreQuotaPerVMFamily: A list of the dedicated core quota per Virtual Machine family for the Batch account. For
	// accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription so this value is not
	// returned.
	DedicatedCoreQuotaPerVMFamily []VirtualMachineFamilyCoreQuota_STATUS `json:"dedicatedCoreQuotaPerVMFamily,omitempty"`

	// DedicatedCoreQuotaPerVMFamilyEnforced: If this flag is true, dedicated core quota is enforced via both the
	// dedicatedCoreQuotaPerVMFamily and dedicatedCoreQuota properties on the account. If this flag is false, dedicated core
	// quota is enforced only via the dedicatedCoreQuota property on the account and does not consider Virtual Machine family.
	DedicatedCoreQuotaPerVMFamilyEnforced *bool `json:"dedicatedCoreQuotaPerVMFamilyEnforced,omitempty"`

	// Encryption: Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using
	// a Microsoft managed key. For additional control, a customer-managed key can be used instead.
	Encryption *EncryptionProperties_STATUS `json:"encryption,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the Batch account.
	Identity *BatchAccountIdentity_STATUS `json:"identity,omitempty"`

	// KeyVaultReference: Identifies the Azure key vault associated with a Batch account.
	KeyVaultReference *KeyVaultReference_STATUS `json:"keyVaultReference,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// LowPriorityCoreQuota: For accounts with PoolAllocationMode set to UserSubscription, quota is managed on the subscription
	// so this value is not returned.
	LowPriorityCoreQuota *int `json:"lowPriorityCoreQuota,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// NetworkProfile: The network profile only takes effect when publicNetworkAccess is enabled.
	NetworkProfile *NetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// NodeManagementEndpoint: The endpoint used by compute node to connect to the Batch node management service.
	NodeManagementEndpoint *string `json:"nodeManagementEndpoint,omitempty"`

	// PoolAllocationMode: The allocation mode for creating pools in the Batch account.
	PoolAllocationMode *PoolAllocationMode_STATUS `json:"poolAllocationMode,omitempty"`

	// PoolQuota: The pool quota for the Batch account.
	PoolQuota *int `json:"poolQuota,omitempty"`

	// PrivateEndpointConnections: List of private endpoint connections associated with the Batch account
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: The provisioned state of the resource
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: The network access type for operating on the resources in the Batch account.
	PublicNetworkAccess *BatchAccountProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BatchAccount_STATUS{}

// ConvertStatusFrom populates our BatchAccount_STATUS from the provided source
func (account *BatchAccount_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.BatchAccount_STATUS)
	if ok {
		// Populate our instance from source
		return account.AssignProperties_From_BatchAccount_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.BatchAccount_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = account.AssignProperties_From_BatchAccount_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BatchAccount_STATUS
func (account *BatchAccount_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.BatchAccount_STATUS)
	if ok {
		// Populate destination from our instance
		return account.AssignProperties_To_BatchAccount_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BatchAccount_STATUS{}
	err := account.AssignProperties_To_BatchAccount_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BatchAccount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (account *BatchAccount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BatchAccount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (account *BatchAccount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BatchAccount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BatchAccount_STATUS, got %T", armInput)
	}

	// Set property "AccountEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AccountEndpoint != nil {
			accountEndpoint := *typedInput.Properties.AccountEndpoint
			account.AccountEndpoint = &accountEndpoint
		}
	}

	// Set property "ActiveJobAndJobScheduleQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ActiveJobAndJobScheduleQuota != nil {
			activeJobAndJobScheduleQuota := *typedInput.Properties.ActiveJobAndJobScheduleQuota
			account.ActiveJobAndJobScheduleQuota = &activeJobAndJobScheduleQuota
		}
	}

	// Set property "AllowedAuthenticationModes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedAuthenticationModes {
			var temp string
			temp = string(item)
			account.AllowedAuthenticationModes = append(account.AllowedAuthenticationModes, AuthenticationMode_STATUS(temp))
		}
	}

	// Set property "AutoStorage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoStorage != nil {
			var autoStorage1 AutoStorageProperties_STATUS
			err := autoStorage1.PopulateFromARM(owner, *typedInput.Properties.AutoStorage)
			if err != nil {
				return err
			}
			autoStorage := autoStorage1
			account.AutoStorage = &autoStorage
		}
	}

	// no assignment for property "Conditions"

	// Set property "DedicatedCoreQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DedicatedCoreQuota != nil {
			dedicatedCoreQuota := *typedInput.Properties.DedicatedCoreQuota
			account.DedicatedCoreQuota = &dedicatedCoreQuota
		}
	}

	// Set property "DedicatedCoreQuotaPerVMFamily":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.DedicatedCoreQuotaPerVMFamily {
			var item1 VirtualMachineFamilyCoreQuota_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			account.DedicatedCoreQuotaPerVMFamily = append(account.DedicatedCoreQuotaPerVMFamily, item1)
		}
	}

	// Set property "DedicatedCoreQuotaPerVMFamilyEnforced":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DedicatedCoreQuotaPerVMFamilyEnforced != nil {
			dedicatedCoreQuotaPerVMFamilyEnforced := *typedInput.Properties.DedicatedCoreQuotaPerVMFamilyEnforced
			account.DedicatedCoreQuotaPerVMFamilyEnforced = &dedicatedCoreQuotaPerVMFamilyEnforced
		}
	}

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 EncryptionProperties_STATUS
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			account.Encryption = &encryption
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		account.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 BatchAccountIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		account.Identity = &identity
	}

	// Set property "KeyVaultReference":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReference != nil {
			var keyVaultReference1 KeyVaultReference_STATUS
			err := keyVaultReference1.PopulateFromARM(owner, *typedInput.Properties.KeyVaultReference)
			if err != nil {
				return err
			}
			keyVaultReference := keyVaultReference1
			account.KeyVaultReference = &keyVaultReference
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		account.Location = &location
	}

	// Set property "LowPriorityCoreQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LowPriorityCoreQuota != nil {
			lowPriorityCoreQuota := *typedInput.Properties.LowPriorityCoreQuota
			account.LowPriorityCoreQuota = &lowPriorityCoreQuota
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		account.Name = &name
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 NetworkProfile_STATUS
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			account.NetworkProfile = &networkProfile
		}
	}

	// Set property "NodeManagementEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeManagementEndpoint != nil {
			nodeManagementEndpoint := *typedInput.Properties.NodeManagementEndpoint
			account.NodeManagementEndpoint = &nodeManagementEndpoint
		}
	}

	// Set property "PoolAllocationMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PoolAllocationMode != nil {
			var temp string
			temp = string(*typedInput.Properties.PoolAllocationMode)
			poolAllocationMode := PoolAllocationMode_STATUS(temp)
			account.PoolAllocationMode = &poolAllocationMode
		}
	}

	// Set property "PoolQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PoolQuota != nil {
			poolQuota := *typedInput.Properties.PoolQuota
			account.PoolQuota = &poolQuota
		}
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			account.PrivateEndpointConnections = append(account.PrivateEndpointConnections, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			account.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := BatchAccountProperties_PublicNetworkAccess_STATUS(temp)
			account.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		account.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		account.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			account.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		account.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BatchAccount_STATUS populates our BatchAccount_STATUS from the provided source BatchAccount_STATUS
func (account *BatchAccount_STATUS) AssignProperties_From_BatchAccount_STATUS(source *storage.BatchAccount_STATUS) error {

	// AccountEndpoint
	account.AccountEndpoint = genruntime.ClonePointerToString(source.AccountEndpoint)

	// ActiveJobAndJobScheduleQuota
	account.ActiveJobAndJobScheduleQuota = genruntime.ClonePointerToInt(source.ActiveJobAndJobScheduleQuota)

	// AllowedAuthenticationModes
	if source.AllowedAuthenticationModes != nil {
		allowedAuthenticationModeList := make([]AuthenticationMode_STATUS, len(source.AllowedAuthenticationModes))
		for allowedAuthenticationModeIndex, allowedAuthenticationModeItem := range source.AllowedAuthenticationModes {
			allowedAuthenticationModeList[allowedAuthenticationModeIndex] = genruntime.ToEnum(allowedAuthenticationModeItem, authenticationMode_STATUS_Values)
		}
		account.AllowedAuthenticationModes = allowedAuthenticationModeList
	} else {
		account.AllowedAuthenticationModes = nil
	}

	// AutoStorage
	if source.AutoStorage != nil {
		var autoStorage AutoStorageProperties_STATUS
		err := autoStorage.AssignProperties_From_AutoStorageProperties_STATUS(source.AutoStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutoStorageProperties_STATUS() to populate field AutoStorage")
		}
		account.AutoStorage = &autoStorage
	} else {
		account.AutoStorage = nil
	}

	// Conditions
	account.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DedicatedCoreQuota
	account.DedicatedCoreQuota = genruntime.ClonePointerToInt(source.DedicatedCoreQuota)

	// DedicatedCoreQuotaPerVMFamily
	if source.DedicatedCoreQuotaPerVMFamily != nil {
		dedicatedCoreQuotaPerVMFamilyList := make([]VirtualMachineFamilyCoreQuota_STATUS, len(source.DedicatedCoreQuotaPerVMFamily))
		for dedicatedCoreQuotaPerVMFamilyIndex, dedicatedCoreQuotaPerVMFamilyItem := range source.DedicatedCoreQuotaPerVMFamily {
			var dedicatedCoreQuotaPerVMFamily VirtualMachineFamilyCoreQuota_STATUS
			err := dedicatedCoreQuotaPerVMFamily.AssignProperties_From_VirtualMachineFamilyCoreQuota_STATUS(&dedicatedCoreQuotaPerVMFamilyItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineFamilyCoreQuota_STATUS() to populate field DedicatedCoreQuotaPerVMFamily")
			}
			dedicatedCoreQuotaPerVMFamilyList[dedicatedCoreQuotaPerVMFamilyIndex] = dedicatedCoreQuotaPerVMFamily
		}
		account.DedicatedCoreQuotaPerVMFamily = dedicatedCoreQuotaPerVMFamilyList
	} else {
		account.DedicatedCoreQuotaPerVMFamily = nil
	}

	// DedicatedCoreQuotaPerVMFamilyEnforced
	if source.DedicatedCoreQuotaPerVMFamilyEnforced != nil {
		dedicatedCoreQuotaPerVMFamilyEnforced := *source.DedicatedCoreQuotaPerVMFamilyEnforced
		account.DedicatedCoreQuotaPerVMFamilyEnforced = &dedicatedCoreQuotaPerVMFamilyEnforced
	} else {
		account.DedicatedCoreQuotaPerVMFamilyEnforced = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionProperties_STATUS
		err := encryption.AssignProperties_From_EncryptionProperties_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionProperties_STATUS() to populate field Encryption")
		}
		account.Encryption = &encryption
	} else {
		account.Encryption = nil
	}

	// Id
	account.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity BatchAccountIdentity_STATUS
		err := identity.AssignProperties_From_BatchAccountIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BatchAccountIdentity_STATUS() to populate field Identity")
		}
		account.Identity = &identity
	} else {
		account.Identity = nil
	}

	// KeyVaultReference
	if source.KeyVaultReference != nil {
		var keyVaultReference KeyVaultReference_STATUS
		err := keyVaultReference.AssignProperties_From_KeyVaultReference_STATUS(source.KeyVaultReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultReference_STATUS() to populate field KeyVaultReference")
		}
		account.KeyVaultReference = &keyVaultReference
	} else {
		account.KeyVaultReference = nil
	}

	// Location
	account.Location = genruntime.ClonePointerToString(source.Location)

	// LowPriorityCoreQuota
	account.LowPriorityCoreQuota = genruntime.ClonePointerToInt(source.LowPriorityCoreQuota)

	// Name
	account.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_NetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		account.NetworkProfile = &networkProfile
	} else {
		account.NetworkProfile = nil
	}

	// NodeManagementEndpoint
	account.NodeManagementEndpoint = genruntime.ClonePointerToString(source.NodeManagementEndpoint)

	// PoolAllocationMode
	if source.PoolAllocationMode != nil {
		poolAllocationMode := *source.PoolAllocationMode
		poolAllocationModeTemp := genruntime.ToEnum(poolAllocationMode, poolAllocationMode_STATUS_Values)
		account.PoolAllocationMode = &poolAllocationModeTemp
	} else {
		account.PoolAllocationMode = nil
	}

	// PoolQuota
	account.PoolQuota = genruntime.ClonePointerToInt(source.PoolQuota)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		account.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		account.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		account.ProvisioningState = &provisioningStateTemp
	} else {
		account.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, batchAccountProperties_PublicNetworkAccess_STATUS_Values)
		account.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		account.PublicNetworkAccess = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		account.SystemData = &systemDatum
	} else {
		account.SystemData = nil
	}

	// Tags
	account.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	account.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BatchAccount_STATUS populates the provided destination BatchAccount_STATUS from our BatchAccount_STATUS
func (account *BatchAccount_STATUS) AssignProperties_To_BatchAccount_STATUS(destination *storage.BatchAccount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountEndpoint
	destination.AccountEndpoint = genruntime.ClonePointerToString(account.AccountEndpoint)

	// ActiveJobAndJobScheduleQuota
	destination.ActiveJobAndJobScheduleQuota = genruntime.ClonePointerToInt(account.ActiveJobAndJobScheduleQuota)

	// AllowedAuthenticationModes
	if account.AllowedAuthenticationModes != nil {
		allowedAuthenticationModeList := make([]string, len(account.AllowedAuthenticationModes))
		for allowedAuthenticationModeIndex, allowedAuthenticationModeItem := range account.AllowedAuthenticationModes {
			allowedAuthenticationModeList[allowedAuthenticationModeIndex] = string(allowedAuthenticationModeItem)
		}
		destination.AllowedAuthenticationModes = allowedAuthenticationModeList
	} else {
		destination.AllowedAuthenticationModes = nil
	}

	// AutoStorage
	if account.AutoStorage != nil {
		var autoStorage storage.AutoStorageProperties_STATUS
		err := account.AutoStorage.AssignProperties_To_AutoStorageProperties_STATUS(&autoStorage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutoStorageProperties_STATUS() to populate field AutoStorage")
		}
		destination.AutoStorage = &autoStorage
	} else {
		destination.AutoStorage = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(account.Conditions)

	// DedicatedCoreQuota
	destination.DedicatedCoreQuota = genruntime.ClonePointerToInt(account.DedicatedCoreQuota)

	// DedicatedCoreQuotaPerVMFamily
	if account.DedicatedCoreQuotaPerVMFamily != nil {
		dedicatedCoreQuotaPerVMFamilyList := make([]storage.VirtualMachineFamilyCoreQuota_STATUS, len(account.DedicatedCoreQuotaPerVMFamily))
		for dedicatedCoreQuotaPerVMFamilyIndex, dedicatedCoreQuotaPerVMFamilyItem := range account.DedicatedCoreQuotaPerVMFamily {
			var dedicatedCoreQuotaPerVMFamily storage.VirtualMachineFamilyCoreQuota_STATUS
			err := dedicatedCoreQuotaPerVMFamilyItem.AssignProperties_To_VirtualMachineFamilyCoreQuota_STATUS(&dedicatedCoreQuotaPerVMFamily)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineFamilyCoreQuota_STATUS() to populate field DedicatedCoreQuotaPerVMFamily")
			}
			dedicatedCoreQuotaPerVMFamilyList[dedicatedCoreQuotaPerVMFamilyIndex] = dedicatedCoreQuotaPerVMFamily
		}
		destination.DedicatedCoreQuotaPerVMFamily = dedicatedCoreQuotaPerVMFamilyList
	} else {
		destination.DedicatedCoreQuotaPerVMFamily = nil
	}

	// DedicatedCoreQuotaPerVMFamilyEnforced
	if account.DedicatedCoreQuotaPerVMFamilyEnforced != nil {
		dedicatedCoreQuotaPerVMFamilyEnforced := *account.DedicatedCoreQuotaPerVMFamilyEnforced
		destination.DedicatedCoreQuotaPerVMFamilyEnforced = &dedicatedCoreQuotaPerVMFamilyEnforced
	} else {
		destination.DedicatedCoreQuotaPerVMFamilyEnforced = nil
	}

	// Encryption
	if account.Encryption != nil {
		var encryption storage.EncryptionProperties_STATUS
		err := account.Encryption.AssignProperties_To_EncryptionProperties_STATUS(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionProperties_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(account.Id)

	// Identity
	if account.Identity != nil {
		var identity storage.BatchAccountIdentity_STATUS
		err := account.Identity.AssignProperties_To_BatchAccountIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BatchAccountIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyVaultReference
	if account.KeyVaultReference != nil {
		var keyVaultReference storage.KeyVaultReference_STATUS
		err := account.KeyVaultReference.AssignProperties_To_KeyVaultReference_STATUS(&keyVaultReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultReference_STATUS() to populate field KeyVaultReference")
		}
		destination.KeyVaultReference = &keyVaultReference
	} else {
		destination.KeyVaultReference = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(account.Location)

	// LowPriorityCoreQuota
	destination.LowPriorityCoreQuota = genruntime.ClonePointerToInt(account.LowPriorityCoreQuota)

	// Name
	destination.Name = genruntime.ClonePointerToString(account.Name)

	// NetworkProfile
	if account.NetworkProfile != nil {
		var networkProfile storage.NetworkProfile_STATUS
		err := account.NetworkProfile.AssignProperties_To_NetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeManagementEndpoint
	destination.NodeManagementEndpoint = genruntime.ClonePointerToString(account.NodeManagementEndpoint)

	// PoolAllocationMode
	if account.PoolAllocationMode != nil {
		poolAllocationMode := string(*account.PoolAllocationMode)
		destination.PoolAllocationMode = &poolAllocationMode
	} else {
		destination.PoolAllocationMode = nil
	}

	// PoolQuota
	destination.PoolQuota = genruntime.ClonePointerToInt(account.PoolQuota)

	// PrivateEndpointConnections
	if account.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(account.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range account.PrivateEndpointConnections {
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if account.ProvisioningState != nil {
		provisioningState := string(*account.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if account.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*account.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// SystemData
	if account.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := account.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(account.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(account.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The authentication mode for the Batch account.
// +kubebuilder:validation:Enum={"AAD","SharedKey","TaskAuthenticationToken"}
type AuthenticationMode string

const (
	AuthenticationMode_AAD                     = AuthenticationMode("AAD")
	AuthenticationMode_SharedKey               = AuthenticationMode("SharedKey")
	AuthenticationMode_TaskAuthenticationToken = AuthenticationMode("TaskAuthenticationToken")
)

// Mapping from string to AuthenticationMode
var authenticationMode_Values = map[string]AuthenticationMode{
	"aad":                     AuthenticationMode_AAD,
	"sharedkey":               AuthenticationMode_SharedKey,
	"taskauthenticationtoken": AuthenticationMode_TaskAuthenticationToken,
}

// The authentication mode for the Batch account.
type AuthenticationMode_STATUS string

const (
	AuthenticationMode_STATUS_AAD                     = AuthenticationMode_STATUS("AAD")
	AuthenticationMode_STATUS_SharedKey               = AuthenticationMode_STATUS("SharedKey")
	AuthenticationMode_STATUS_TaskAuthenticationToken = AuthenticationMode_STATUS("TaskAuthenticationToken")
)

// Mapping from string to AuthenticationMode_STATUS
var authenticationMode_STATUS_Values = map[string]AuthenticationMode_STATUS{
	"aad":                     AuthenticationMode_STATUS_AAD,
	"sharedkey":               AuthenticationMode_STATUS_SharedKey,
	"taskauthenticationtoken": AuthenticationMode_STATUS_TaskAuthenticationToken,
}

// The properties related to the auto-storage account.
type AutoStorageBaseProperties struct {
	// AuthenticationMode: The authentication mode which the Batch service will use to manage the auto-storage account.
	AuthenticationMode *AutoStorageBaseProperties_AuthenticationMode `json:"authenticationMode,omitempty"`

	// NodeIdentityReference: The identity referenced here must be assigned to pools which have compute nodes that need access
	// to auto-storage.
	NodeIdentityReference *ComputeNodeIdentityReference `json:"nodeIdentityReference,omitempty"`

	// +kubebuilder:validation:Required
	// StorageAccountReference: The resource ID of the storage account to be used for auto-storage account.
	StorageAccountReference *genruntime.ResourceReference `armReference:"StorageAccountId" json:"storageAccountReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoStorageBaseProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoStorageBaseProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AutoStorageBaseProperties{}

	// Set property "AuthenticationMode":
	if properties.AuthenticationMode != nil {
		var temp string
		temp = string(*properties.AuthenticationMode)
		authenticationMode := arm.AutoStorageBaseProperties_AuthenticationMode(temp)
		result.AuthenticationMode = &authenticationMode
	}

	// Set property "NodeIdentityReference":
	if properties.NodeIdentityReference != nil {
		nodeIdentityReference_ARM, err := properties.NodeIdentityReference.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nodeIdentityReference := *nodeIdentityReference_ARM.(*arm.ComputeNodeIdentityReference)
		result.NodeIdentityReference = &nodeIdentityReference
	}

	// Set property "StorageAccountId":
	if properties.StorageAccountReference != nil {
		storageAccountReferenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.StorageAccountReference)
		if err != nil {
			return nil, err
		}
		storageAccountReference := storageAccountReferenceARMID
		result.StorageAccountId = &storageAccountReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoStorageBaseProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoStorageBaseProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoStorageBaseProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoStorageBaseProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoStorageBaseProperties, got %T", armInput)
	}

	// Set property "AuthenticationMode":
	if typedInput.AuthenticationMode != nil {
		var temp string
		temp = string(*typedInput.AuthenticationMode)
		authenticationMode := AutoStorageBaseProperties_AuthenticationMode(temp)
		properties.AuthenticationMode = &authenticationMode
	}

	// Set property "NodeIdentityReference":
	if typedInput.NodeIdentityReference != nil {
		var nodeIdentityReference1 ComputeNodeIdentityReference
		err := nodeIdentityReference1.PopulateFromARM(owner, *typedInput.NodeIdentityReference)
		if err != nil {
			return err
		}
		nodeIdentityReference := nodeIdentityReference1
		properties.NodeIdentityReference = &nodeIdentityReference
	}

	// no assignment for property "StorageAccountReference"

	// No error
	return nil
}

// AssignProperties_From_AutoStorageBaseProperties populates our AutoStorageBaseProperties from the provided source AutoStorageBaseProperties
func (properties *AutoStorageBaseProperties) AssignProperties_From_AutoStorageBaseProperties(source *storage.AutoStorageBaseProperties) error {

	// AuthenticationMode
	if source.AuthenticationMode != nil {
		authenticationMode := *source.AuthenticationMode
		authenticationModeTemp := genruntime.ToEnum(authenticationMode, autoStorageBaseProperties_AuthenticationMode_Values)
		properties.AuthenticationMode = &authenticationModeTemp
	} else {
		properties.AuthenticationMode = nil
	}

	// NodeIdentityReference
	if source.NodeIdentityReference != nil {
		var nodeIdentityReference ComputeNodeIdentityReference
		err := nodeIdentityReference.AssignProperties_From_ComputeNodeIdentityReference(source.NodeIdentityReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeNodeIdentityReference() to populate field NodeIdentityReference")
		}
		properties.NodeIdentityReference = &nodeIdentityReference
	} else {
		properties.NodeIdentityReference = nil
	}

	// StorageAccountReference
	if source.StorageAccountReference != nil {
		storageAccountReference := source.StorageAccountReference.Copy()
		properties.StorageAccountReference = &storageAccountReference
	} else {
		properties.StorageAccountReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoStorageBaseProperties populates the provided destination AutoStorageBaseProperties from our AutoStorageBaseProperties
func (properties *AutoStorageBaseProperties) AssignProperties_To_AutoStorageBaseProperties(destination *storage.AutoStorageBaseProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationMode
	if properties.AuthenticationMode != nil {
		authenticationMode := string(*properties.AuthenticationMode)
		destination.AuthenticationMode = &authenticationMode
	} else {
		destination.AuthenticationMode = nil
	}

	// NodeIdentityReference
	if properties.NodeIdentityReference != nil {
		var nodeIdentityReference storage.ComputeNodeIdentityReference
		err := properties.NodeIdentityReference.AssignProperties_To_ComputeNodeIdentityReference(&nodeIdentityReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeNodeIdentityReference() to populate field NodeIdentityReference")
		}
		destination.NodeIdentityReference = &nodeIdentityReference
	} else {
		destination.NodeIdentityReference = nil
	}

	// StorageAccountReference
	if properties.StorageAccountReference != nil {
		storageAccountReference := properties.StorageAccountReference.Copy()
		destination.StorageAccountReference = &storageAccountReference
	} else {
		destination.StorageAccountReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoStorageProperties_STATUS populates our AutoStorageBaseProperties from the provided source AutoStorageProperties_STATUS
func (properties *AutoStorageBaseProperties) Initialize_From_AutoStorageProperties_STATUS(source *AutoStorageProperties_STATUS) error {

	// AuthenticationMode
	if source.AuthenticationMode != nil {
		authenticationMode := genruntime.ToEnum(string(*source.AuthenticationMode), autoStorageBaseProperties_AuthenticationMode_Values)
		properties.AuthenticationMode = &authenticationMode
	} else {
		properties.AuthenticationMode = nil
	}

	// NodeIdentityReference
	if source.NodeIdentityReference != nil {
		var nodeIdentityReference ComputeNodeIdentityReference
		err := nodeIdentityReference.Initialize_From_ComputeNodeIdentityReference_STATUS(source.NodeIdentityReference)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ComputeNodeIdentityReference_STATUS() to populate field NodeIdentityReference")
		}
		properties.NodeIdentityReference = &nodeIdentityReference
	} else {
		properties.NodeIdentityReference = nil
	}

	// StorageAccountReference
	if source.StorageAccountId != nil {
		storageAccountReference := genruntime.CreateResourceReferenceFromARMID(*source.StorageAccountId)
		properties.StorageAccountReference = &storageAccountReference
	} else {
		properties.StorageAccountReference = nil
	}

	// No error
	return nil
}

// Contains information about the auto-storage account associated with a Batch account.
type AutoStorageProperties_STATUS struct {
	// AuthenticationMode: The authentication mode which the Batch service will use to manage the auto-storage account.
	AuthenticationMode *AutoStorageProperties_AuthenticationMode_STATUS `json:"authenticationMode,omitempty"`

	// LastKeySync: The UTC time at which storage keys were last synchronized with the Batch account.
	LastKeySync *string `json:"lastKeySync,omitempty"`

	// NodeIdentityReference: The identity referenced here must be assigned to pools which have compute nodes that need access
	// to auto-storage.
	NodeIdentityReference *ComputeNodeIdentityReference_STATUS `json:"nodeIdentityReference,omitempty"`

	// StorageAccountId: The resource ID of the storage account to be used for auto-storage account.
	StorageAccountId *string `json:"storageAccountId,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoStorageProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoStorageProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoStorageProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoStorageProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoStorageProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoStorageProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthenticationMode":
	if typedInput.AuthenticationMode != nil {
		var temp string
		temp = string(*typedInput.AuthenticationMode)
		authenticationMode := AutoStorageProperties_AuthenticationMode_STATUS(temp)
		properties.AuthenticationMode = &authenticationMode
	}

	// Set property "LastKeySync":
	if typedInput.LastKeySync != nil {
		lastKeySync := *typedInput.LastKeySync
		properties.LastKeySync = &lastKeySync
	}

	// Set property "NodeIdentityReference":
	if typedInput.NodeIdentityReference != nil {
		var nodeIdentityReference1 ComputeNodeIdentityReference_STATUS
		err := nodeIdentityReference1.PopulateFromARM(owner, *typedInput.NodeIdentityReference)
		if err != nil {
			return err
		}
		nodeIdentityReference := nodeIdentityReference1
		properties.NodeIdentityReference = &nodeIdentityReference
	}

	// Set property "StorageAccountId":
	if typedInput.StorageAccountId != nil {
		storageAccountId := *typedInput.StorageAccountId
		properties.StorageAccountId = &storageAccountId
	}

	// No error
	return nil
}

// AssignProperties_From_AutoStorageProperties_STATUS populates our AutoStorageProperties_STATUS from the provided source AutoStorageProperties_STATUS
func (properties *AutoStorageProperties_STATUS) AssignProperties_From_AutoStorageProperties_STATUS(source *storage.AutoStorageProperties_STATUS) error {

	// AuthenticationMode
	if source.AuthenticationMode != nil {
		authenticationMode := *source.AuthenticationMode
		authenticationModeTemp := genruntime.ToEnum(authenticationMode, autoStorageProperties_AuthenticationMode_STATUS_Values)
		properties.AuthenticationMode = &authenticationModeTemp
	} else {
		properties.AuthenticationMode = nil
	}

	// LastKeySync
	properties.LastKeySync = genruntime.ClonePointerToString(source.LastKeySync)

	// NodeIdentityReference
	if source.NodeIdentityReference != nil {
		var nodeIdentityReference ComputeNodeIdentityReference_STATUS
		err := nodeIdentityReference.AssignProperties_From_ComputeNodeIdentityReference_STATUS(source.NodeIdentityReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeNodeIdentityReference_STATUS() to populate field NodeIdentityReference")
		}
		properties.NodeIdentityReference = &nodeIdentityReference
	} else {
		properties.NodeIdentityReference = nil
	}

	// StorageAccountId
	properties.StorageAccountId = genruntime.ClonePointerToString(source.StorageAccountId)

	// No error
	return nil
}

// AssignProperties_To_AutoStorageProperties_STATUS populates the provided destination AutoStorageProperties_STATUS from our AutoStorageProperties_STATUS
func (properties *AutoStorageProperties_STATUS) AssignProperties_To_AutoStorageProperties_STATUS(destination *storage.AutoStorageProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationMode
	if properties.AuthenticationMode != nil {
		authenticationMode := string(*properties.AuthenticationMode)
		destination.AuthenticationMode = &authenticationMode
	} else {
		destination.AuthenticationMode = nil
	}

	// LastKeySync
	destination.LastKeySync = genruntime.ClonePointerToString(properties.LastKeySync)

	// NodeIdentityReference
	if properties.NodeIdentityReference != nil {
		var nodeIdentityReference storage.ComputeNodeIdentityReference_STATUS
		err := properties.NodeIdentityReference.AssignProperties_To_ComputeNodeIdentityReference_STATUS(&nodeIdentityReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeNodeIdentityReference_STATUS() to populate field NodeIdentityReference")
		}
		destination.NodeIdentityReference = &nodeIdentityReference
	} else {
		destination.NodeIdentityReference = nil
	}

	// StorageAccountId
	destination.StorageAccountId = genruntime.ClonePointerToString(properties.StorageAccountId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","SecuredByPerimeter"}
type BatchAccountCreateProperties_PublicNetworkAccess string

const (
	BatchAccountCreateProperties_PublicNetworkAccess_Disabled           = BatchAccountCreateProperties_PublicNetworkAccess("Disabled")
	BatchAccountCreateProperties_PublicNetworkAccess_Enabled            = BatchAccountCreateProperties_PublicNetworkAccess("Enabled")
	BatchAccountCreateProperties_PublicNetworkAccess_SecuredByPerimeter = BatchAccountCreateProperties_PublicNetworkAccess("SecuredByPerimeter")
)

// Mapping from string to BatchAccountCreateProperties_PublicNetworkAccess
var batchAccountCreateProperties_PublicNetworkAccess_Values = map[string]BatchAccountCreateProperties_PublicNetworkAccess{
	"disabled":           BatchAccountCreateProperties_PublicNetworkAccess_Disabled,
	"enabled":            BatchAccountCreateProperties_PublicNetworkAccess_Enabled,
	"securedbyperimeter": BatchAccountCreateProperties_PublicNetworkAccess_SecuredByPerimeter,
}

// The identity of the Batch account, if configured. This is used when the user specifies 'Microsoft.KeyVault' as their
// Batch account encryption configuration or when `ManagedIdentity` is selected as the auto-storage authentication mode.
type BatchAccountIdentity struct {
	// +kubebuilder:validation:Required
	// Type: The type of identity used for the Batch account.
	Type *ResourceIdentityType `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the Batch account.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &BatchAccountIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *BatchAccountIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.BatchAccountIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ResourceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *BatchAccountIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BatchAccountIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *BatchAccountIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BatchAccountIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BatchAccountIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ResourceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_BatchAccountIdentity populates our BatchAccountIdentity from the provided source BatchAccountIdentity
func (identity *BatchAccountIdentity) AssignProperties_From_BatchAccountIdentity(source *storage.BatchAccountIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, resourceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BatchAccountIdentity populates the provided destination BatchAccountIdentity from our BatchAccountIdentity
func (identity *BatchAccountIdentity) AssignProperties_To_BatchAccountIdentity(destination *storage.BatchAccountIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BatchAccountIdentity_STATUS populates our BatchAccountIdentity from the provided source BatchAccountIdentity_STATUS
func (identity *BatchAccountIdentity) Initialize_From_BatchAccountIdentity_STATUS(source *BatchAccountIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), resourceIdentityType_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// The identity of the Batch account, if configured. This is used when the user specifies 'Microsoft.KeyVault' as their
// Batch account encryption configuration or when `ManagedIdentity` is selected as the auto-storage authentication mode.
type BatchAccountIdentity_STATUS struct {
	// PrincipalId: The principal id of the Batch account. This property will only be provided for a system assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id associated with the Batch account. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the Batch account.
	Type *ResourceIdentityType_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the Batch account.
	UserAssignedIdentities map[string]UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &BatchAccountIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *BatchAccountIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BatchAccountIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *BatchAccountIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BatchAccountIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BatchAccountIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ResourceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_BatchAccountIdentity_STATUS populates our BatchAccountIdentity_STATUS from the provided source BatchAccountIdentity_STATUS
func (identity *BatchAccountIdentity_STATUS) AssignProperties_From_BatchAccountIdentity_STATUS(source *storage.BatchAccountIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, resourceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			var userAssignedIdentity UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BatchAccountIdentity_STATUS populates the provided destination BatchAccountIdentity_STATUS from our BatchAccountIdentity_STATUS
func (identity *BatchAccountIdentity_STATUS) AssignProperties_To_BatchAccountIdentity_STATUS(destination *storage.BatchAccountIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type BatchAccountOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_BatchAccountOperatorSpec populates our BatchAccountOperatorSpec from the provided source BatchAccountOperatorSpec
func (operator *BatchAccountOperatorSpec) AssignProperties_From_BatchAccountOperatorSpec(source *storage.BatchAccountOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BatchAccountOperatorSpec populates the provided destination BatchAccountOperatorSpec from our BatchAccountOperatorSpec
func (operator *BatchAccountOperatorSpec) AssignProperties_To_BatchAccountOperatorSpec(destination *storage.BatchAccountOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BatchAccountProperties_PublicNetworkAccess_STATUS string

const (
	BatchAccountProperties_PublicNetworkAccess_STATUS_Disabled           = BatchAccountProperties_PublicNetworkAccess_STATUS("Disabled")
	BatchAccountProperties_PublicNetworkAccess_STATUS_Enabled            = BatchAccountProperties_PublicNetworkAccess_STATUS("Enabled")
	BatchAccountProperties_PublicNetworkAccess_STATUS_SecuredByPerimeter = BatchAccountProperties_PublicNetworkAccess_STATUS("SecuredByPerimeter")
)

// Mapping from string to BatchAccountProperties_PublicNetworkAccess_STATUS
var batchAccountProperties_PublicNetworkAccess_STATUS_Values = map[string]BatchAccountProperties_PublicNetworkAccess_STATUS{
	"disabled":           BatchAccountProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":            BatchAccountProperties_PublicNetworkAccess_STATUS_Enabled,
	"securedbyperimeter": BatchAccountProperties_PublicNetworkAccess_STATUS_SecuredByPerimeter,
}

// Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft
// managed key. For additional control, a customer-managed key can be used instead.
type EncryptionProperties struct {
	// KeySource: Type of the key source.
	KeySource *KeySource `json:"keySource,omitempty"`

	// KeyVaultProperties: Additional details when using Microsoft.KeyVault
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EncryptionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.EncryptionProperties{}

	// Set property "KeySource":
	if properties.KeySource != nil {
		var temp string
		temp = string(*properties.KeySource)
		keySource := arm.KeySource(temp)
		result.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if properties.KeyVaultProperties != nil {
		keyVaultProperties_ARM, err := properties.KeyVaultProperties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultProperties := *keyVaultProperties_ARM.(*arm.KeyVaultProperties)
		result.KeyVaultProperties = &keyVaultProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionProperties, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := KeySource(temp)
		properties.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 KeyVaultProperties
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		properties.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperties populates our EncryptionProperties from the provided source EncryptionProperties
func (properties *EncryptionProperties) AssignProperties_From_EncryptionProperties(source *storage.EncryptionProperties) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, keySource_Values)
		properties.KeySource = &keySourceTemp
	} else {
		properties.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties
		err := keyVaultProperty.AssignProperties_From_KeyVaultProperties(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		properties.KeyVaultProperties = &keyVaultProperty
	} else {
		properties.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperties populates the provided destination EncryptionProperties from our EncryptionProperties
func (properties *EncryptionProperties) AssignProperties_To_EncryptionProperties(destination *storage.EncryptionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if properties.KeySource != nil {
		keySource := string(*properties.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if properties.KeyVaultProperties != nil {
		var keyVaultProperty storage.KeyVaultProperties
		err := properties.KeyVaultProperties.AssignProperties_To_KeyVaultProperties(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionProperties_STATUS populates our EncryptionProperties from the provided source EncryptionProperties_STATUS
func (properties *EncryptionProperties) Initialize_From_EncryptionProperties_STATUS(source *EncryptionProperties_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := genruntime.ToEnum(string(*source.KeySource), keySource_Values)
		properties.KeySource = &keySource
	} else {
		properties.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties
		err := keyVaultProperty.Initialize_From_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		properties.KeyVaultProperties = &keyVaultProperty
	} else {
		properties.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// Configures how customer data is encrypted inside the Batch account. By default, accounts are encrypted using a Microsoft
// managed key. For additional control, a customer-managed key can be used instead.
type EncryptionProperties_STATUS struct {
	// KeySource: Type of the key source.
	KeySource *KeySource_STATUS `json:"keySource,omitempty"`

	// KeyVaultProperties: Additional details when using Microsoft.KeyVault
	KeyVaultProperties *KeyVaultProperties_STATUS `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionProperties_STATUS, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := KeySource_STATUS(temp)
		properties.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 KeyVaultProperties_STATUS
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		properties.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperties_STATUS populates our EncryptionProperties_STATUS from the provided source EncryptionProperties_STATUS
func (properties *EncryptionProperties_STATUS) AssignProperties_From_EncryptionProperties_STATUS(source *storage.EncryptionProperties_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, keySource_STATUS_Values)
		properties.KeySource = &keySourceTemp
	} else {
		properties.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties_STATUS
		err := keyVaultProperty.AssignProperties_From_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		properties.KeyVaultProperties = &keyVaultProperty
	} else {
		properties.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperties_STATUS populates the provided destination EncryptionProperties_STATUS from our EncryptionProperties_STATUS
func (properties *EncryptionProperties_STATUS) AssignProperties_To_EncryptionProperties_STATUS(destination *storage.EncryptionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if properties.KeySource != nil {
		keySource := string(*properties.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if properties.KeyVaultProperties != nil {
		var keyVaultProperty storage.KeyVaultProperties_STATUS
		err := properties.KeyVaultProperties.AssignProperties_To_KeyVaultProperties_STATUS(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identifies the Azure key vault associated with a Batch account.
type KeyVaultReference struct {
	// +kubebuilder:validation:Required
	// Reference: The resource ID of the Azure key vault associated with the Batch account.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// +kubebuilder:validation:Required
	// Url: The URL of the Azure key vault associated with the Batch account.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *KeyVaultReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.KeyVaultReference{}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}

	// Set property "Url":
	if reference.Url != nil {
		url := *reference.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultReference, got %T", armInput)
	}

	// no assignment for property "Reference"

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		reference.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultReference populates our KeyVaultReference from the provided source KeyVaultReference
func (reference *KeyVaultReference) AssignProperties_From_KeyVaultReference(source *storage.KeyVaultReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Url
	reference.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultReference populates the provided destination KeyVaultReference from our KeyVaultReference
func (reference *KeyVaultReference) AssignProperties_To_KeyVaultReference(destination *storage.KeyVaultReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Url
	destination.Url = genruntime.ClonePointerToString(reference.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KeyVaultReference_STATUS populates our KeyVaultReference from the provided source KeyVaultReference_STATUS
func (reference *KeyVaultReference) Initialize_From_KeyVaultReference_STATUS(source *KeyVaultReference_STATUS) error {

	// Reference
	if source.Id != nil {
		referenceTemp := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Url
	reference.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// Identifies the Azure key vault associated with a Batch account.
type KeyVaultReference_STATUS struct {
	// Id: The resource ID of the Azure key vault associated with the Batch account.
	Id *string `json:"id,omitempty"`

	// Url: The URL of the Azure key vault associated with the Batch account.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultReference_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		reference.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultReference_STATUS populates our KeyVaultReference_STATUS from the provided source KeyVaultReference_STATUS
func (reference *KeyVaultReference_STATUS) AssignProperties_From_KeyVaultReference_STATUS(source *storage.KeyVaultReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Url
	reference.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultReference_STATUS populates the provided destination KeyVaultReference_STATUS from our KeyVaultReference_STATUS
func (reference *KeyVaultReference_STATUS) AssignProperties_To_KeyVaultReference_STATUS(destination *storage.KeyVaultReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Url
	destination.Url = genruntime.ClonePointerToString(reference.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network profile for Batch account, which contains network rule settings for each endpoint.
type NetworkProfile struct {
	// AccountAccess: Network access profile for batchAccount endpoint (Batch account data plane API).
	AccountAccess *EndpointAccessProfile `json:"accountAccess,omitempty"`

	// NodeManagementAccess: Network access profile for nodeManagement endpoint (Batch service managing compute nodes for Batch
	// pools).
	NodeManagementAccess *EndpointAccessProfile `json:"nodeManagementAccess,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.NetworkProfile{}

	// Set property "AccountAccess":
	if profile.AccountAccess != nil {
		accountAccess_ARM, err := profile.AccountAccess.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		accountAccess := *accountAccess_ARM.(*arm.EndpointAccessProfile)
		result.AccountAccess = &accountAccess
	}

	// Set property "NodeManagementAccess":
	if profile.NodeManagementAccess != nil {
		nodeManagementAccess_ARM, err := profile.NodeManagementAccess.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		nodeManagementAccess := *nodeManagementAccess_ARM.(*arm.EndpointAccessProfile)
		result.NodeManagementAccess = &nodeManagementAccess
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkProfile, got %T", armInput)
	}

	// Set property "AccountAccess":
	if typedInput.AccountAccess != nil {
		var accountAccess1 EndpointAccessProfile
		err := accountAccess1.PopulateFromARM(owner, *typedInput.AccountAccess)
		if err != nil {
			return err
		}
		accountAccess := accountAccess1
		profile.AccountAccess = &accountAccess
	}

	// Set property "NodeManagementAccess":
	if typedInput.NodeManagementAccess != nil {
		var nodeManagementAccess1 EndpointAccessProfile
		err := nodeManagementAccess1.PopulateFromARM(owner, *typedInput.NodeManagementAccess)
		if err != nil {
			return err
		}
		nodeManagementAccess := nodeManagementAccess1
		profile.NodeManagementAccess = &nodeManagementAccess
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkProfile populates our NetworkProfile from the provided source NetworkProfile
func (profile *NetworkProfile) AssignProperties_From_NetworkProfile(source *storage.NetworkProfile) error {

	// AccountAccess
	if source.AccountAccess != nil {
		var accountAccess EndpointAccessProfile
		err := accountAccess.AssignProperties_From_EndpointAccessProfile(source.AccountAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EndpointAccessProfile() to populate field AccountAccess")
		}
		profile.AccountAccess = &accountAccess
	} else {
		profile.AccountAccess = nil
	}

	// NodeManagementAccess
	if source.NodeManagementAccess != nil {
		var nodeManagementAccess EndpointAccessProfile
		err := nodeManagementAccess.AssignProperties_From_EndpointAccessProfile(source.NodeManagementAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EndpointAccessProfile() to populate field NodeManagementAccess")
		}
		profile.NodeManagementAccess = &nodeManagementAccess
	} else {
		profile.NodeManagementAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile populates the provided destination NetworkProfile from our NetworkProfile
func (profile *NetworkProfile) AssignProperties_To_NetworkProfile(destination *storage.NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountAccess
	if profile.AccountAccess != nil {
		var accountAccess storage.EndpointAccessProfile
		err := profile.AccountAccess.AssignProperties_To_EndpointAccessProfile(&accountAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EndpointAccessProfile() to populate field AccountAccess")
		}
		destination.AccountAccess = &accountAccess
	} else {
		destination.AccountAccess = nil
	}

	// NodeManagementAccess
	if profile.NodeManagementAccess != nil {
		var nodeManagementAccess storage.EndpointAccessProfile
		err := profile.NodeManagementAccess.AssignProperties_To_EndpointAccessProfile(&nodeManagementAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EndpointAccessProfile() to populate field NodeManagementAccess")
		}
		destination.NodeManagementAccess = &nodeManagementAccess
	} else {
		destination.NodeManagementAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkProfile_STATUS populates our NetworkProfile from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile) Initialize_From_NetworkProfile_STATUS(source *NetworkProfile_STATUS) error {

	// AccountAccess
	if source.AccountAccess != nil {
		var accountAccess EndpointAccessProfile
		err := accountAccess.Initialize_From_EndpointAccessProfile_STATUS(source.AccountAccess)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EndpointAccessProfile_STATUS() to populate field AccountAccess")
		}
		profile.AccountAccess = &accountAccess
	} else {
		profile.AccountAccess = nil
	}

	// NodeManagementAccess
	if source.NodeManagementAccess != nil {
		var nodeManagementAccess EndpointAccessProfile
		err := nodeManagementAccess.Initialize_From_EndpointAccessProfile_STATUS(source.NodeManagementAccess)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EndpointAccessProfile_STATUS() to populate field NodeManagementAccess")
		}
		profile.NodeManagementAccess = &nodeManagementAccess
	} else {
		profile.NodeManagementAccess = nil
	}

	// No error
	return nil
}

// Network profile for Batch account, which contains network rule settings for each endpoint.
type NetworkProfile_STATUS struct {
	// AccountAccess: Network access profile for batchAccount endpoint (Batch account data plane API).
	AccountAccess *EndpointAccessProfile_STATUS `json:"accountAccess,omitempty"`

	// NodeManagementAccess: Network access profile for nodeManagement endpoint (Batch service managing compute nodes for Batch
	// pools).
	NodeManagementAccess *EndpointAccessProfile_STATUS `json:"nodeManagementAccess,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkProfile_STATUS, got %T", armInput)
	}

	// Set property "AccountAccess":
	if typedInput.AccountAccess != nil {
		var accountAccess1 EndpointAccessProfile_STATUS
		err := accountAccess1.PopulateFromARM(owner, *typedInput.AccountAccess)
		if err != nil {
			return err
		}
		accountAccess := accountAccess1
		profile.AccountAccess = &accountAccess
	}

	// Set property "NodeManagementAccess":
	if typedInput.NodeManagementAccess != nil {
		var nodeManagementAccess1 EndpointAccessProfile_STATUS
		err := nodeManagementAccess1.PopulateFromARM(owner, *typedInput.NodeManagementAccess)
		if err != nil {
			return err
		}
		nodeManagementAccess := nodeManagementAccess1
		profile.NodeManagementAccess = &nodeManagementAccess
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkProfile_STATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_From_NetworkProfile_STATUS(source *storage.NetworkProfile_STATUS) error {

	// AccountAccess
	if source.AccountAccess != nil {
		var accountAccess EndpointAccessProfile_STATUS
		err := accountAccess.AssignProperties_From_EndpointAccessProfile_STATUS(source.AccountAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EndpointAccessProfile_STATUS() to populate field AccountAccess")
		}
		profile.AccountAccess = &accountAccess
	} else {
		profile.AccountAccess = nil
	}

	// NodeManagementAccess
	if source.NodeManagementAccess != nil {
		var nodeManagementAccess EndpointAccessProfile_STATUS
		err := nodeManagementAccess.AssignProperties_From_EndpointAccessProfile_STATUS(source.NodeManagementAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EndpointAccessProfile_STATUS() to populate field NodeManagementAccess")
		}
		profile.NodeManagementAccess = &nodeManagementAccess
	} else {
		profile.NodeManagementAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile_STATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_To_NetworkProfile_STATUS(destination *storage.NetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountAccess
	if profile.AccountAccess != nil {
		var accountAccess storage.EndpointAccessProfile_STATUS
		err := profile.AccountAccess.AssignProperties_To_EndpointAccessProfile_STATUS(&accountAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EndpointAccessProfile_STATUS() to populate field AccountAccess")
		}
		destination.AccountAccess = &accountAccess
	} else {
		destination.AccountAccess = nil
	}

	// NodeManagementAccess
	if profile.NodeManagementAccess != nil {
		var nodeManagementAccess storage.EndpointAccessProfile_STATUS
		err := profile.NodeManagementAccess.AssignProperties_To_EndpointAccessProfile_STATUS(&nodeManagementAccess)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EndpointAccessProfile_STATUS() to populate field NodeManagementAccess")
		}
		destination.NodeManagementAccess = &nodeManagementAccess
	} else {
		destination.NodeManagementAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The allocation mode for creating pools in the Batch account.
// +kubebuilder:validation:Enum={"BatchService","UserSubscription"}
type PoolAllocationMode string

const (
	PoolAllocationMode_BatchService     = PoolAllocationMode("BatchService")
	PoolAllocationMode_UserSubscription = PoolAllocationMode("UserSubscription")
)

// Mapping from string to PoolAllocationMode
var poolAllocationMode_Values = map[string]PoolAllocationMode{
	"batchservice":     PoolAllocationMode_BatchService,
	"usersubscription": PoolAllocationMode_UserSubscription,
}

// The allocation mode for creating pools in the Batch account.
type PoolAllocationMode_STATUS string

const (
	PoolAllocationMode_STATUS_BatchService     = PoolAllocationMode_STATUS("BatchService")
	PoolAllocationMode_STATUS_UserSubscription = PoolAllocationMode_STATUS("UserSubscription")
)

// Mapping from string to PoolAllocationMode_STATUS
var poolAllocationMode_STATUS_Values = map[string]PoolAllocationMode_STATUS{
	"batchservice":     PoolAllocationMode_STATUS_BatchService,
	"usersubscription": PoolAllocationMode_STATUS_UserSubscription,
}

// Contains information about a private link resource.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The provisioned state of the resource
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Cancelled = ProvisioningState_STATUS("Cancelled")
	ProvisioningState_STATUS_Creating  = ProvisioningState_STATUS("Creating")
	ProvisioningState_STATUS_Deleting  = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed    = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Invalid   = ProvisioningState_STATUS("Invalid")
	ProvisioningState_STATUS_Succeeded = ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"cancelled": ProvisioningState_STATUS_Cancelled,
	"creating":  ProvisioningState_STATUS_Creating,
	"deleting":  ProvisioningState_STATUS_Deleting,
	"failed":    ProvisioningState_STATUS_Failed,
	"invalid":   ProvisioningState_STATUS_Invalid,
	"succeeded": ProvisioningState_STATUS_Succeeded,
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A VM Family and its associated core quota for the Batch account.
type VirtualMachineFamilyCoreQuota_STATUS struct {
	// CoreQuota: The core quota for the VM family for the Batch account.
	CoreQuota *int `json:"coreQuota,omitempty"`

	// Name: The Virtual Machine family name.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineFamilyCoreQuota_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (quota *VirtualMachineFamilyCoreQuota_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineFamilyCoreQuota_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (quota *VirtualMachineFamilyCoreQuota_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineFamilyCoreQuota_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineFamilyCoreQuota_STATUS, got %T", armInput)
	}

	// Set property "CoreQuota":
	if typedInput.CoreQuota != nil {
		coreQuota := *typedInput.CoreQuota
		quota.CoreQuota = &coreQuota
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		quota.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineFamilyCoreQuota_STATUS populates our VirtualMachineFamilyCoreQuota_STATUS from the provided source VirtualMachineFamilyCoreQuota_STATUS
func (quota *VirtualMachineFamilyCoreQuota_STATUS) AssignProperties_From_VirtualMachineFamilyCoreQuota_STATUS(source *storage.VirtualMachineFamilyCoreQuota_STATUS) error {

	// CoreQuota
	quota.CoreQuota = genruntime.ClonePointerToInt(source.CoreQuota)

	// Name
	quota.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineFamilyCoreQuota_STATUS populates the provided destination VirtualMachineFamilyCoreQuota_STATUS from our VirtualMachineFamilyCoreQuota_STATUS
func (quota *VirtualMachineFamilyCoreQuota_STATUS) AssignProperties_To_VirtualMachineFamilyCoreQuota_STATUS(destination *storage.VirtualMachineFamilyCoreQuota_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CoreQuota
	destination.CoreQuota = genruntime.ClonePointerToInt(quota.CoreQuota)

	// Name
	destination.Name = genruntime.ClonePointerToString(quota.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"BatchAccountManagedIdentity","StorageKeys"}
type AutoStorageBaseProperties_AuthenticationMode string

const (
	AutoStorageBaseProperties_AuthenticationMode_BatchAccountManagedIdentity = AutoStorageBaseProperties_AuthenticationMode("BatchAccountManagedIdentity")
	AutoStorageBaseProperties_AuthenticationMode_StorageKeys                 = AutoStorageBaseProperties_AuthenticationMode("StorageKeys")
)

// Mapping from string to AutoStorageBaseProperties_AuthenticationMode
var autoStorageBaseProperties_AuthenticationMode_Values = map[string]AutoStorageBaseProperties_AuthenticationMode{
	"batchaccountmanagedidentity": AutoStorageBaseProperties_AuthenticationMode_BatchAccountManagedIdentity,
	"storagekeys":                 AutoStorageBaseProperties_AuthenticationMode_StorageKeys,
}

type AutoStorageProperties_AuthenticationMode_STATUS string

const (
	AutoStorageProperties_AuthenticationMode_STATUS_BatchAccountManagedIdentity = AutoStorageProperties_AuthenticationMode_STATUS("BatchAccountManagedIdentity")
	AutoStorageProperties_AuthenticationMode_STATUS_StorageKeys                 = AutoStorageProperties_AuthenticationMode_STATUS("StorageKeys")
)

// Mapping from string to AutoStorageProperties_AuthenticationMode_STATUS
var autoStorageProperties_AuthenticationMode_STATUS_Values = map[string]AutoStorageProperties_AuthenticationMode_STATUS{
	"batchaccountmanagedidentity": AutoStorageProperties_AuthenticationMode_STATUS_BatchAccountManagedIdentity,
	"storagekeys":                 AutoStorageProperties_AuthenticationMode_STATUS_StorageKeys,
}

// The reference to a user assigned identity associated with the Batch pool which a compute node will use.
type ComputeNodeIdentityReference struct {
	// ResourceReference: The ARM resource id of the user assigned identity.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeNodeIdentityReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ComputeNodeIdentityReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ComputeNodeIdentityReference{}

	// Set property "ResourceId":
	if reference.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ComputeNodeIdentityReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeNodeIdentityReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ComputeNodeIdentityReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ComputeNodeIdentityReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeNodeIdentityReference, got %T", armInput)
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_ComputeNodeIdentityReference populates our ComputeNodeIdentityReference from the provided source ComputeNodeIdentityReference
func (reference *ComputeNodeIdentityReference) AssignProperties_From_ComputeNodeIdentityReference(source *storage.ComputeNodeIdentityReference) error {

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		reference.ResourceReference = &resourceReference
	} else {
		reference.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeNodeIdentityReference populates the provided destination ComputeNodeIdentityReference from our ComputeNodeIdentityReference
func (reference *ComputeNodeIdentityReference) AssignProperties_To_ComputeNodeIdentityReference(destination *storage.ComputeNodeIdentityReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceReference
	if reference.ResourceReference != nil {
		resourceReference := reference.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeNodeIdentityReference_STATUS populates our ComputeNodeIdentityReference from the provided source ComputeNodeIdentityReference_STATUS
func (reference *ComputeNodeIdentityReference) Initialize_From_ComputeNodeIdentityReference_STATUS(source *ComputeNodeIdentityReference_STATUS) error {

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		reference.ResourceReference = &resourceReference
	} else {
		reference.ResourceReference = nil
	}

	// No error
	return nil
}

// The reference to a user assigned identity associated with the Batch pool which a compute node will use.
type ComputeNodeIdentityReference_STATUS struct {
	// ResourceId: The ARM resource id of the user assigned identity.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeNodeIdentityReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ComputeNodeIdentityReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeNodeIdentityReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ComputeNodeIdentityReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeNodeIdentityReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeNodeIdentityReference_STATUS, got %T", armInput)
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		reference.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeNodeIdentityReference_STATUS populates our ComputeNodeIdentityReference_STATUS from the provided source ComputeNodeIdentityReference_STATUS
func (reference *ComputeNodeIdentityReference_STATUS) AssignProperties_From_ComputeNodeIdentityReference_STATUS(source *storage.ComputeNodeIdentityReference_STATUS) error {

	// ResourceId
	reference.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_ComputeNodeIdentityReference_STATUS populates the provided destination ComputeNodeIdentityReference_STATUS from our ComputeNodeIdentityReference_STATUS
func (reference *ComputeNodeIdentityReference_STATUS) AssignProperties_To_ComputeNodeIdentityReference_STATUS(destination *storage.ComputeNodeIdentityReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(reference.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network access profile for Batch endpoint.
type EndpointAccessProfile struct {
	// +kubebuilder:validation:Required
	// DefaultAction: Default action for endpoint access. It is only applicable when publicNetworkAccess is enabled.
	DefaultAction *EndpointAccessDefaultAction `json:"defaultAction,omitempty"`

	// IpRules: Array of IP ranges to filter client IP address.
	IpRules []IPRule `json:"ipRules,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointAccessProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *EndpointAccessProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.EndpointAccessProfile{}

	// Set property "DefaultAction":
	if profile.DefaultAction != nil {
		var temp string
		temp = string(*profile.DefaultAction)
		defaultAction := arm.EndpointAccessDefaultAction(temp)
		result.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range profile.IpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpRules = append(result.IpRules, *item_ARM.(*arm.IPRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *EndpointAccessProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointAccessProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *EndpointAccessProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointAccessProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointAccessProfile, got %T", armInput)
	}

	// Set property "DefaultAction":
	if typedInput.DefaultAction != nil {
		var temp string
		temp = string(*typedInput.DefaultAction)
		defaultAction := EndpointAccessDefaultAction(temp)
		profile.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IPRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.IpRules = append(profile.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointAccessProfile populates our EndpointAccessProfile from the provided source EndpointAccessProfile
func (profile *EndpointAccessProfile) AssignProperties_From_EndpointAccessProfile(source *storage.EndpointAccessProfile) error {

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := *source.DefaultAction
		defaultActionTemp := genruntime.ToEnum(defaultAction, endpointAccessDefaultAction_Values)
		profile.DefaultAction = &defaultActionTemp
	} else {
		profile.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IPRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			var ipRule IPRule
			err := ipRule.AssignProperties_From_IPRule(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IPRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		profile.IpRules = ipRuleList
	} else {
		profile.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointAccessProfile populates the provided destination EndpointAccessProfile from our EndpointAccessProfile
func (profile *EndpointAccessProfile) AssignProperties_To_EndpointAccessProfile(destination *storage.EndpointAccessProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultAction
	if profile.DefaultAction != nil {
		defaultAction := string(*profile.DefaultAction)
		destination.DefaultAction = &defaultAction
	} else {
		destination.DefaultAction = nil
	}

	// IpRules
	if profile.IpRules != nil {
		ipRuleList := make([]storage.IPRule, len(profile.IpRules))
		for ipRuleIndex, ipRuleItem := range profile.IpRules {
			var ipRule storage.IPRule
			err := ipRuleItem.AssignProperties_To_IPRule(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IPRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointAccessProfile_STATUS populates our EndpointAccessProfile from the provided source EndpointAccessProfile_STATUS
func (profile *EndpointAccessProfile) Initialize_From_EndpointAccessProfile_STATUS(source *EndpointAccessProfile_STATUS) error {

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := genruntime.ToEnum(string(*source.DefaultAction), endpointAccessDefaultAction_Values)
		profile.DefaultAction = &defaultAction
	} else {
		profile.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IPRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			var ipRule IPRule
			err := ipRule.Initialize_From_IPRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IPRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		profile.IpRules = ipRuleList
	} else {
		profile.IpRules = nil
	}

	// No error
	return nil
}

// Network access profile for Batch endpoint.
type EndpointAccessProfile_STATUS struct {
	// DefaultAction: Default action for endpoint access. It is only applicable when publicNetworkAccess is enabled.
	DefaultAction *EndpointAccessDefaultAction_STATUS `json:"defaultAction,omitempty"`

	// IpRules: Array of IP ranges to filter client IP address.
	IpRules []IPRule_STATUS `json:"ipRules,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointAccessProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *EndpointAccessProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointAccessProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *EndpointAccessProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointAccessProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointAccessProfile_STATUS, got %T", armInput)
	}

	// Set property "DefaultAction":
	if typedInput.DefaultAction != nil {
		var temp string
		temp = string(*typedInput.DefaultAction)
		defaultAction := EndpointAccessDefaultAction_STATUS(temp)
		profile.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IPRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.IpRules = append(profile.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointAccessProfile_STATUS populates our EndpointAccessProfile_STATUS from the provided source EndpointAccessProfile_STATUS
func (profile *EndpointAccessProfile_STATUS) AssignProperties_From_EndpointAccessProfile_STATUS(source *storage.EndpointAccessProfile_STATUS) error {

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := *source.DefaultAction
		defaultActionTemp := genruntime.ToEnum(defaultAction, endpointAccessDefaultAction_STATUS_Values)
		profile.DefaultAction = &defaultActionTemp
	} else {
		profile.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IPRule_STATUS, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			var ipRule IPRule_STATUS
			err := ipRule.AssignProperties_From_IPRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IPRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		profile.IpRules = ipRuleList
	} else {
		profile.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointAccessProfile_STATUS populates the provided destination EndpointAccessProfile_STATUS from our EndpointAccessProfile_STATUS
func (profile *EndpointAccessProfile_STATUS) AssignProperties_To_EndpointAccessProfile_STATUS(destination *storage.EndpointAccessProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultAction
	if profile.DefaultAction != nil {
		defaultAction := string(*profile.DefaultAction)
		destination.DefaultAction = &defaultAction
	} else {
		destination.DefaultAction = nil
	}

	// IpRules
	if profile.IpRules != nil {
		ipRuleList := make([]storage.IPRule_STATUS, len(profile.IpRules))
		for ipRuleIndex, ipRuleItem := range profile.IpRules {
			var ipRule storage.IPRule_STATUS
			err := ipRuleItem.AssignProperties_To_IPRule_STATUS(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IPRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of the key source.
// +kubebuilder:validation:Enum={"Microsoft.Batch","Microsoft.KeyVault"}
type KeySource string

const (
	KeySource_MicrosoftBatch    = KeySource("Microsoft.Batch")
	KeySource_MicrosoftKeyVault = KeySource("Microsoft.KeyVault")
)

// Mapping from string to KeySource
var keySource_Values = map[string]KeySource{
	"microsoft.batch":    KeySource_MicrosoftBatch,
	"microsoft.keyvault": KeySource_MicrosoftKeyVault,
}

// Type of the key source.
type KeySource_STATUS string

const (
	KeySource_STATUS_MicrosoftBatch    = KeySource_STATUS("Microsoft.Batch")
	KeySource_STATUS_MicrosoftKeyVault = KeySource_STATUS("Microsoft.KeyVault")
)

// Mapping from string to KeySource_STATUS
var keySource_STATUS_Values = map[string]KeySource_STATUS{
	"microsoft.batch":    KeySource_STATUS_MicrosoftBatch,
	"microsoft.keyvault": KeySource_STATUS_MicrosoftKeyVault,
}

// KeyVault configuration when using an encryption KeySource of Microsoft.KeyVault.
type KeyVaultProperties struct {
	// KeyIdentifier: Full path to the secret with or without version. Example
	// https://mykeyvault.vault.azure.net/keys/testkey/6e34a81fef704045975661e297a4c053. or
	// https://mykeyvault.vault.azure.net/keys/testkey. To be usable the following prerequisites must be met:
	// The Batch Account has a System Assigned identity
	// The account identity has been granted Key/Get, Key/Unwrap and Key/Wrap permissions
	// The KeyVault has soft-delete and purge protection enabled
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *KeyVaultProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.KeyVaultProperties{}

	// Set property "KeyIdentifier":
	if properties.KeyIdentifier != nil {
		keyIdentifier := *properties.KeyIdentifier
		result.KeyIdentifier = &keyIdentifier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyVaultProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyVaultProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultProperties, got %T", armInput)
	}

	// Set property "KeyIdentifier":
	if typedInput.KeyIdentifier != nil {
		keyIdentifier := *typedInput.KeyIdentifier
		properties.KeyIdentifier = &keyIdentifier
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultProperties populates our KeyVaultProperties from the provided source KeyVaultProperties
func (properties *KeyVaultProperties) AssignProperties_From_KeyVaultProperties(source *storage.KeyVaultProperties) error {

	// KeyIdentifier
	properties.KeyIdentifier = genruntime.ClonePointerToString(source.KeyIdentifier)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultProperties populates the provided destination KeyVaultProperties from our KeyVaultProperties
func (properties *KeyVaultProperties) AssignProperties_To_KeyVaultProperties(destination *storage.KeyVaultProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyIdentifier
	destination.KeyIdentifier = genruntime.ClonePointerToString(properties.KeyIdentifier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KeyVaultProperties_STATUS populates our KeyVaultProperties from the provided source KeyVaultProperties_STATUS
func (properties *KeyVaultProperties) Initialize_From_KeyVaultProperties_STATUS(source *KeyVaultProperties_STATUS) error {

	// KeyIdentifier
	properties.KeyIdentifier = genruntime.ClonePointerToString(source.KeyIdentifier)

	// No error
	return nil
}

// KeyVault configuration when using an encryption KeySource of Microsoft.KeyVault.
type KeyVaultProperties_STATUS struct {
	// KeyIdentifier: Full path to the secret with or without version. Example
	// https://mykeyvault.vault.azure.net/keys/testkey/6e34a81fef704045975661e297a4c053. or
	// https://mykeyvault.vault.azure.net/keys/testkey. To be usable the following prerequisites must be met:
	// The Batch Account has a System Assigned identity
	// The account identity has been granted Key/Get, Key/Unwrap and Key/Wrap permissions
	// The KeyVault has soft-delete and purge protection enabled
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyVaultProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyVaultProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultProperties_STATUS, got %T", armInput)
	}

	// Set property "KeyIdentifier":
	if typedInput.KeyIdentifier != nil {
		keyIdentifier := *typedInput.KeyIdentifier
		properties.KeyIdentifier = &keyIdentifier
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultProperties_STATUS populates our KeyVaultProperties_STATUS from the provided source KeyVaultProperties_STATUS
func (properties *KeyVaultProperties_STATUS) AssignProperties_From_KeyVaultProperties_STATUS(source *storage.KeyVaultProperties_STATUS) error {

	// KeyIdentifier
	properties.KeyIdentifier = genruntime.ClonePointerToString(source.KeyIdentifier)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultProperties_STATUS populates the provided destination KeyVaultProperties_STATUS from our KeyVaultProperties_STATUS
func (properties *KeyVaultProperties_STATUS) AssignProperties_To_KeyVaultProperties_STATUS(destination *storage.KeyVaultProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyIdentifier
	destination.KeyIdentifier = genruntime.ClonePointerToString(properties.KeyIdentifier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The type of identity used for the Batch account.
// +kubebuilder:validation:Enum={"None","SystemAssigned","UserAssigned"}
type ResourceIdentityType string

const (
	ResourceIdentityType_None           = ResourceIdentityType("None")
	ResourceIdentityType_SystemAssigned = ResourceIdentityType("SystemAssigned")
	ResourceIdentityType_UserAssigned   = ResourceIdentityType("UserAssigned")
)

// Mapping from string to ResourceIdentityType
var resourceIdentityType_Values = map[string]ResourceIdentityType{
	"none":           ResourceIdentityType_None,
	"systemassigned": ResourceIdentityType_SystemAssigned,
	"userassigned":   ResourceIdentityType_UserAssigned,
}

// The type of identity used for the Batch account.
type ResourceIdentityType_STATUS string

const (
	ResourceIdentityType_STATUS_None           = ResourceIdentityType_STATUS("None")
	ResourceIdentityType_STATUS_SystemAssigned = ResourceIdentityType_STATUS("SystemAssigned")
	ResourceIdentityType_STATUS_UserAssigned   = ResourceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ResourceIdentityType_STATUS
var resourceIdentityType_STATUS_Values = map[string]ResourceIdentityType_STATUS{
	"none":           ResourceIdentityType_STATUS_None,
	"systemassigned": ResourceIdentityType_STATUS_SystemAssigned,
	"userassigned":   ResourceIdentityType_STATUS_UserAssigned,
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// The list of associated user identities.
type UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentities_STATUS populates our UserAssignedIdentities_STATUS from the provided source UserAssignedIdentities_STATUS
func (identities *UserAssignedIdentities_STATUS) AssignProperties_From_UserAssignedIdentities_STATUS(source *storage.UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentities_STATUS populates the provided destination UserAssignedIdentities_STATUS from our UserAssignedIdentities_STATUS
func (identities *UserAssignedIdentities_STATUS) AssignProperties_To_UserAssignedIdentities_STATUS(destination *storage.UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Default action for endpoint access. It is only applicable when publicNetworkAccess is enabled.
// +kubebuilder:validation:Enum={"Allow","Deny"}
type EndpointAccessDefaultAction string

const (
	EndpointAccessDefaultAction_Allow = EndpointAccessDefaultAction("Allow")
	EndpointAccessDefaultAction_Deny  = EndpointAccessDefaultAction("Deny")
)

// Mapping from string to EndpointAccessDefaultAction
var endpointAccessDefaultAction_Values = map[string]EndpointAccessDefaultAction{
	"allow": EndpointAccessDefaultAction_Allow,
	"deny":  EndpointAccessDefaultAction_Deny,
}

// Default action for endpoint access. It is only applicable when publicNetworkAccess is enabled.
type EndpointAccessDefaultAction_STATUS string

const (
	EndpointAccessDefaultAction_STATUS_Allow = EndpointAccessDefaultAction_STATUS("Allow")
	EndpointAccessDefaultAction_STATUS_Deny  = EndpointAccessDefaultAction_STATUS("Deny")
)

// Mapping from string to EndpointAccessDefaultAction_STATUS
var endpointAccessDefaultAction_STATUS_Values = map[string]EndpointAccessDefaultAction_STATUS{
	"allow": EndpointAccessDefaultAction_STATUS_Allow,
	"deny":  EndpointAccessDefaultAction_STATUS_Deny,
}

// Rule to filter client IP address.
type IPRule struct {
	// +kubebuilder:validation:Required
	// Action: Action when client IP address is matched.
	Action *IPRuleAction `json:"action,omitempty"`

	// +kubebuilder:validation:Required
	// Value: IPv4 address, or IPv4 address range in CIDR format.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &IPRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IPRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.IPRule{}

	// Set property "Action":
	if rule.Action != nil {
		var temp string
		temp = string(*rule.Action)
		action := arm.IPRuleAction(temp)
		result.Action = &action
	}

	// Set property "Value":
	if rule.Value != nil {
		value := *rule.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IPRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IPRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IPRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IPRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IPRule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := IPRuleAction(temp)
		rule.Action = &action
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IPRule populates our IPRule from the provided source IPRule
func (rule *IPRule) AssignProperties_From_IPRule(source *storage.IPRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, iPRuleAction_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IPRule populates the provided destination IPRule from our IPRule
func (rule *IPRule) AssignProperties_To_IPRule(destination *storage.IPRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IPRule_STATUS populates our IPRule from the provided source IPRule_STATUS
func (rule *IPRule) Initialize_From_IPRule_STATUS(source *IPRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), iPRuleAction_Values)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Rule to filter client IP address.
type IPRule_STATUS struct {
	// Action: Action when client IP address is matched.
	Action *IPRuleAction_STATUS `json:"action,omitempty"`

	// Value: IPv4 address, or IPv4 address range in CIDR format.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &IPRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IPRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IPRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IPRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IPRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IPRule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := IPRuleAction_STATUS(temp)
		rule.Action = &action
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IPRule_STATUS populates our IPRule_STATUS from the provided source IPRule_STATUS
func (rule *IPRule_STATUS) AssignProperties_From_IPRule_STATUS(source *storage.IPRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, iPRuleAction_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IPRule_STATUS populates the provided destination IPRule_STATUS from our IPRule_STATUS
func (rule *IPRule_STATUS) AssignProperties_To_IPRule_STATUS(destination *storage.IPRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The action when client IP address is matched.
// +kubebuilder:validation:Enum={"Allow"}
type IPRuleAction string

const IPRuleAction_Allow = IPRuleAction("Allow")

// Mapping from string to IPRuleAction
var iPRuleAction_Values = map[string]IPRuleAction{
	"allow": IPRuleAction_Allow,
}

// The action when client IP address is matched.
type IPRuleAction_STATUS string

const IPRuleAction_STATUS_Allow = IPRuleAction_STATUS("Allow")

// Mapping from string to IPRuleAction_STATUS
var iPRuleAction_STATUS_Values = map[string]IPRuleAction_STATUS{
	"allow": IPRuleAction_STATUS_Allow,
}

func init() {
	SchemeBuilder.Register(&BatchAccount{}, &BatchAccountList{})
}
