// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,network}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/TrafficManager/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/AzureEndpoints/{endpointName}
type TrafficManagerProfilesAzureEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TrafficManagerProfilesAzureEndpoint_Spec   `json:"spec,omitempty"`
	Status            TrafficManagerProfilesAzureEndpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &TrafficManagerProfilesAzureEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *TrafficManagerProfilesAzureEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &TrafficManagerProfilesAzureEndpoint{}

// ConvertFrom populates our TrafficManagerProfilesAzureEndpoint from the provided hub TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.TrafficManagerProfilesAzureEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesAzureEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint(source)
}

// ConvertTo populates the provided hub TrafficManagerProfilesAzureEndpoint from our TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.TrafficManagerProfilesAzureEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesAzureEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint(destination)
}

var _ configmaps.Exporter = &TrafficManagerProfilesAzureEndpoint{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (endpoint *TrafficManagerProfilesAzureEndpoint) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &TrafficManagerProfilesAzureEndpoint{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (endpoint *TrafficManagerProfilesAzureEndpoint) SecretDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &TrafficManagerProfilesAzureEndpoint{}

// InitializeSpec initializes the spec for this resource from the given status
func (endpoint *TrafficManagerProfilesAzureEndpoint) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*TrafficManagerProfilesAzureEndpoint_STATUS); ok {
		return endpoint.Spec.Initialize_From_TrafficManagerProfilesAzureEndpoint_STATUS(s)
	}

	return fmt.Errorf("expected Status of type TrafficManagerProfilesAzureEndpoint_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &TrafficManagerProfilesAzureEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-04-01"
func (endpoint TrafficManagerProfilesAzureEndpoint) GetAPIVersion() string {
	return "2022-04-01"
}

// GetResourceScope returns the scope of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/trafficmanagerprofiles/AzureEndpoints"
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetType() string {
	return "Microsoft.Network/trafficmanagerprofiles/AzureEndpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *TrafficManagerProfilesAzureEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &TrafficManagerProfilesAzureEndpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *TrafficManagerProfilesAzureEndpoint) Owner() *genruntime.ResourceReference {
	if endpoint.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*TrafficManagerProfilesAzureEndpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st TrafficManagerProfilesAzureEndpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpoint populates our TrafficManagerProfilesAzureEndpoint from the provided source TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) AssignProperties_From_TrafficManagerProfilesAzureEndpoint(source *storage.TrafficManagerProfilesAzureEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec TrafficManagerProfilesAzureEndpoint_Spec
	err := spec.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status TrafficManagerProfilesAzureEndpoint_STATUS
	err = status.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpoint populates the provided destination TrafficManagerProfilesAzureEndpoint from our TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) AssignProperties_To_TrafficManagerProfilesAzureEndpoint(destination *storage.TrafficManagerProfilesAzureEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.TrafficManagerProfilesAzureEndpoint_Spec
	err := endpoint.Spec.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.TrafficManagerProfilesAzureEndpoint_STATUS
	err = endpoint.Status.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion(),
		Kind:    "TrafficManagerProfilesAzureEndpoint",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/TrafficManager/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/AzureEndpoints/{endpointName}
type TrafficManagerProfilesAzureEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficManagerProfilesAzureEndpoint `json:"items"`
}

type TrafficManagerProfilesAzureEndpoint_Spec struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *AlwaysServe `json:"alwaysServe,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointPropertiesCustomHeadersItem `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointMonitorStatus `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointStatus `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *TrafficManagerProfilesAzureEndpointOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a network.azure.com/TrafficManagerProfile resource
	Owner *genruntime.KnownResourceReference `group:"network.azure.com" json:"owner,omitempty" kind:"TrafficManagerProfile"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointPropertiesSubnetsItem `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceReference: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type
	// 'ExternalEndpoints'.
	TargetResourceReference *genruntime.ResourceReference `armReference:"TargetResourceId" json:"targetResourceReference,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficManagerProfilesAzureEndpoint_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &arm.TrafficManagerProfilesAzureEndpoint_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if endpoint.AlwaysServe != nil ||
		endpoint.CustomHeaders != nil ||
		endpoint.EndpointLocation != nil ||
		endpoint.EndpointMonitorStatus != nil ||
		endpoint.EndpointStatus != nil ||
		endpoint.GeoMapping != nil ||
		endpoint.MinChildEndpoints != nil ||
		endpoint.MinChildEndpointsIPv4 != nil ||
		endpoint.MinChildEndpointsIPv6 != nil ||
		endpoint.Priority != nil ||
		endpoint.Subnets != nil ||
		endpoint.Target != nil ||
		endpoint.TargetResourceReference != nil ||
		endpoint.Weight != nil {
		result.Properties = &arm.EndpointProperties{}
	}
	if endpoint.AlwaysServe != nil {
		var temp string
		temp = string(*endpoint.AlwaysServe)
		alwaysServe := arm.AlwaysServe(temp)
		result.Properties.AlwaysServe = &alwaysServe
	}
	for _, item := range endpoint.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomHeaders = append(result.Properties.CustomHeaders, *item_ARM.(*arm.EndpointPropertiesCustomHeadersItem))
	}
	if endpoint.EndpointLocation != nil {
		endpointLocation := *endpoint.EndpointLocation
		result.Properties.EndpointLocation = &endpointLocation
	}
	if endpoint.EndpointMonitorStatus != nil {
		var temp string
		temp = string(*endpoint.EndpointMonitorStatus)
		endpointMonitorStatus := arm.EndpointMonitorStatus(temp)
		result.Properties.EndpointMonitorStatus = &endpointMonitorStatus
	}
	if endpoint.EndpointStatus != nil {
		var temp string
		temp = string(*endpoint.EndpointStatus)
		endpointStatus := arm.EndpointStatus(temp)
		result.Properties.EndpointStatus = &endpointStatus
	}
	for _, item := range endpoint.GeoMapping {
		result.Properties.GeoMapping = append(result.Properties.GeoMapping, item)
	}
	if endpoint.MinChildEndpoints != nil {
		minChildEndpoints := *endpoint.MinChildEndpoints
		result.Properties.MinChildEndpoints = &minChildEndpoints
	}
	if endpoint.MinChildEndpointsIPv4 != nil {
		minChildEndpointsIPv4 := *endpoint.MinChildEndpointsIPv4
		result.Properties.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
	}
	if endpoint.MinChildEndpointsIPv6 != nil {
		minChildEndpointsIPv6 := *endpoint.MinChildEndpointsIPv6
		result.Properties.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
	}
	if endpoint.Priority != nil {
		priority := *endpoint.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range endpoint.Subnets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Subnets = append(result.Properties.Subnets, *item_ARM.(*arm.EndpointPropertiesSubnetsItem))
	}
	if endpoint.Target != nil {
		target := *endpoint.Target
		result.Properties.Target = &target
	}
	if endpoint.TargetResourceReference != nil {
		targetResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*endpoint.TargetResourceReference)
		if err != nil {
			return nil, err
		}
		targetResourceId := targetResourceIdARMID
		result.Properties.TargetResourceId = &targetResourceId
	}
	if endpoint.Weight != nil {
		weight := *endpoint.Weight
		result.Properties.Weight = &weight
	}

	// Set property "Type":
	if endpoint.Type != nil {
		typeVar := *endpoint.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfilesAzureEndpoint_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfilesAzureEndpoint_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfilesAzureEndpoint_Spec, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := AlwaysServe(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// Set property "AzureName":
	endpoint.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointPropertiesCustomHeadersItem
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointMonitorStatus(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointStatus(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	endpoint.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointPropertiesSubnetsItem
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// no assignment for property "TargetResourceReference"

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &TrafficManagerProfilesAzureEndpoint_Spec{}

// ConvertSpecFrom populates our TrafficManagerProfilesAzureEndpoint_Spec from the provided source
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.TrafficManagerProfilesAzureEndpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfilesAzureEndpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our TrafficManagerProfilesAzureEndpoint_Spec
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.TrafficManagerProfilesAzureEndpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfilesAzureEndpoint_Spec{}
	err := endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec populates our TrafficManagerProfilesAzureEndpoint_Spec from the provided source TrafficManagerProfilesAzureEndpoint_Spec
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(source *storage.TrafficManagerProfilesAzureEndpoint_Spec) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, alwaysServe_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// AzureName
	endpoint.AzureName = source.AzureName

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointPropertiesCustomHeadersItem, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader EndpointPropertiesCustomHeadersItem
			err := customHeader.AssignProperties_From_EndpointPropertiesCustomHeadersItem(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EndpointPropertiesCustomHeadersItem() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointMonitorStatus_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointStatus_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec TrafficManagerProfilesAzureEndpointOperatorSpec
		err := operatorSpec.AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec() to populate field OperatorSpec")
		}
		endpoint.OperatorSpec = &operatorSpec
	} else {
		endpoint.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointPropertiesSubnetsItem, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			var subnet EndpointPropertiesSubnetsItem
			err := subnet.AssignProperties_From_EndpointPropertiesSubnetsItem(&subnetItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EndpointPropertiesSubnetsItem() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceReference != nil {
		targetResourceReference := source.TargetResourceReference.Copy()
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec populates the provided destination TrafficManagerProfilesAzureEndpoint_Spec from our TrafficManagerProfilesAzureEndpoint_Spec
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(destination *storage.TrafficManagerProfilesAzureEndpoint_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// AzureName
	destination.AzureName = endpoint.AzureName

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointPropertiesCustomHeadersItem, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			var customHeader storage.EndpointPropertiesCustomHeadersItem
			err := customHeaderItem.AssignProperties_To_EndpointPropertiesCustomHeadersItem(&customHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EndpointPropertiesCustomHeadersItem() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// OperatorSpec
	if endpoint.OperatorSpec != nil {
		var operatorSpec storage.TrafficManagerProfilesAzureEndpointOperatorSpec
		err := endpoint.OperatorSpec.AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion()

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointPropertiesSubnetsItem, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			var subnet storage.EndpointPropertiesSubnetsItem
			err := subnetItem.AssignProperties_To_EndpointPropertiesSubnetsItem(&subnet)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EndpointPropertiesSubnetsItem() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceReference
	if endpoint.TargetResourceReference != nil {
		targetResourceReference := endpoint.TargetResourceReference.Copy()
		destination.TargetResourceReference = &targetResourceReference
	} else {
		destination.TargetResourceReference = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficManagerProfilesAzureEndpoint_STATUS populates our TrafficManagerProfilesAzureEndpoint_Spec from the provided source TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) Initialize_From_TrafficManagerProfilesAzureEndpoint_STATUS(source *TrafficManagerProfilesAzureEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := genruntime.ToEnum(string(*source.AlwaysServe), alwaysServe_Values)
		endpoint.AlwaysServe = &alwaysServe
	} else {
		endpoint.AlwaysServe = nil
	}

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointPropertiesCustomHeadersItem, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader EndpointPropertiesCustomHeadersItem
			err := customHeader.Initialize_From_EndpointPropertiesCustomHeadersItem_STATUS(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EndpointPropertiesCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := genruntime.ToEnum(string(*source.EndpointMonitorStatus), endpointMonitorStatus_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := genruntime.ToEnum(string(*source.EndpointStatus), endpointStatus_Values)
		endpoint.EndpointStatus = &endpointStatus
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointPropertiesSubnetsItem, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			var subnet EndpointPropertiesSubnetsItem
			err := subnet.Initialize_From_EndpointPropertiesSubnetsItem_STATUS(&subnetItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EndpointPropertiesSubnetsItem_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceId != nil {
		targetResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.TargetResourceId)
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) SetAzureName(azureName string) {
	endpoint.AzureName = azureName
}

type TrafficManagerProfilesAzureEndpoint_STATUS struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *AlwaysServe_STATUS `json:"alwaysServe,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointPropertiesCustomHeadersItem_STATUS `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointMonitorStatus_STATUS `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointStatus_STATUS `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointPropertiesSubnetsItem_STATUS `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceId: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
	TargetResourceId *string `json:"targetResourceId,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ConvertibleStatus = &TrafficManagerProfilesAzureEndpoint_STATUS{}

// ConvertStatusFrom populates our TrafficManagerProfilesAzureEndpoint_STATUS from the provided source
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.TrafficManagerProfilesAzureEndpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfilesAzureEndpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.TrafficManagerProfilesAzureEndpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfilesAzureEndpoint_STATUS{}
	err := endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &TrafficManagerProfilesAzureEndpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfilesAzureEndpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfilesAzureEndpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfilesAzureEndpoint_STATUS, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := AlwaysServe_STATUS(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointPropertiesCustomHeadersItem_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointMonitorStatus_STATUS(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointStatus_STATUS(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointPropertiesSubnetsItem_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// Set property "TargetResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceId != nil {
			targetResourceId := *typedInput.Properties.TargetResourceId
			endpoint.TargetResourceId = &targetResourceId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS populates our TrafficManagerProfilesAzureEndpoint_STATUS from the provided source TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(source *storage.TrafficManagerProfilesAzureEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, alwaysServe_STATUS_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointPropertiesCustomHeadersItem_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader EndpointPropertiesCustomHeadersItem_STATUS
			err := customHeader.AssignProperties_From_EndpointPropertiesCustomHeadersItem_STATUS(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EndpointPropertiesCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointMonitorStatus_STATUS_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointStatus_STATUS_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointPropertiesSubnetsItem_STATUS, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			var subnet EndpointPropertiesSubnetsItem_STATUS
			err := subnet.AssignProperties_From_EndpointPropertiesSubnetsItem_STATUS(&subnetItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EndpointPropertiesSubnetsItem_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceId
	endpoint.TargetResourceId = genruntime.ClonePointerToString(source.TargetResourceId)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS populates the provided destination TrafficManagerProfilesAzureEndpoint_STATUS from our TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(destination *storage.TrafficManagerProfilesAzureEndpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointPropertiesCustomHeadersItem_STATUS, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			var customHeader storage.EndpointPropertiesCustomHeadersItem_STATUS
			err := customHeaderItem.AssignProperties_To_EndpointPropertiesCustomHeadersItem_STATUS(&customHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EndpointPropertiesCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointPropertiesSubnetsItem_STATUS, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			var subnet storage.EndpointPropertiesSubnetsItem_STATUS
			err := subnetItem.AssignProperties_To_EndpointPropertiesSubnetsItem_STATUS(&subnet)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EndpointPropertiesSubnetsItem_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceId
	destination.TargetResourceId = genruntime.ClonePointerToString(endpoint.TargetResourceId)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in the traffic
// routing method.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type AlwaysServe string

const (
	AlwaysServe_Disabled = AlwaysServe("Disabled")
	AlwaysServe_Enabled  = AlwaysServe("Enabled")
)

// Mapping from string to AlwaysServe
var alwaysServe_Values = map[string]AlwaysServe{
	"disabled": AlwaysServe_Disabled,
	"enabled":  AlwaysServe_Enabled,
}

// If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in the traffic
// routing method.
type AlwaysServe_STATUS string

const (
	AlwaysServe_STATUS_Disabled = AlwaysServe_STATUS("Disabled")
	AlwaysServe_STATUS_Enabled  = AlwaysServe_STATUS("Enabled")
)

// Mapping from string to AlwaysServe_STATUS
var alwaysServe_STATUS_Values = map[string]AlwaysServe_STATUS{
	"disabled": AlwaysServe_STATUS_Disabled,
	"enabled":  AlwaysServe_STATUS_Enabled,
}

// The monitoring status of the endpoint.
// +kubebuilder:validation:Enum={"CheckingEndpoint","Degraded","Disabled","Inactive","Online","Stopped","Unmonitored"}
type EndpointMonitorStatus string

const (
	EndpointMonitorStatus_CheckingEndpoint = EndpointMonitorStatus("CheckingEndpoint")
	EndpointMonitorStatus_Degraded         = EndpointMonitorStatus("Degraded")
	EndpointMonitorStatus_Disabled         = EndpointMonitorStatus("Disabled")
	EndpointMonitorStatus_Inactive         = EndpointMonitorStatus("Inactive")
	EndpointMonitorStatus_Online           = EndpointMonitorStatus("Online")
	EndpointMonitorStatus_Stopped          = EndpointMonitorStatus("Stopped")
	EndpointMonitorStatus_Unmonitored      = EndpointMonitorStatus("Unmonitored")
)

// Mapping from string to EndpointMonitorStatus
var endpointMonitorStatus_Values = map[string]EndpointMonitorStatus{
	"checkingendpoint": EndpointMonitorStatus_CheckingEndpoint,
	"degraded":         EndpointMonitorStatus_Degraded,
	"disabled":         EndpointMonitorStatus_Disabled,
	"inactive":         EndpointMonitorStatus_Inactive,
	"online":           EndpointMonitorStatus_Online,
	"stopped":          EndpointMonitorStatus_Stopped,
	"unmonitored":      EndpointMonitorStatus_Unmonitored,
}

// The monitoring status of the endpoint.
type EndpointMonitorStatus_STATUS string

const (
	EndpointMonitorStatus_STATUS_CheckingEndpoint = EndpointMonitorStatus_STATUS("CheckingEndpoint")
	EndpointMonitorStatus_STATUS_Degraded         = EndpointMonitorStatus_STATUS("Degraded")
	EndpointMonitorStatus_STATUS_Disabled         = EndpointMonitorStatus_STATUS("Disabled")
	EndpointMonitorStatus_STATUS_Inactive         = EndpointMonitorStatus_STATUS("Inactive")
	EndpointMonitorStatus_STATUS_Online           = EndpointMonitorStatus_STATUS("Online")
	EndpointMonitorStatus_STATUS_Stopped          = EndpointMonitorStatus_STATUS("Stopped")
	EndpointMonitorStatus_STATUS_Unmonitored      = EndpointMonitorStatus_STATUS("Unmonitored")
)

// Mapping from string to EndpointMonitorStatus_STATUS
var endpointMonitorStatus_STATUS_Values = map[string]EndpointMonitorStatus_STATUS{
	"checkingendpoint": EndpointMonitorStatus_STATUS_CheckingEndpoint,
	"degraded":         EndpointMonitorStatus_STATUS_Degraded,
	"disabled":         EndpointMonitorStatus_STATUS_Disabled,
	"inactive":         EndpointMonitorStatus_STATUS_Inactive,
	"online":           EndpointMonitorStatus_STATUS_Online,
	"stopped":          EndpointMonitorStatus_STATUS_Stopped,
	"unmonitored":      EndpointMonitorStatus_STATUS_Unmonitored,
}

// Custom header name and value.
type EndpointPropertiesCustomHeadersItem struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointPropertiesCustomHeadersItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *EndpointPropertiesCustomHeadersItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.EndpointPropertiesCustomHeadersItem{}

	// Set property "Name":
	if item.Name != nil {
		name := *item.Name
		result.Name = &name
	}

	// Set property "Value":
	if item.Value != nil {
		value := *item.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *EndpointPropertiesCustomHeadersItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointPropertiesCustomHeadersItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *EndpointPropertiesCustomHeadersItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointPropertiesCustomHeadersItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointPropertiesCustomHeadersItem, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		item.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		item.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointPropertiesCustomHeadersItem populates our EndpointPropertiesCustomHeadersItem from the provided source EndpointPropertiesCustomHeadersItem
func (item *EndpointPropertiesCustomHeadersItem) AssignProperties_From_EndpointPropertiesCustomHeadersItem(source *storage.EndpointPropertiesCustomHeadersItem) error {

	// Name
	item.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	item.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EndpointPropertiesCustomHeadersItem populates the provided destination EndpointPropertiesCustomHeadersItem from our EndpointPropertiesCustomHeadersItem
func (item *EndpointPropertiesCustomHeadersItem) AssignProperties_To_EndpointPropertiesCustomHeadersItem(destination *storage.EndpointPropertiesCustomHeadersItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(item.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(item.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointPropertiesCustomHeadersItem_STATUS populates our EndpointPropertiesCustomHeadersItem from the provided source EndpointPropertiesCustomHeadersItem_STATUS
func (item *EndpointPropertiesCustomHeadersItem) Initialize_From_EndpointPropertiesCustomHeadersItem_STATUS(source *EndpointPropertiesCustomHeadersItem_STATUS) error {

	// Name
	item.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	item.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Custom header name and value.
type EndpointPropertiesCustomHeadersItem_STATUS struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointPropertiesCustomHeadersItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *EndpointPropertiesCustomHeadersItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointPropertiesCustomHeadersItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *EndpointPropertiesCustomHeadersItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointPropertiesCustomHeadersItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointPropertiesCustomHeadersItem_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		item.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		item.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointPropertiesCustomHeadersItem_STATUS populates our EndpointPropertiesCustomHeadersItem_STATUS from the provided source EndpointPropertiesCustomHeadersItem_STATUS
func (item *EndpointPropertiesCustomHeadersItem_STATUS) AssignProperties_From_EndpointPropertiesCustomHeadersItem_STATUS(source *storage.EndpointPropertiesCustomHeadersItem_STATUS) error {

	// Name
	item.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	item.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EndpointPropertiesCustomHeadersItem_STATUS populates the provided destination EndpointPropertiesCustomHeadersItem_STATUS from our EndpointPropertiesCustomHeadersItem_STATUS
func (item *EndpointPropertiesCustomHeadersItem_STATUS) AssignProperties_To_EndpointPropertiesCustomHeadersItem_STATUS(destination *storage.EndpointPropertiesCustomHeadersItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(item.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(item.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Subnet first address, scope, and/or last address.
type EndpointPropertiesSubnetsItem struct {
	// First: First address in the subnet.
	First *string `json:"first,omitempty"`

	// Last: Last address in the subnet.
	Last *string `json:"last,omitempty"`

	// Scope: Block size (number of leading bits in the subnet mask).
	Scope *int `json:"scope,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointPropertiesSubnetsItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *EndpointPropertiesSubnetsItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.EndpointPropertiesSubnetsItem{}

	// Set property "First":
	if item.First != nil {
		first := *item.First
		result.First = &first
	}

	// Set property "Last":
	if item.Last != nil {
		last := *item.Last
		result.Last = &last
	}

	// Set property "Scope":
	if item.Scope != nil {
		scope := *item.Scope
		result.Scope = &scope
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *EndpointPropertiesSubnetsItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointPropertiesSubnetsItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *EndpointPropertiesSubnetsItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointPropertiesSubnetsItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointPropertiesSubnetsItem, got %T", armInput)
	}

	// Set property "First":
	if typedInput.First != nil {
		first := *typedInput.First
		item.First = &first
	}

	// Set property "Last":
	if typedInput.Last != nil {
		last := *typedInput.Last
		item.Last = &last
	}

	// Set property "Scope":
	if typedInput.Scope != nil {
		scope := *typedInput.Scope
		item.Scope = &scope
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointPropertiesSubnetsItem populates our EndpointPropertiesSubnetsItem from the provided source EndpointPropertiesSubnetsItem
func (item *EndpointPropertiesSubnetsItem) AssignProperties_From_EndpointPropertiesSubnetsItem(source *storage.EndpointPropertiesSubnetsItem) error {

	// First
	item.First = genruntime.ClonePointerToString(source.First)

	// Last
	item.Last = genruntime.ClonePointerToString(source.Last)

	// Scope
	item.Scope = genruntime.ClonePointerToInt(source.Scope)

	// No error
	return nil
}

// AssignProperties_To_EndpointPropertiesSubnetsItem populates the provided destination EndpointPropertiesSubnetsItem from our EndpointPropertiesSubnetsItem
func (item *EndpointPropertiesSubnetsItem) AssignProperties_To_EndpointPropertiesSubnetsItem(destination *storage.EndpointPropertiesSubnetsItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// First
	destination.First = genruntime.ClonePointerToString(item.First)

	// Last
	destination.Last = genruntime.ClonePointerToString(item.Last)

	// Scope
	destination.Scope = genruntime.ClonePointerToInt(item.Scope)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointPropertiesSubnetsItem_STATUS populates our EndpointPropertiesSubnetsItem from the provided source EndpointPropertiesSubnetsItem_STATUS
func (item *EndpointPropertiesSubnetsItem) Initialize_From_EndpointPropertiesSubnetsItem_STATUS(source *EndpointPropertiesSubnetsItem_STATUS) error {

	// First
	item.First = genruntime.ClonePointerToString(source.First)

	// Last
	item.Last = genruntime.ClonePointerToString(source.Last)

	// Scope
	item.Scope = genruntime.ClonePointerToInt(source.Scope)

	// No error
	return nil
}

// Subnet first address, scope, and/or last address.
type EndpointPropertiesSubnetsItem_STATUS struct {
	// First: First address in the subnet.
	First *string `json:"first,omitempty"`

	// Last: Last address in the subnet.
	Last *string `json:"last,omitempty"`

	// Scope: Block size (number of leading bits in the subnet mask).
	Scope *int `json:"scope,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointPropertiesSubnetsItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *EndpointPropertiesSubnetsItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointPropertiesSubnetsItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *EndpointPropertiesSubnetsItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointPropertiesSubnetsItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointPropertiesSubnetsItem_STATUS, got %T", armInput)
	}

	// Set property "First":
	if typedInput.First != nil {
		first := *typedInput.First
		item.First = &first
	}

	// Set property "Last":
	if typedInput.Last != nil {
		last := *typedInput.Last
		item.Last = &last
	}

	// Set property "Scope":
	if typedInput.Scope != nil {
		scope := *typedInput.Scope
		item.Scope = &scope
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointPropertiesSubnetsItem_STATUS populates our EndpointPropertiesSubnetsItem_STATUS from the provided source EndpointPropertiesSubnetsItem_STATUS
func (item *EndpointPropertiesSubnetsItem_STATUS) AssignProperties_From_EndpointPropertiesSubnetsItem_STATUS(source *storage.EndpointPropertiesSubnetsItem_STATUS) error {

	// First
	item.First = genruntime.ClonePointerToString(source.First)

	// Last
	item.Last = genruntime.ClonePointerToString(source.Last)

	// Scope
	item.Scope = genruntime.ClonePointerToInt(source.Scope)

	// No error
	return nil
}

// AssignProperties_To_EndpointPropertiesSubnetsItem_STATUS populates the provided destination EndpointPropertiesSubnetsItem_STATUS from our EndpointPropertiesSubnetsItem_STATUS
func (item *EndpointPropertiesSubnetsItem_STATUS) AssignProperties_To_EndpointPropertiesSubnetsItem_STATUS(destination *storage.EndpointPropertiesSubnetsItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// First
	destination.First = genruntime.ClonePointerToString(item.First)

	// Last
	destination.Last = genruntime.ClonePointerToString(item.Last)

	// Scope
	destination.Scope = genruntime.ClonePointerToInt(item.Scope)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included in the traffic
// routing method.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type EndpointStatus string

const (
	EndpointStatus_Disabled = EndpointStatus("Disabled")
	EndpointStatus_Enabled  = EndpointStatus("Enabled")
)

// Mapping from string to EndpointStatus
var endpointStatus_Values = map[string]EndpointStatus{
	"disabled": EndpointStatus_Disabled,
	"enabled":  EndpointStatus_Enabled,
}

// The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included in the traffic
// routing method.
type EndpointStatus_STATUS string

const (
	EndpointStatus_STATUS_Disabled = EndpointStatus_STATUS("Disabled")
	EndpointStatus_STATUS_Enabled  = EndpointStatus_STATUS("Enabled")
)

// Mapping from string to EndpointStatus_STATUS
var endpointStatus_STATUS_Values = map[string]EndpointStatus_STATUS{
	"disabled": EndpointStatus_STATUS_Disabled,
	"enabled":  EndpointStatus_STATUS_Enabled,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type TrafficManagerProfilesAzureEndpointOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec populates our TrafficManagerProfilesAzureEndpointOperatorSpec from the provided source TrafficManagerProfilesAzureEndpointOperatorSpec
func (operator *TrafficManagerProfilesAzureEndpointOperatorSpec) AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec(source *storage.TrafficManagerProfilesAzureEndpointOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec populates the provided destination TrafficManagerProfilesAzureEndpointOperatorSpec from our TrafficManagerProfilesAzureEndpointOperatorSpec
func (operator *TrafficManagerProfilesAzureEndpointOperatorSpec) AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec(destination *storage.TrafficManagerProfilesAzureEndpointOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&TrafficManagerProfilesAzureEndpoint{}, &TrafficManagerProfilesAzureEndpointList{})
}
