// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220401

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,network}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/TrafficManager/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}
type TrafficManagerProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TrafficManagerProfile_Spec   `json:"spec,omitempty"`
	Status            TrafficManagerProfile_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &TrafficManagerProfile{}

// GetConditions returns the conditions of the resource
func (profile *TrafficManagerProfile) GetConditions() conditions.Conditions {
	return profile.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (profile *TrafficManagerProfile) SetConditions(conditions conditions.Conditions) {
	profile.Status.Conditions = conditions
}

var _ conversion.Convertible = &TrafficManagerProfile{}

// ConvertFrom populates our TrafficManagerProfile from the provided hub TrafficManagerProfile
func (profile *TrafficManagerProfile) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.TrafficManagerProfile)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfile but received %T instead", hub)
	}

	return profile.AssignProperties_From_TrafficManagerProfile(source)
}

// ConvertTo populates the provided hub TrafficManagerProfile from our TrafficManagerProfile
func (profile *TrafficManagerProfile) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.TrafficManagerProfile)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfile but received %T instead", hub)
	}

	return profile.AssignProperties_To_TrafficManagerProfile(destination)
}

var _ configmaps.Exporter = &TrafficManagerProfile{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (profile *TrafficManagerProfile) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if profile.Spec.OperatorSpec == nil {
		return nil
	}
	return profile.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &TrafficManagerProfile{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (profile *TrafficManagerProfile) SecretDestinationExpressions() []*core.DestinationExpression {
	if profile.Spec.OperatorSpec == nil {
		return nil
	}
	return profile.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &TrafficManagerProfile{}

// InitializeSpec initializes the spec for this resource from the given status
func (profile *TrafficManagerProfile) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*TrafficManagerProfile_STATUS); ok {
		return profile.Spec.Initialize_From_TrafficManagerProfile_STATUS(s)
	}

	return fmt.Errorf("expected Status of type TrafficManagerProfile_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesConfigExporter = &TrafficManagerProfile{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (profile *TrafficManagerProfile) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(profile.Namespace)
	if profile.Spec.OperatorSpec != nil && profile.Spec.OperatorSpec.ConfigMaps != nil {
		if profile.Status.DnsConfig != nil {
			if profile.Status.DnsConfig.Fqdn != nil {
				collector.AddValue(profile.Spec.OperatorSpec.ConfigMaps.DnsConfigFqdn, *profile.Status.DnsConfig.Fqdn)
			}
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &TrafficManagerProfile{}

// AzureName returns the Azure name of the resource
func (profile *TrafficManagerProfile) AzureName() string {
	return profile.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-04-01"
func (profile TrafficManagerProfile) GetAPIVersion() string {
	return "2022-04-01"
}

// GetResourceScope returns the scope of the resource
func (profile *TrafficManagerProfile) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (profile *TrafficManagerProfile) GetSpec() genruntime.ConvertibleSpec {
	return &profile.Spec
}

// GetStatus returns the status of this resource
func (profile *TrafficManagerProfile) GetStatus() genruntime.ConvertibleStatus {
	return &profile.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (profile *TrafficManagerProfile) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/trafficmanagerprofiles"
func (profile *TrafficManagerProfile) GetType() string {
	return "Microsoft.Network/trafficmanagerprofiles"
}

// NewEmptyStatus returns a new empty (blank) status
func (profile *TrafficManagerProfile) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &TrafficManagerProfile_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (profile *TrafficManagerProfile) Owner() *genruntime.ResourceReference {
	if profile.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(profile.Spec)
	return profile.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (profile *TrafficManagerProfile) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*TrafficManagerProfile_STATUS); ok {
		profile.Status = *st
		return nil
	}

	// Convert status to required version
	var st TrafficManagerProfile_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	profile.Status = st
	return nil
}

// AssignProperties_From_TrafficManagerProfile populates our TrafficManagerProfile from the provided source TrafficManagerProfile
func (profile *TrafficManagerProfile) AssignProperties_From_TrafficManagerProfile(source *storage.TrafficManagerProfile) error {

	// ObjectMeta
	profile.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec TrafficManagerProfile_Spec
	err := spec.AssignProperties_From_TrafficManagerProfile_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfile_Spec() to populate field Spec")
	}
	profile.Spec = spec

	// Status
	var status TrafficManagerProfile_STATUS
	err = status.AssignProperties_From_TrafficManagerProfile_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfile_STATUS() to populate field Status")
	}
	profile.Status = status

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfile populates the provided destination TrafficManagerProfile from our TrafficManagerProfile
func (profile *TrafficManagerProfile) AssignProperties_To_TrafficManagerProfile(destination *storage.TrafficManagerProfile) error {

	// ObjectMeta
	destination.ObjectMeta = *profile.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.TrafficManagerProfile_Spec
	err := profile.Spec.AssignProperties_To_TrafficManagerProfile_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfile_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.TrafficManagerProfile_STATUS
	err = profile.Status.AssignProperties_To_TrafficManagerProfile_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfile_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (profile *TrafficManagerProfile) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: profile.Spec.OriginalVersion(),
		Kind:    "TrafficManagerProfile",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/TrafficManager/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}
type TrafficManagerProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficManagerProfile `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-04-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-04-01")

type TrafficManagerProfile_Spec struct {
	// AllowedEndpointRecordTypes: The list of allowed endpoint record types.
	AllowedEndpointRecordTypes []AllowedEndpointRecordType `json:"allowedEndpointRecordTypes,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DnsConfig: The DNS settings of the Traffic Manager profile.
	DnsConfig *DnsConfig `json:"dnsConfig,omitempty"`

	// Location: The Azure Region where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxReturn: Maximum number of endpoints to be returned for MultiValue routing type.
	MaxReturn *int `json:"maxReturn,omitempty"`

	// MonitorConfig: The endpoint monitoring settings of the Traffic Manager profile.
	MonitorConfig *MonitorConfig `json:"monitorConfig,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *TrafficManagerProfileOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// ProfileStatus: The status of the Traffic Manager profile.
	ProfileStatus *ProfileStatus `json:"profileStatus,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrafficRoutingMethod: The traffic routing method of the Traffic Manager profile.
	TrafficRoutingMethod *TrafficRoutingMethod `json:"trafficRoutingMethod,omitempty"`

	// TrafficViewEnrollmentStatus: Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile.
	// Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
	TrafficViewEnrollmentStatus *TrafficViewEnrollmentStatus `json:"trafficViewEnrollmentStatus,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficManagerProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TrafficManagerProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.TrafficManagerProfile_Spec{}

	// Set property "Location":
	if profile.Location != nil {
		location := *profile.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if profile.AllowedEndpointRecordTypes != nil ||
		profile.DnsConfig != nil ||
		profile.MaxReturn != nil ||
		profile.MonitorConfig != nil ||
		profile.ProfileStatus != nil ||
		profile.TrafficRoutingMethod != nil ||
		profile.TrafficViewEnrollmentStatus != nil {
		result.Properties = &arm.ProfileProperties{}
	}
	for _, item := range profile.AllowedEndpointRecordTypes {
		var temp string
		temp = string(item)
		result.Properties.AllowedEndpointRecordTypes = append(result.Properties.AllowedEndpointRecordTypes, arm.AllowedEndpointRecordType(temp))
	}
	if profile.DnsConfig != nil {
		dnsConfig_ARM, err := profile.DnsConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsConfig := *dnsConfig_ARM.(*arm.DnsConfig)
		result.Properties.DnsConfig = &dnsConfig
	}
	if profile.MaxReturn != nil {
		maxReturn := *profile.MaxReturn
		result.Properties.MaxReturn = &maxReturn
	}
	if profile.MonitorConfig != nil {
		monitorConfig_ARM, err := profile.MonitorConfig.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		monitorConfig := *monitorConfig_ARM.(*arm.MonitorConfig)
		result.Properties.MonitorConfig = &monitorConfig
	}
	if profile.ProfileStatus != nil {
		var temp string
		temp = string(*profile.ProfileStatus)
		profileStatus := arm.ProfileStatus(temp)
		result.Properties.ProfileStatus = &profileStatus
	}
	if profile.TrafficRoutingMethod != nil {
		var temp string
		temp = string(*profile.TrafficRoutingMethod)
		trafficRoutingMethod := arm.TrafficRoutingMethod(temp)
		result.Properties.TrafficRoutingMethod = &trafficRoutingMethod
	}
	if profile.TrafficViewEnrollmentStatus != nil {
		var temp string
		temp = string(*profile.TrafficViewEnrollmentStatus)
		trafficViewEnrollmentStatus := arm.TrafficViewEnrollmentStatus(temp)
		result.Properties.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	}

	// Set property "Tags":
	if profile.Tags != nil {
		result.Tags = make(map[string]string, len(profile.Tags))
		for key, value := range profile.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Type":
	if profile.Type != nil {
		typeVar := *profile.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TrafficManagerProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfile_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TrafficManagerProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfile_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfile_Spec, got %T", armInput)
	}

	// Set property "AllowedEndpointRecordTypes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedEndpointRecordTypes {
			var temp string
			temp = string(item)
			profile.AllowedEndpointRecordTypes = append(profile.AllowedEndpointRecordTypes, AllowedEndpointRecordType(temp))
		}
	}

	// Set property "AzureName":
	profile.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DnsConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfig
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			profile.DnsConfig = &dnsConfig
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		profile.Location = &location
	}

	// Set property "MaxReturn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxReturn != nil {
			maxReturn := *typedInput.Properties.MaxReturn
			profile.MaxReturn = &maxReturn
		}
	}

	// Set property "MonitorConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MonitorConfig != nil {
			var monitorConfig1 MonitorConfig
			err := monitorConfig1.PopulateFromARM(owner, *typedInput.Properties.MonitorConfig)
			if err != nil {
				return err
			}
			monitorConfig := monitorConfig1
			profile.MonitorConfig = &monitorConfig
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	profile.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "ProfileStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProfileStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.ProfileStatus)
			profileStatus := ProfileStatus(temp)
			profile.ProfileStatus = &profileStatus
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property "TrafficRoutingMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRoutingMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficRoutingMethod)
			trafficRoutingMethod := TrafficRoutingMethod(temp)
			profile.TrafficRoutingMethod = &trafficRoutingMethod
		}
	}

	// Set property "TrafficViewEnrollmentStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficViewEnrollmentStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficViewEnrollmentStatus)
			trafficViewEnrollmentStatus := TrafficViewEnrollmentStatus(temp)
			profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		profile.Type = &typeVar
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &TrafficManagerProfile_Spec{}

// ConvertSpecFrom populates our TrafficManagerProfile_Spec from the provided source
func (profile *TrafficManagerProfile_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.TrafficManagerProfile_Spec)
	if ok {
		// Populate our instance from source
		return profile.AssignProperties_From_TrafficManagerProfile_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfile_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = profile.AssignProperties_From_TrafficManagerProfile_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our TrafficManagerProfile_Spec
func (profile *TrafficManagerProfile_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.TrafficManagerProfile_Spec)
	if ok {
		// Populate destination from our instance
		return profile.AssignProperties_To_TrafficManagerProfile_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfile_Spec{}
	err := profile.AssignProperties_To_TrafficManagerProfile_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_TrafficManagerProfile_Spec populates our TrafficManagerProfile_Spec from the provided source TrafficManagerProfile_Spec
func (profile *TrafficManagerProfile_Spec) AssignProperties_From_TrafficManagerProfile_Spec(source *storage.TrafficManagerProfile_Spec) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = genruntime.ToEnum(allowedEndpointRecordTypeItem, allowedEndpointRecordType_Values)
		}
		profile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		profile.AllowedEndpointRecordTypes = nil
	}

	// AzureName
	profile.AzureName = source.AzureName

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig
		err := dnsConfig.AssignProperties_From_DnsConfig(source.DnsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DnsConfig() to populate field DnsConfig")
		}
		profile.DnsConfig = &dnsConfig
	} else {
		profile.DnsConfig = nil
	}

	// Location
	profile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	profile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig
		err := monitorConfig.AssignProperties_From_MonitorConfig(source.MonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MonitorConfig() to populate field MonitorConfig")
		}
		profile.MonitorConfig = &monitorConfig
	} else {
		profile.MonitorConfig = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec TrafficManagerProfileOperatorSpec
		err := operatorSpec.AssignProperties_From_TrafficManagerProfileOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfileOperatorSpec() to populate field OperatorSpec")
		}
		profile.OperatorSpec = &operatorSpec
	} else {
		profile.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		profile.Owner = &owner
	} else {
		profile.Owner = nil
	}

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := *source.ProfileStatus
		profileStatusTemp := genruntime.ToEnum(profileStatus, profileStatus_Values)
		profile.ProfileStatus = &profileStatusTemp
	} else {
		profile.ProfileStatus = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := *source.TrafficRoutingMethod
		trafficRoutingMethodTemp := genruntime.ToEnum(trafficRoutingMethod, trafficRoutingMethod_Values)
		profile.TrafficRoutingMethod = &trafficRoutingMethodTemp
	} else {
		profile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := *source.TrafficViewEnrollmentStatus
		trafficViewEnrollmentStatusTemp := genruntime.ToEnum(trafficViewEnrollmentStatus, trafficViewEnrollmentStatus_Values)
		profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatusTemp
	} else {
		profile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfile_Spec populates the provided destination TrafficManagerProfile_Spec from our TrafficManagerProfile_Spec
func (profile *TrafficManagerProfile_Spec) AssignProperties_To_TrafficManagerProfile_Spec(destination *storage.TrafficManagerProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedEndpointRecordTypes
	if profile.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]string, len(profile.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range profile.AllowedEndpointRecordTypes {
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = string(allowedEndpointRecordTypeItem)
		}
		destination.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		destination.AllowedEndpointRecordTypes = nil
	}

	// AzureName
	destination.AzureName = profile.AzureName

	// DnsConfig
	if profile.DnsConfig != nil {
		var dnsConfig storage.DnsConfig
		err := profile.DnsConfig.AssignProperties_To_DnsConfig(&dnsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DnsConfig() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(profile.Location)

	// MaxReturn
	destination.MaxReturn = genruntime.ClonePointerToInt(profile.MaxReturn)

	// MonitorConfig
	if profile.MonitorConfig != nil {
		var monitorConfig storage.MonitorConfig
		err := profile.MonitorConfig.AssignProperties_To_MonitorConfig(&monitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MonitorConfig() to populate field MonitorConfig")
		}
		destination.MonitorConfig = &monitorConfig
	} else {
		destination.MonitorConfig = nil
	}

	// OperatorSpec
	if profile.OperatorSpec != nil {
		var operatorSpec storage.TrafficManagerProfileOperatorSpec
		err := profile.OperatorSpec.AssignProperties_To_TrafficManagerProfileOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfileOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = profile.OriginalVersion()

	// Owner
	if profile.Owner != nil {
		owner := profile.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ProfileStatus
	if profile.ProfileStatus != nil {
		profileStatus := string(*profile.ProfileStatus)
		destination.ProfileStatus = &profileStatus
	} else {
		destination.ProfileStatus = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// TrafficRoutingMethod
	if profile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := string(*profile.TrafficRoutingMethod)
		destination.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		destination.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if profile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := string(*profile.TrafficViewEnrollmentStatus)
		destination.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		destination.TrafficViewEnrollmentStatus = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(profile.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficManagerProfile_STATUS populates our TrafficManagerProfile_Spec from the provided source TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_Spec) Initialize_From_TrafficManagerProfile_STATUS(source *TrafficManagerProfile_STATUS) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			allowedEndpointRecordType := genruntime.ToEnum(string(allowedEndpointRecordTypeItem), allowedEndpointRecordType_Values)
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = allowedEndpointRecordType
		}
		profile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		profile.AllowedEndpointRecordTypes = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig
		err := dnsConfig.Initialize_From_DnsConfig_STATUS(source.DnsConfig)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DnsConfig_STATUS() to populate field DnsConfig")
		}
		profile.DnsConfig = &dnsConfig
	} else {
		profile.DnsConfig = nil
	}

	// Location
	profile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	profile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig
		err := monitorConfig.Initialize_From_MonitorConfig_STATUS(source.MonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		profile.MonitorConfig = &monitorConfig
	} else {
		profile.MonitorConfig = nil
	}

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := genruntime.ToEnum(string(*source.ProfileStatus), profileStatus_Values)
		profile.ProfileStatus = &profileStatus
	} else {
		profile.ProfileStatus = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := genruntime.ToEnum(string(*source.TrafficRoutingMethod), trafficRoutingMethod_Values)
		profile.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		profile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := genruntime.ToEnum(string(*source.TrafficViewEnrollmentStatus), trafficViewEnrollmentStatus_Values)
		profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		profile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (profile *TrafficManagerProfile_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (profile *TrafficManagerProfile_Spec) SetAzureName(azureName string) {
	profile.AzureName = azureName
}

type TrafficManagerProfile_STATUS struct {
	// AllowedEndpointRecordTypes: The list of allowed endpoint record types.
	AllowedEndpointRecordTypes []AllowedEndpointRecordType_STATUS `json:"allowedEndpointRecordTypes,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DnsConfig: The DNS settings of the Traffic Manager profile.
	DnsConfig *DnsConfig_STATUS `json:"dnsConfig,omitempty"`

	// Endpoints: The list of endpoints in the Traffic Manager profile.
	Endpoints []Endpoint_STATUS `json:"endpoints,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// Location: The Azure Region where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxReturn: Maximum number of endpoints to be returned for MultiValue routing type.
	MaxReturn *int `json:"maxReturn,omitempty"`

	// MonitorConfig: The endpoint monitoring settings of the Traffic Manager profile.
	MonitorConfig *MonitorConfig_STATUS `json:"monitorConfig,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// ProfileStatus: The status of the Traffic Manager profile.
	ProfileStatus *ProfileStatus_STATUS `json:"profileStatus,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrafficRoutingMethod: The traffic routing method of the Traffic Manager profile.
	TrafficRoutingMethod *TrafficRoutingMethod_STATUS `json:"trafficRoutingMethod,omitempty"`

	// TrafficViewEnrollmentStatus: Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile.
	// Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
	TrafficViewEnrollmentStatus *TrafficViewEnrollmentStatus_STATUS `json:"trafficViewEnrollmentStatus,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &TrafficManagerProfile_STATUS{}

// ConvertStatusFrom populates our TrafficManagerProfile_STATUS from the provided source
func (profile *TrafficManagerProfile_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.TrafficManagerProfile_STATUS)
	if ok {
		// Populate our instance from source
		return profile.AssignProperties_From_TrafficManagerProfile_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfile_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = profile.AssignProperties_From_TrafficManagerProfile_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.TrafficManagerProfile_STATUS)
	if ok {
		// Populate destination from our instance
		return profile.AssignProperties_To_TrafficManagerProfile_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfile_STATUS{}
	err := profile.AssignProperties_To_TrafficManagerProfile_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &TrafficManagerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TrafficManagerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TrafficManagerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfile_STATUS, got %T", armInput)
	}

	// Set property "AllowedEndpointRecordTypes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedEndpointRecordTypes {
			var temp string
			temp = string(item)
			profile.AllowedEndpointRecordTypes = append(profile.AllowedEndpointRecordTypes, AllowedEndpointRecordType_STATUS(temp))
		}
	}

	// no assignment for property "Conditions"

	// Set property "DnsConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfig_STATUS
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			profile.DnsConfig = &dnsConfig
		}
	}

	// Set property "Endpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Endpoints {
			var item1 Endpoint_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			profile.Endpoints = append(profile.Endpoints, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		profile.Location = &location
	}

	// Set property "MaxReturn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxReturn != nil {
			maxReturn := *typedInput.Properties.MaxReturn
			profile.MaxReturn = &maxReturn
		}
	}

	// Set property "MonitorConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MonitorConfig != nil {
			var monitorConfig1 MonitorConfig_STATUS
			err := monitorConfig1.PopulateFromARM(owner, *typedInput.Properties.MonitorConfig)
			if err != nil {
				return err
			}
			monitorConfig := monitorConfig1
			profile.MonitorConfig = &monitorConfig
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "ProfileStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProfileStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.ProfileStatus)
			profileStatus := ProfileStatus_STATUS(temp)
			profile.ProfileStatus = &profileStatus
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property "TrafficRoutingMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRoutingMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficRoutingMethod)
			trafficRoutingMethod := TrafficRoutingMethod_STATUS(temp)
			profile.TrafficRoutingMethod = &trafficRoutingMethod
		}
	}

	// Set property "TrafficViewEnrollmentStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficViewEnrollmentStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficViewEnrollmentStatus)
			trafficViewEnrollmentStatus := TrafficViewEnrollmentStatus_STATUS(temp)
			profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		profile.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficManagerProfile_STATUS populates our TrafficManagerProfile_STATUS from the provided source TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_STATUS) AssignProperties_From_TrafficManagerProfile_STATUS(source *storage.TrafficManagerProfile_STATUS) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType_STATUS, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = genruntime.ToEnum(allowedEndpointRecordTypeItem, allowedEndpointRecordType_STATUS_Values)
		}
		profile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		profile.AllowedEndpointRecordTypes = nil
	}

	// Conditions
	profile.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig_STATUS
		err := dnsConfig.AssignProperties_From_DnsConfig_STATUS(source.DnsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DnsConfig_STATUS() to populate field DnsConfig")
		}
		profile.DnsConfig = &dnsConfig
	} else {
		profile.DnsConfig = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint_STATUS, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			var endpoint Endpoint_STATUS
			err := endpoint.AssignProperties_From_Endpoint_STATUS(&endpointItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		profile.Endpoints = endpointList
	} else {
		profile.Endpoints = nil
	}

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	profile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	profile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig_STATUS
		err := monitorConfig.AssignProperties_From_MonitorConfig_STATUS(source.MonitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		profile.MonitorConfig = &monitorConfig
	} else {
		profile.MonitorConfig = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := *source.ProfileStatus
		profileStatusTemp := genruntime.ToEnum(profileStatus, profileStatus_STATUS_Values)
		profile.ProfileStatus = &profileStatusTemp
	} else {
		profile.ProfileStatus = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := *source.TrafficRoutingMethod
		trafficRoutingMethodTemp := genruntime.ToEnum(trafficRoutingMethod, trafficRoutingMethod_STATUS_Values)
		profile.TrafficRoutingMethod = &trafficRoutingMethodTemp
	} else {
		profile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := *source.TrafficViewEnrollmentStatus
		trafficViewEnrollmentStatusTemp := genruntime.ToEnum(trafficViewEnrollmentStatus, trafficViewEnrollmentStatus_STATUS_Values)
		profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatusTemp
	} else {
		profile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfile_STATUS populates the provided destination TrafficManagerProfile_STATUS from our TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_STATUS) AssignProperties_To_TrafficManagerProfile_STATUS(destination *storage.TrafficManagerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedEndpointRecordTypes
	if profile.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]string, len(profile.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range profile.AllowedEndpointRecordTypes {
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = string(allowedEndpointRecordTypeItem)
		}
		destination.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		destination.AllowedEndpointRecordTypes = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(profile.Conditions)

	// DnsConfig
	if profile.DnsConfig != nil {
		var dnsConfig storage.DnsConfig_STATUS
		err := profile.DnsConfig.AssignProperties_To_DnsConfig_STATUS(&dnsConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DnsConfig_STATUS() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// Endpoints
	if profile.Endpoints != nil {
		endpointList := make([]storage.Endpoint_STATUS, len(profile.Endpoints))
		for endpointIndex, endpointItem := range profile.Endpoints {
			var endpoint storage.Endpoint_STATUS
			err := endpointItem.AssignProperties_To_Endpoint_STATUS(&endpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		destination.Endpoints = endpointList
	} else {
		destination.Endpoints = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(profile.Location)

	// MaxReturn
	destination.MaxReturn = genruntime.ClonePointerToInt(profile.MaxReturn)

	// MonitorConfig
	if profile.MonitorConfig != nil {
		var monitorConfig storage.MonitorConfig_STATUS
		err := profile.MonitorConfig.AssignProperties_To_MonitorConfig_STATUS(&monitorConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		destination.MonitorConfig = &monitorConfig
	} else {
		destination.MonitorConfig = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// ProfileStatus
	if profile.ProfileStatus != nil {
		profileStatus := string(*profile.ProfileStatus)
		destination.ProfileStatus = &profileStatus
	} else {
		destination.ProfileStatus = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// TrafficRoutingMethod
	if profile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := string(*profile.TrafficRoutingMethod)
		destination.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		destination.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if profile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := string(*profile.TrafficViewEnrollmentStatus)
		destination.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		destination.TrafficViewEnrollmentStatus = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(profile.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The allowed type DNS record types for this profile.
// +kubebuilder:validation:Enum={"Any","DomainName","IPv4Address","IPv6Address"}
type AllowedEndpointRecordType string

const (
	AllowedEndpointRecordType_Any         = AllowedEndpointRecordType("Any")
	AllowedEndpointRecordType_DomainName  = AllowedEndpointRecordType("DomainName")
	AllowedEndpointRecordType_IPv4Address = AllowedEndpointRecordType("IPv4Address")
	AllowedEndpointRecordType_IPv6Address = AllowedEndpointRecordType("IPv6Address")
)

// Mapping from string to AllowedEndpointRecordType
var allowedEndpointRecordType_Values = map[string]AllowedEndpointRecordType{
	"any":         AllowedEndpointRecordType_Any,
	"domainname":  AllowedEndpointRecordType_DomainName,
	"ipv4address": AllowedEndpointRecordType_IPv4Address,
	"ipv6address": AllowedEndpointRecordType_IPv6Address,
}

// The allowed type DNS record types for this profile.
type AllowedEndpointRecordType_STATUS string

const (
	AllowedEndpointRecordType_STATUS_Any         = AllowedEndpointRecordType_STATUS("Any")
	AllowedEndpointRecordType_STATUS_DomainName  = AllowedEndpointRecordType_STATUS("DomainName")
	AllowedEndpointRecordType_STATUS_IPv4Address = AllowedEndpointRecordType_STATUS("IPv4Address")
	AllowedEndpointRecordType_STATUS_IPv6Address = AllowedEndpointRecordType_STATUS("IPv6Address")
)

// Mapping from string to AllowedEndpointRecordType_STATUS
var allowedEndpointRecordType_STATUS_Values = map[string]AllowedEndpointRecordType_STATUS{
	"any":         AllowedEndpointRecordType_STATUS_Any,
	"domainname":  AllowedEndpointRecordType_STATUS_DomainName,
	"ipv4address": AllowedEndpointRecordType_STATUS_IPv4Address,
	"ipv6address": AllowedEndpointRecordType_STATUS_IPv6Address,
}

// Class containing DNS settings in a Traffic Manager profile.
type DnsConfig struct {
	// RelativeName: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain
	// name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
	RelativeName *string `json:"relativeName,omitempty"`

	// Ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS
	// responses provided by this Traffic Manager profile.
	Ttl *int `json:"ttl,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *DnsConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.DnsConfig{}

	// Set property "RelativeName":
	if config.RelativeName != nil {
		relativeName := *config.RelativeName
		result.RelativeName = &relativeName
	}

	// Set property "Ttl":
	if config.Ttl != nil {
		ttl := *config.Ttl
		result.Ttl = &ttl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *DnsConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *DnsConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsConfig, got %T", armInput)
	}

	// Set property "RelativeName":
	if typedInput.RelativeName != nil {
		relativeName := *typedInput.RelativeName
		config.RelativeName = &relativeName
	}

	// Set property "Ttl":
	if typedInput.Ttl != nil {
		ttl := *typedInput.Ttl
		config.Ttl = &ttl
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfig populates our DnsConfig from the provided source DnsConfig
func (config *DnsConfig) AssignProperties_From_DnsConfig(source *storage.DnsConfig) error {

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// AssignProperties_To_DnsConfig populates the provided destination DnsConfig from our DnsConfig
func (config *DnsConfig) AssignProperties_To_DnsConfig(destination *storage.DnsConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RelativeName
	destination.RelativeName = genruntime.ClonePointerToString(config.RelativeName)

	// Ttl
	destination.Ttl = genruntime.ClonePointerToInt(config.Ttl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DnsConfig_STATUS populates our DnsConfig from the provided source DnsConfig_STATUS
func (config *DnsConfig) Initialize_From_DnsConfig_STATUS(source *DnsConfig_STATUS) error {

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// Class containing DNS settings in a Traffic Manager profile.
type DnsConfig_STATUS struct {
	// Fqdn: The fully-qualified domain name (FQDN) of the Traffic Manager profile. This is formed from the concatenation of
	// the RelativeName with the DNS domain used by Azure Traffic Manager.
	Fqdn *string `json:"fqdn,omitempty"`

	// RelativeName: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain
	// name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
	RelativeName *string `json:"relativeName,omitempty"`

	// Ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS
	// responses provided by this Traffic Manager profile.
	Ttl *int `json:"ttl,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *DnsConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *DnsConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsConfig_STATUS, got %T", armInput)
	}

	// Set property "Fqdn":
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		config.Fqdn = &fqdn
	}

	// Set property "RelativeName":
	if typedInput.RelativeName != nil {
		relativeName := *typedInput.RelativeName
		config.RelativeName = &relativeName
	}

	// Set property "Ttl":
	if typedInput.Ttl != nil {
		ttl := *typedInput.Ttl
		config.Ttl = &ttl
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfig_STATUS populates our DnsConfig_STATUS from the provided source DnsConfig_STATUS
func (config *DnsConfig_STATUS) AssignProperties_From_DnsConfig_STATUS(source *storage.DnsConfig_STATUS) error {

	// Fqdn
	config.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// AssignProperties_To_DnsConfig_STATUS populates the provided destination DnsConfig_STATUS from our DnsConfig_STATUS
func (config *DnsConfig_STATUS) AssignProperties_To_DnsConfig_STATUS(destination *storage.DnsConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(config.Fqdn)

	// RelativeName
	destination.RelativeName = genruntime.ClonePointerToString(config.RelativeName)

	// Ttl
	destination.Ttl = genruntime.ClonePointerToInt(config.Ttl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class representing a Traffic Manager endpoint.
type Endpoint_STATUS struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *AlwaysServe_STATUS `json:"alwaysServe,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointPropertiesCustomHeadersItem_STATUS `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointMonitorStatus_STATUS `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointStatus_STATUS `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointPropertiesSubnetsItem_STATUS `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceId: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
	TargetResourceId *string `json:"targetResourceId,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.FromARMConverter = &Endpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Endpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Endpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Endpoint_STATUS, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := AlwaysServe_STATUS(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointPropertiesCustomHeadersItem_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointMonitorStatus_STATUS(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointStatus_STATUS(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointPropertiesSubnetsItem_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// Set property "TargetResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceId != nil {
			targetResourceId := *typedInput.Properties.TargetResourceId
			endpoint.TargetResourceId = &targetResourceId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Endpoint_STATUS populates our Endpoint_STATUS from the provided source Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_From_Endpoint_STATUS(source *storage.Endpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, alwaysServe_STATUS_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointPropertiesCustomHeadersItem_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader EndpointPropertiesCustomHeadersItem_STATUS
			err := customHeader.AssignProperties_From_EndpointPropertiesCustomHeadersItem_STATUS(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EndpointPropertiesCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointMonitorStatus_STATUS_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointStatus_STATUS_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointPropertiesSubnetsItem_STATUS, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			var subnet EndpointPropertiesSubnetsItem_STATUS
			err := subnet.AssignProperties_From_EndpointPropertiesSubnetsItem_STATUS(&subnetItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EndpointPropertiesSubnetsItem_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceId
	endpoint.TargetResourceId = genruntime.ClonePointerToString(source.TargetResourceId)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_Endpoint_STATUS populates the provided destination Endpoint_STATUS from our Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_To_Endpoint_STATUS(destination *storage.Endpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointPropertiesCustomHeadersItem_STATUS, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			var customHeader storage.EndpointPropertiesCustomHeadersItem_STATUS
			err := customHeaderItem.AssignProperties_To_EndpointPropertiesCustomHeadersItem_STATUS(&customHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EndpointPropertiesCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointPropertiesSubnetsItem_STATUS, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			var subnet storage.EndpointPropertiesSubnetsItem_STATUS
			err := subnetItem.AssignProperties_To_EndpointPropertiesSubnetsItem_STATUS(&subnet)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EndpointPropertiesSubnetsItem_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceId
	destination.TargetResourceId = genruntime.ClonePointerToString(endpoint.TargetResourceId)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing endpoint monitoring settings in a Traffic Manager profile.
type MonitorConfig struct {
	// CustomHeaders: List of custom headers.
	CustomHeaders []MonitorConfigCustomHeadersItem `json:"customHeaders,omitempty"`

	// ExpectedStatusCodeRanges: List of expected status code ranges.
	ExpectedStatusCodeRanges []MonitorConfigExpectedStatusCodeRangesItem `json:"expectedStatusCodeRanges,omitempty"`

	// IntervalInSeconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager
	// will check the health of each endpoint in this profile.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Path: The path relative to the endpoint domain name used to probe for endpoint health.
	Path *string `json:"path,omitempty"`

	// Port: The TCP port used to probe for endpoint health.
	Port *int `json:"port,omitempty"`

	// ProfileMonitorStatus: The profile-level monitoring status of the Traffic Manager profile.
	ProfileMonitorStatus *ProfileMonitorStatus `json:"profileMonitorStatus,omitempty"`

	// Protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
	Protocol *MonitorProtocol `json:"protocol,omitempty"`

	// TimeoutInSeconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows
	// endpoints in this profile to response to the health check.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// ToleratedNumberOfFailures: The number of consecutive failed health check that Traffic Manager tolerates before declaring
	// an endpoint in this profile Degraded after the next failed health check.
	ToleratedNumberOfFailures *int `json:"toleratedNumberOfFailures,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *MonitorConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.MonitorConfig{}

	// Set property "CustomHeaders":
	for _, item := range config.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.CustomHeaders = append(result.CustomHeaders, *item_ARM.(*arm.MonitorConfigCustomHeadersItem))
	}

	// Set property "ExpectedStatusCodeRanges":
	for _, item := range config.ExpectedStatusCodeRanges {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ExpectedStatusCodeRanges = append(result.ExpectedStatusCodeRanges, *item_ARM.(*arm.MonitorConfigExpectedStatusCodeRangesItem))
	}

	// Set property "IntervalInSeconds":
	if config.IntervalInSeconds != nil {
		intervalInSeconds := *config.IntervalInSeconds
		result.IntervalInSeconds = &intervalInSeconds
	}

	// Set property "Path":
	if config.Path != nil {
		path := *config.Path
		result.Path = &path
	}

	// Set property "Port":
	if config.Port != nil {
		port := *config.Port
		result.Port = &port
	}

	// Set property "ProfileMonitorStatus":
	if config.ProfileMonitorStatus != nil {
		var temp string
		temp = string(*config.ProfileMonitorStatus)
		profileMonitorStatus := arm.ProfileMonitorStatus(temp)
		result.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property "Protocol":
	if config.Protocol != nil {
		var temp string
		temp = string(*config.Protocol)
		protocol := arm.MonitorProtocol(temp)
		result.Protocol = &protocol
	}

	// Set property "TimeoutInSeconds":
	if config.TimeoutInSeconds != nil {
		timeoutInSeconds := *config.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "ToleratedNumberOfFailures":
	if config.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *config.ToleratedNumberOfFailures
		result.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *MonitorConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *MonitorConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig, got %T", armInput)
	}

	// Set property "CustomHeaders":
	for _, item := range typedInput.CustomHeaders {
		var item1 MonitorConfigCustomHeadersItem
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.CustomHeaders = append(config.CustomHeaders, item1)
	}

	// Set property "ExpectedStatusCodeRanges":
	for _, item := range typedInput.ExpectedStatusCodeRanges {
		var item1 MonitorConfigExpectedStatusCodeRangesItem
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ExpectedStatusCodeRanges = append(config.ExpectedStatusCodeRanges, item1)
	}

	// Set property "IntervalInSeconds":
	if typedInput.IntervalInSeconds != nil {
		intervalInSeconds := *typedInput.IntervalInSeconds
		config.IntervalInSeconds = &intervalInSeconds
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		config.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		config.Port = &port
	}

	// Set property "ProfileMonitorStatus":
	if typedInput.ProfileMonitorStatus != nil {
		var temp string
		temp = string(*typedInput.ProfileMonitorStatus)
		profileMonitorStatus := ProfileMonitorStatus(temp)
		config.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := MonitorProtocol(temp)
		config.Protocol = &protocol
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		config.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "ToleratedNumberOfFailures":
	if typedInput.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *typedInput.ToleratedNumberOfFailures
		config.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig populates our MonitorConfig from the provided source MonitorConfig
func (config *MonitorConfig) AssignProperties_From_MonitorConfig(source *storage.MonitorConfig) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfigCustomHeadersItem, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader MonitorConfigCustomHeadersItem
			err := customHeader.AssignProperties_From_MonitorConfigCustomHeadersItem(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitorConfigCustomHeadersItem() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfigExpectedStatusCodeRangesItem, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			var expectedStatusCodeRange MonitorConfigExpectedStatusCodeRangesItem
			err := expectedStatusCodeRange.AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem(&expectedStatusCodeRangeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := *source.ProfileMonitorStatus
		profileMonitorStatusTemp := genruntime.ToEnum(profileMonitorStatus, profileMonitorStatus_Values)
		config.ProfileMonitorStatus = &profileMonitorStatusTemp
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, monitorProtocol_Values)
		config.Protocol = &protocolTemp
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig populates the provided destination MonitorConfig from our MonitorConfig
func (config *MonitorConfig) AssignProperties_To_MonitorConfig(destination *storage.MonitorConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHeaders
	if config.CustomHeaders != nil {
		customHeaderList := make([]storage.MonitorConfigCustomHeadersItem, len(config.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range config.CustomHeaders {
			var customHeader storage.MonitorConfigCustomHeadersItem
			err := customHeaderItem.AssignProperties_To_MonitorConfigCustomHeadersItem(&customHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitorConfigCustomHeadersItem() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if config.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]storage.MonitorConfigExpectedStatusCodeRangesItem, len(config.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range config.ExpectedStatusCodeRanges {
			var expectedStatusCodeRange storage.MonitorConfigExpectedStatusCodeRangesItem
			err := expectedStatusCodeRangeItem.AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem(&expectedStatusCodeRange)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		destination.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		destination.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(config.IntervalInSeconds)

	// Path
	destination.Path = genruntime.ClonePointerToString(config.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(config.Port)

	// ProfileMonitorStatus
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := string(*config.ProfileMonitorStatus)
		destination.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		destination.ProfileMonitorStatus = nil
	}

	// Protocol
	if config.Protocol != nil {
		protocol := string(*config.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(config.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	destination.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(config.ToleratedNumberOfFailures)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitorConfig_STATUS populates our MonitorConfig from the provided source MonitorConfig_STATUS
func (config *MonitorConfig) Initialize_From_MonitorConfig_STATUS(source *MonitorConfig_STATUS) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfigCustomHeadersItem, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader MonitorConfigCustomHeadersItem
			err := customHeader.Initialize_From_MonitorConfigCustomHeadersItem_STATUS(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_MonitorConfigCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfigExpectedStatusCodeRangesItem, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			var expectedStatusCodeRange MonitorConfigExpectedStatusCodeRangesItem
			err := expectedStatusCodeRange.Initialize_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS(&expectedStatusCodeRangeItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := genruntime.ToEnum(string(*source.ProfileMonitorStatus), profileMonitorStatus_Values)
		config.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), monitorProtocol_Values)
		config.Protocol = &protocol
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// Class containing endpoint monitoring settings in a Traffic Manager profile.
type MonitorConfig_STATUS struct {
	// CustomHeaders: List of custom headers.
	CustomHeaders []MonitorConfigCustomHeadersItem_STATUS `json:"customHeaders,omitempty"`

	// ExpectedStatusCodeRanges: List of expected status code ranges.
	ExpectedStatusCodeRanges []MonitorConfigExpectedStatusCodeRangesItem_STATUS `json:"expectedStatusCodeRanges,omitempty"`

	// IntervalInSeconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager
	// will check the health of each endpoint in this profile.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Path: The path relative to the endpoint domain name used to probe for endpoint health.
	Path *string `json:"path,omitempty"`

	// Port: The TCP port used to probe for endpoint health.
	Port *int `json:"port,omitempty"`

	// ProfileMonitorStatus: The profile-level monitoring status of the Traffic Manager profile.
	ProfileMonitorStatus *ProfileMonitorStatus_STATUS `json:"profileMonitorStatus,omitempty"`

	// Protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
	Protocol *MonitorProtocol_STATUS `json:"protocol,omitempty"`

	// TimeoutInSeconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows
	// endpoints in this profile to response to the health check.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// ToleratedNumberOfFailures: The number of consecutive failed health check that Traffic Manager tolerates before declaring
	// an endpoint in this profile Degraded after the next failed health check.
	ToleratedNumberOfFailures *int `json:"toleratedNumberOfFailures,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *MonitorConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *MonitorConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig_STATUS, got %T", armInput)
	}

	// Set property "CustomHeaders":
	for _, item := range typedInput.CustomHeaders {
		var item1 MonitorConfigCustomHeadersItem_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.CustomHeaders = append(config.CustomHeaders, item1)
	}

	// Set property "ExpectedStatusCodeRanges":
	for _, item := range typedInput.ExpectedStatusCodeRanges {
		var item1 MonitorConfigExpectedStatusCodeRangesItem_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ExpectedStatusCodeRanges = append(config.ExpectedStatusCodeRanges, item1)
	}

	// Set property "IntervalInSeconds":
	if typedInput.IntervalInSeconds != nil {
		intervalInSeconds := *typedInput.IntervalInSeconds
		config.IntervalInSeconds = &intervalInSeconds
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		config.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		config.Port = &port
	}

	// Set property "ProfileMonitorStatus":
	if typedInput.ProfileMonitorStatus != nil {
		var temp string
		temp = string(*typedInput.ProfileMonitorStatus)
		profileMonitorStatus := ProfileMonitorStatus_STATUS(temp)
		config.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := MonitorProtocol_STATUS(temp)
		config.Protocol = &protocol
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		config.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "ToleratedNumberOfFailures":
	if typedInput.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *typedInput.ToleratedNumberOfFailures
		config.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_STATUS populates our MonitorConfig_STATUS from the provided source MonitorConfig_STATUS
func (config *MonitorConfig_STATUS) AssignProperties_From_MonitorConfig_STATUS(source *storage.MonitorConfig_STATUS) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfigCustomHeadersItem_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			var customHeader MonitorConfigCustomHeadersItem_STATUS
			err := customHeader.AssignProperties_From_MonitorConfigCustomHeadersItem_STATUS(&customHeaderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitorConfigCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfigExpectedStatusCodeRangesItem_STATUS, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			var expectedStatusCodeRange MonitorConfigExpectedStatusCodeRangesItem_STATUS
			err := expectedStatusCodeRange.AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS(&expectedStatusCodeRangeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := *source.ProfileMonitorStatus
		profileMonitorStatusTemp := genruntime.ToEnum(profileMonitorStatus, profileMonitorStatus_STATUS_Values)
		config.ProfileMonitorStatus = &profileMonitorStatusTemp
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, monitorProtocol_STATUS_Values)
		config.Protocol = &protocolTemp
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_STATUS populates the provided destination MonitorConfig_STATUS from our MonitorConfig_STATUS
func (config *MonitorConfig_STATUS) AssignProperties_To_MonitorConfig_STATUS(destination *storage.MonitorConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHeaders
	if config.CustomHeaders != nil {
		customHeaderList := make([]storage.MonitorConfigCustomHeadersItem_STATUS, len(config.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range config.CustomHeaders {
			var customHeader storage.MonitorConfigCustomHeadersItem_STATUS
			err := customHeaderItem.AssignProperties_To_MonitorConfigCustomHeadersItem_STATUS(&customHeader)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitorConfigCustomHeadersItem_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if config.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]storage.MonitorConfigExpectedStatusCodeRangesItem_STATUS, len(config.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range config.ExpectedStatusCodeRanges {
			var expectedStatusCodeRange storage.MonitorConfigExpectedStatusCodeRangesItem_STATUS
			err := expectedStatusCodeRangeItem.AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem_STATUS(&expectedStatusCodeRange)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		destination.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		destination.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(config.IntervalInSeconds)

	// Path
	destination.Path = genruntime.ClonePointerToString(config.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(config.Port)

	// ProfileMonitorStatus
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := string(*config.ProfileMonitorStatus)
		destination.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		destination.ProfileMonitorStatus = nil
	}

	// Protocol
	if config.Protocol != nil {
		protocol := string(*config.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(config.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	destination.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(config.ToleratedNumberOfFailures)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The status of the Traffic Manager profile.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ProfileStatus string

const (
	ProfileStatus_Disabled = ProfileStatus("Disabled")
	ProfileStatus_Enabled  = ProfileStatus("Enabled")
)

// Mapping from string to ProfileStatus
var profileStatus_Values = map[string]ProfileStatus{
	"disabled": ProfileStatus_Disabled,
	"enabled":  ProfileStatus_Enabled,
}

// The status of the Traffic Manager profile.
type ProfileStatus_STATUS string

const (
	ProfileStatus_STATUS_Disabled = ProfileStatus_STATUS("Disabled")
	ProfileStatus_STATUS_Enabled  = ProfileStatus_STATUS("Enabled")
)

// Mapping from string to ProfileStatus_STATUS
var profileStatus_STATUS_Values = map[string]ProfileStatus_STATUS{
	"disabled": ProfileStatus_STATUS_Disabled,
	"enabled":  ProfileStatus_STATUS_Enabled,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type TrafficManagerProfileOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *TrafficManagerProfileOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_TrafficManagerProfileOperatorSpec populates our TrafficManagerProfileOperatorSpec from the provided source TrafficManagerProfileOperatorSpec
func (operator *TrafficManagerProfileOperatorSpec) AssignProperties_From_TrafficManagerProfileOperatorSpec(source *storage.TrafficManagerProfileOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap TrafficManagerProfileOperatorConfigMaps
		err := configMap.AssignProperties_From_TrafficManagerProfileOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TrafficManagerProfileOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfileOperatorSpec populates the provided destination TrafficManagerProfileOperatorSpec from our TrafficManagerProfileOperatorSpec
func (operator *TrafficManagerProfileOperatorSpec) AssignProperties_To_TrafficManagerProfileOperatorSpec(destination *storage.TrafficManagerProfileOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.TrafficManagerProfileOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_TrafficManagerProfileOperatorConfigMaps(&configMap)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TrafficManagerProfileOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The traffic routing method of the Traffic Manager profile.
// +kubebuilder:validation:Enum={"Geographic","MultiValue","Performance","Priority","Subnet","Weighted"}
type TrafficRoutingMethod string

const (
	TrafficRoutingMethod_Geographic  = TrafficRoutingMethod("Geographic")
	TrafficRoutingMethod_MultiValue  = TrafficRoutingMethod("MultiValue")
	TrafficRoutingMethod_Performance = TrafficRoutingMethod("Performance")
	TrafficRoutingMethod_Priority    = TrafficRoutingMethod("Priority")
	TrafficRoutingMethod_Subnet      = TrafficRoutingMethod("Subnet")
	TrafficRoutingMethod_Weighted    = TrafficRoutingMethod("Weighted")
)

// Mapping from string to TrafficRoutingMethod
var trafficRoutingMethod_Values = map[string]TrafficRoutingMethod{
	"geographic":  TrafficRoutingMethod_Geographic,
	"multivalue":  TrafficRoutingMethod_MultiValue,
	"performance": TrafficRoutingMethod_Performance,
	"priority":    TrafficRoutingMethod_Priority,
	"subnet":      TrafficRoutingMethod_Subnet,
	"weighted":    TrafficRoutingMethod_Weighted,
}

// The traffic routing method of the Traffic Manager profile.
type TrafficRoutingMethod_STATUS string

const (
	TrafficRoutingMethod_STATUS_Geographic  = TrafficRoutingMethod_STATUS("Geographic")
	TrafficRoutingMethod_STATUS_MultiValue  = TrafficRoutingMethod_STATUS("MultiValue")
	TrafficRoutingMethod_STATUS_Performance = TrafficRoutingMethod_STATUS("Performance")
	TrafficRoutingMethod_STATUS_Priority    = TrafficRoutingMethod_STATUS("Priority")
	TrafficRoutingMethod_STATUS_Subnet      = TrafficRoutingMethod_STATUS("Subnet")
	TrafficRoutingMethod_STATUS_Weighted    = TrafficRoutingMethod_STATUS("Weighted")
)

// Mapping from string to TrafficRoutingMethod_STATUS
var trafficRoutingMethod_STATUS_Values = map[string]TrafficRoutingMethod_STATUS{
	"geographic":  TrafficRoutingMethod_STATUS_Geographic,
	"multivalue":  TrafficRoutingMethod_STATUS_MultiValue,
	"performance": TrafficRoutingMethod_STATUS_Performance,
	"priority":    TrafficRoutingMethod_STATUS_Priority,
	"subnet":      TrafficRoutingMethod_STATUS_Subnet,
	"weighted":    TrafficRoutingMethod_STATUS_Weighted,
}

// Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile. Null, indicates 'Disabled'.
// Enabling this feature will increase the cost of the Traffic Manage profile.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type TrafficViewEnrollmentStatus string

const (
	TrafficViewEnrollmentStatus_Disabled = TrafficViewEnrollmentStatus("Disabled")
	TrafficViewEnrollmentStatus_Enabled  = TrafficViewEnrollmentStatus("Enabled")
)

// Mapping from string to TrafficViewEnrollmentStatus
var trafficViewEnrollmentStatus_Values = map[string]TrafficViewEnrollmentStatus{
	"disabled": TrafficViewEnrollmentStatus_Disabled,
	"enabled":  TrafficViewEnrollmentStatus_Enabled,
}

// Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile. Null, indicates 'Disabled'.
// Enabling this feature will increase the cost of the Traffic Manage profile.
type TrafficViewEnrollmentStatus_STATUS string

const (
	TrafficViewEnrollmentStatus_STATUS_Disabled = TrafficViewEnrollmentStatus_STATUS("Disabled")
	TrafficViewEnrollmentStatus_STATUS_Enabled  = TrafficViewEnrollmentStatus_STATUS("Enabled")
)

// Mapping from string to TrafficViewEnrollmentStatus_STATUS
var trafficViewEnrollmentStatus_STATUS_Values = map[string]TrafficViewEnrollmentStatus_STATUS{
	"disabled": TrafficViewEnrollmentStatus_STATUS_Disabled,
	"enabled":  TrafficViewEnrollmentStatus_STATUS_Enabled,
}

// Custom header name and value.
type MonitorConfigCustomHeadersItem struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfigCustomHeadersItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *MonitorConfigCustomHeadersItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.MonitorConfigCustomHeadersItem{}

	// Set property "Name":
	if item.Name != nil {
		name := *item.Name
		result.Name = &name
	}

	// Set property "Value":
	if item.Value != nil {
		value := *item.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *MonitorConfigCustomHeadersItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfigCustomHeadersItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *MonitorConfigCustomHeadersItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfigCustomHeadersItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfigCustomHeadersItem, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		item.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		item.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfigCustomHeadersItem populates our MonitorConfigCustomHeadersItem from the provided source MonitorConfigCustomHeadersItem
func (item *MonitorConfigCustomHeadersItem) AssignProperties_From_MonitorConfigCustomHeadersItem(source *storage.MonitorConfigCustomHeadersItem) error {

	// Name
	item.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	item.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfigCustomHeadersItem populates the provided destination MonitorConfigCustomHeadersItem from our MonitorConfigCustomHeadersItem
func (item *MonitorConfigCustomHeadersItem) AssignProperties_To_MonitorConfigCustomHeadersItem(destination *storage.MonitorConfigCustomHeadersItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(item.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(item.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitorConfigCustomHeadersItem_STATUS populates our MonitorConfigCustomHeadersItem from the provided source MonitorConfigCustomHeadersItem_STATUS
func (item *MonitorConfigCustomHeadersItem) Initialize_From_MonitorConfigCustomHeadersItem_STATUS(source *MonitorConfigCustomHeadersItem_STATUS) error {

	// Name
	item.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	item.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Custom header name and value.
type MonitorConfigCustomHeadersItem_STATUS struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfigCustomHeadersItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *MonitorConfigCustomHeadersItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfigCustomHeadersItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *MonitorConfigCustomHeadersItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfigCustomHeadersItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfigCustomHeadersItem_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		item.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		item.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfigCustomHeadersItem_STATUS populates our MonitorConfigCustomHeadersItem_STATUS from the provided source MonitorConfigCustomHeadersItem_STATUS
func (item *MonitorConfigCustomHeadersItem_STATUS) AssignProperties_From_MonitorConfigCustomHeadersItem_STATUS(source *storage.MonitorConfigCustomHeadersItem_STATUS) error {

	// Name
	item.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	item.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfigCustomHeadersItem_STATUS populates the provided destination MonitorConfigCustomHeadersItem_STATUS from our MonitorConfigCustomHeadersItem_STATUS
func (item *MonitorConfigCustomHeadersItem_STATUS) AssignProperties_To_MonitorConfigCustomHeadersItem_STATUS(destination *storage.MonitorConfigCustomHeadersItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(item.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(item.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Min and max value of a status code range.
type MonitorConfigExpectedStatusCodeRangesItem struct {
	// Max: Max status code.
	Max *int `json:"max,omitempty"`

	// Min: Min status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfigExpectedStatusCodeRangesItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *MonitorConfigExpectedStatusCodeRangesItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.MonitorConfigExpectedStatusCodeRangesItem{}

	// Set property "Max":
	if item.Max != nil {
		max := *item.Max
		result.Max = &max
	}

	// Set property "Min":
	if item.Min != nil {
		min := *item.Min
		result.Min = &min
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *MonitorConfigExpectedStatusCodeRangesItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfigExpectedStatusCodeRangesItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *MonitorConfigExpectedStatusCodeRangesItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfigExpectedStatusCodeRangesItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfigExpectedStatusCodeRangesItem, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		item.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		item.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem populates our MonitorConfigExpectedStatusCodeRangesItem from the provided source MonitorConfigExpectedStatusCodeRangesItem
func (item *MonitorConfigExpectedStatusCodeRangesItem) AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem(source *storage.MonitorConfigExpectedStatusCodeRangesItem) error {

	// Max
	item.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	item.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem populates the provided destination MonitorConfigExpectedStatusCodeRangesItem from our MonitorConfigExpectedStatusCodeRangesItem
func (item *MonitorConfigExpectedStatusCodeRangesItem) AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem(destination *storage.MonitorConfigExpectedStatusCodeRangesItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(item.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(item.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS populates our MonitorConfigExpectedStatusCodeRangesItem from the provided source MonitorConfigExpectedStatusCodeRangesItem_STATUS
func (item *MonitorConfigExpectedStatusCodeRangesItem) Initialize_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS(source *MonitorConfigExpectedStatusCodeRangesItem_STATUS) error {

	// Max
	item.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	item.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// Min and max value of a status code range.
type MonitorConfigExpectedStatusCodeRangesItem_STATUS struct {
	// Max: Max status code.
	Max *int `json:"max,omitempty"`

	// Min: Min status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfigExpectedStatusCodeRangesItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *MonitorConfigExpectedStatusCodeRangesItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfigExpectedStatusCodeRangesItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *MonitorConfigExpectedStatusCodeRangesItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfigExpectedStatusCodeRangesItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfigExpectedStatusCodeRangesItem_STATUS, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		item.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		item.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS populates our MonitorConfigExpectedStatusCodeRangesItem_STATUS from the provided source MonitorConfigExpectedStatusCodeRangesItem_STATUS
func (item *MonitorConfigExpectedStatusCodeRangesItem_STATUS) AssignProperties_From_MonitorConfigExpectedStatusCodeRangesItem_STATUS(source *storage.MonitorConfigExpectedStatusCodeRangesItem_STATUS) error {

	// Max
	item.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	item.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem_STATUS populates the provided destination MonitorConfigExpectedStatusCodeRangesItem_STATUS from our MonitorConfigExpectedStatusCodeRangesItem_STATUS
func (item *MonitorConfigExpectedStatusCodeRangesItem_STATUS) AssignProperties_To_MonitorConfigExpectedStatusCodeRangesItem_STATUS(destination *storage.MonitorConfigExpectedStatusCodeRangesItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(item.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(item.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
// +kubebuilder:validation:Enum={"HTTP","HTTPS","TCP"}
type MonitorProtocol string

const (
	MonitorProtocol_HTTP  = MonitorProtocol("HTTP")
	MonitorProtocol_HTTPS = MonitorProtocol("HTTPS")
	MonitorProtocol_TCP   = MonitorProtocol("TCP")
)

// Mapping from string to MonitorProtocol
var monitorProtocol_Values = map[string]MonitorProtocol{
	"http":  MonitorProtocol_HTTP,
	"https": MonitorProtocol_HTTPS,
	"tcp":   MonitorProtocol_TCP,
}

// The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
type MonitorProtocol_STATUS string

const (
	MonitorProtocol_STATUS_HTTP  = MonitorProtocol_STATUS("HTTP")
	MonitorProtocol_STATUS_HTTPS = MonitorProtocol_STATUS("HTTPS")
	MonitorProtocol_STATUS_TCP   = MonitorProtocol_STATUS("TCP")
)

// Mapping from string to MonitorProtocol_STATUS
var monitorProtocol_STATUS_Values = map[string]MonitorProtocol_STATUS{
	"http":  MonitorProtocol_STATUS_HTTP,
	"https": MonitorProtocol_STATUS_HTTPS,
	"tcp":   MonitorProtocol_STATUS_TCP,
}

// The profile-level monitoring status of the Traffic Manager profile.
// +kubebuilder:validation:Enum={"CheckingEndpoints","Degraded","Disabled","Inactive","Online"}
type ProfileMonitorStatus string

const (
	ProfileMonitorStatus_CheckingEndpoints = ProfileMonitorStatus("CheckingEndpoints")
	ProfileMonitorStatus_Degraded          = ProfileMonitorStatus("Degraded")
	ProfileMonitorStatus_Disabled          = ProfileMonitorStatus("Disabled")
	ProfileMonitorStatus_Inactive          = ProfileMonitorStatus("Inactive")
	ProfileMonitorStatus_Online            = ProfileMonitorStatus("Online")
)

// Mapping from string to ProfileMonitorStatus
var profileMonitorStatus_Values = map[string]ProfileMonitorStatus{
	"checkingendpoints": ProfileMonitorStatus_CheckingEndpoints,
	"degraded":          ProfileMonitorStatus_Degraded,
	"disabled":          ProfileMonitorStatus_Disabled,
	"inactive":          ProfileMonitorStatus_Inactive,
	"online":            ProfileMonitorStatus_Online,
}

// The profile-level monitoring status of the Traffic Manager profile.
type ProfileMonitorStatus_STATUS string

const (
	ProfileMonitorStatus_STATUS_CheckingEndpoints = ProfileMonitorStatus_STATUS("CheckingEndpoints")
	ProfileMonitorStatus_STATUS_Degraded          = ProfileMonitorStatus_STATUS("Degraded")
	ProfileMonitorStatus_STATUS_Disabled          = ProfileMonitorStatus_STATUS("Disabled")
	ProfileMonitorStatus_STATUS_Inactive          = ProfileMonitorStatus_STATUS("Inactive")
	ProfileMonitorStatus_STATUS_Online            = ProfileMonitorStatus_STATUS("Online")
)

// Mapping from string to ProfileMonitorStatus_STATUS
var profileMonitorStatus_STATUS_Values = map[string]ProfileMonitorStatus_STATUS{
	"checkingendpoints": ProfileMonitorStatus_STATUS_CheckingEndpoints,
	"degraded":          ProfileMonitorStatus_STATUS_Degraded,
	"disabled":          ProfileMonitorStatus_STATUS_Disabled,
	"inactive":          ProfileMonitorStatus_STATUS_Inactive,
	"online":            ProfileMonitorStatus_STATUS_Online,
}

type TrafficManagerProfileOperatorConfigMaps struct {
	// DnsConfigFqdn: indicates where the DnsConfigFqdn config map should be placed. If omitted, no config map will be created.
	DnsConfigFqdn *genruntime.ConfigMapDestination `json:"dnsConfigFqdn,omitempty"`
}

// AssignProperties_From_TrafficManagerProfileOperatorConfigMaps populates our TrafficManagerProfileOperatorConfigMaps from the provided source TrafficManagerProfileOperatorConfigMaps
func (maps *TrafficManagerProfileOperatorConfigMaps) AssignProperties_From_TrafficManagerProfileOperatorConfigMaps(source *storage.TrafficManagerProfileOperatorConfigMaps) error {

	// DnsConfigFqdn
	if source.DnsConfigFqdn != nil {
		dnsConfigFqdn := source.DnsConfigFqdn.Copy()
		maps.DnsConfigFqdn = &dnsConfigFqdn
	} else {
		maps.DnsConfigFqdn = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfileOperatorConfigMaps populates the provided destination TrafficManagerProfileOperatorConfigMaps from our TrafficManagerProfileOperatorConfigMaps
func (maps *TrafficManagerProfileOperatorConfigMaps) AssignProperties_To_TrafficManagerProfileOperatorConfigMaps(destination *storage.TrafficManagerProfileOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsConfigFqdn
	if maps.DnsConfigFqdn != nil {
		dnsConfigFqdn := maps.DnsConfigFqdn.Copy()
		destination.DnsConfigFqdn = &dnsConfigFqdn
	} else {
		destination.DnsConfigFqdn = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&TrafficManagerProfile{}, &TrafficManagerProfileList{})
}
